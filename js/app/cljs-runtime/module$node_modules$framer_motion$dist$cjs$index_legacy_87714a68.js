import "./cljs_env.js";
import "./shadow.js.js";
shadow$provide.module$node_modules$framer_motion$dist$cjs$index_legacy_87714a68=function(global,require,module,exports){function isRefObject(ref){return ref&&"object"===typeof ref&&Object.prototype.hasOwnProperty.call(ref,"current")}function isVariantLabel(v){return"string"===typeof v||Array.isArray(v)}function isAnimationControls(v){return null!==v&&"object"===typeof v&&"function"===typeof v.start}function isControllingVariants(props){return isAnimationControls(props.animate)||variantProps.some(name=>
isVariantLabel(props[name]))}function isVariantNode(props){return!(!isControllingVariants(props)&&!props.variants)}function isForcedMotionValue(key,{layout,layoutId}){return transformProps.has(key)||key.startsWith("origin")||(layout||void 0!==layoutId)&&(!!scaleCorrectors[key]||"opacity"===key)}function buildTransform(transform,{enableHardwareAcceleration=!0,allowTransformNone=!0},transformIsDefault,transformTemplate){let transformString="";for(let i=0;i<numTransforms;i++){const key=transformPropOrder[i];
void 0!==transform[key]&&(transformString+=`${translateAlias[key]||key}(${transform[key]}) `)}enableHardwareAcceleration&&!transform.z&&(transformString+="translateZ(0)");transformString=transformString.trim();transformTemplate?transformString=transformTemplate(transform,transformIsDefault?"":transformString):allowTransformNone&&transformIsDefault&&(transformString="none");return transformString}function isString(v){return"string"===typeof v}function buildHTMLStyles(state,latestValues,options,transformTemplate){const {style,
vars,transform,transformOrigin}=state;let hasTransform=!1,hasTransformOrigin=!1,transformIsNone=!0;for(const key in latestValues){const value=latestValues[key];if(isCSSVariableName(key)){vars[key]=value;continue}const valueType=numberValueTypes[key];var value$jscomp$0=value;value$jscomp$0=valueType&&"number"===typeof value$jscomp$0?valueType.transform(value$jscomp$0):value$jscomp$0;transformProps.has(key)?(hasTransform=!0,transform[key]=value$jscomp$0,transformIsNone&&value!==(valueType.default||
0)&&(transformIsNone=!1)):key.startsWith("origin")?(hasTransformOrigin=!0,transformOrigin[key]=value$jscomp$0):style[key]=value$jscomp$0}latestValues.transform||(hasTransform||transformTemplate?style.transform=buildTransform(state.transform,options,transformIsNone,transformTemplate):style.transform&&(style.transform="none"));if(hasTransformOrigin){const {originX="50%",originY="50%",originZ=0}=transformOrigin;style.transformOrigin=`${originX} ${originY} ${originZ}`}}function buildSVGPath(attrs,length,
spacing=1,offset=0,useDashCase=!0){attrs.pathLength=1;useDashCase=useDashCase?dashKeys:camelKeys;attrs[useDashCase.offset]=px.transform(-offset);length=px.transform(length);spacing=px.transform(spacing);attrs[useDashCase.array]=`${length} ${spacing}`}function buildSVGAttrs(state,{attrX,attrY,attrScale,originX,originY,pathLength,pathSpacing=1,pathOffset=0,...latest},options,isSVGTag,transformTemplate){buildHTMLStyles(state,latest,options,transformTemplate);if(isSVGTag)state.style.viewBox&&(state.attrs.viewBox=
state.style.viewBox);else{state.attrs=state.style;state.style={};var {attrs,style,dimensions}=state;attrs.transform&&(dimensions&&(style.transform=attrs.transform),delete attrs.transform);dimensions&&(void 0!==originX||void 0!==originY||style.transform)&&(state=void 0!==originY?originY:.5,originX=void 0!==originX?originX:.5,originX="string"===typeof originX?originX:px.transform(dimensions.x+dimensions.width*originX),state="string"===typeof state?state:px.transform(dimensions.y+dimensions.height*state),
style.transformOrigin=`${originX} ${state}`);void 0!==attrX&&(attrs.x=attrX);void 0!==attrY&&(attrs.y=attrY);void 0!==attrScale&&(attrs.scale=attrScale);void 0!==pathLength&&buildSVGPath(attrs,pathLength,pathSpacing,pathOffset,!1)}}function renderHTML(element,{style,vars},styleProp,projection){Object.assign(element.style,style,projection&&projection.getProjectionStyles(styleProp));for(const key in vars)element.style.setProperty(key,vars[key])}function renderSVG(element,renderState,_styleProp,projection){renderHTML(element,
renderState,void 0,projection);for(const key in renderState.attrs)element.setAttribute(camelCaseAttributes.has(key)?key:camelToDash(key),renderState.attrs[key])}function scrapeMotionValuesFromProps$1(props,prevProps){const {style}=props,newValues={};for(const key in style){var value=style[key];!(value=!(!value||!value.getVelocity))&&(value=prevProps.style)&&(value=prevProps.style[key],value=!(!value||!value.getVelocity));if(value||isForcedMotionValue(key,props))newValues[key]=style[key]}return newValues}
function scrapeMotionValuesFromProps(props,prevProps){const newValues=scrapeMotionValuesFromProps$1(props,prevProps);for(const key in props){var value=props[key];(value=!(!value||!value.getVelocity))||(value=prevProps[key],value=!(!value||!value.getVelocity));value&&(value=-1!==transformPropOrder.indexOf(key)?"attr"+key.charAt(0).toUpperCase()+key.substring(1):key,newValues[value]=props[key])}return newValues}function resolveVariantFromProps(props,definition,custom,currentValues={},currentVelocity=
{}){"function"===typeof definition&&(definition=definition(void 0!==custom?custom:props.custom,currentValues,currentVelocity));"string"===typeof definition&&(definition=props.variants&&props.variants[definition]);"function"===typeof definition&&(definition=definition(void 0!==custom?custom:props.custom,currentValues,currentVelocity));return definition}function createRenderStep(runNextFrame){let thisFrame=new Queue,nextFrame=new Queue,numToRun=0,isProcessing=!1,flushNextFrame=!1;const toKeepAlive=
new WeakSet,step={schedule:(callback,keepAlive=!1,immediate=!1)=>{const queue=(immediate=immediate&&isProcessing)?thisFrame:nextFrame;keepAlive&&toKeepAlive.add(callback);queue.add(callback)&&immediate&&isProcessing&&(numToRun=thisFrame.order.length);return callback},cancel:callback=>{nextFrame.remove(callback);toKeepAlive.delete(callback)},process:frameData=>{if(isProcessing)flushNextFrame=!0;else{isProcessing=!0;[thisFrame,nextFrame]=[nextFrame,thisFrame];nextFrame.clear();if(numToRun=thisFrame.order.length)for(let i=
0;i<numToRun;i++){const callback=thisFrame.order[i];callback(frameData);toKeepAlive.has(callback)&&(step.schedule(callback),runNextFrame())}isProcessing=!1;flushNextFrame&&(flushNextFrame=!1,step.process(frameData))}}};return step}function getCurrent(visualElement){const current={};visualElement.values.forEach((value,key)=>current[key]=value.get());return current}function getVelocity(visualElement){const velocity={};visualElement.values.forEach((value,key)=>velocity[key]=value.getVelocity());return velocity}
function resolveVariant(visualElement,definition,custom){const props=visualElement.getProps();return resolveVariantFromProps(props,definition,void 0!==custom?custom:props.custom,getCurrent(visualElement),getVelocity(visualElement))}function isWaapiSupportedEasing(easing){return!!(!easing||"string"===typeof easing&&supportedWaapiEasing[easing]||isBezierDefinition(easing)||Array.isArray(easing)&&easing.every(isWaapiSupportedEasing))}function mapEasingToNativeEasing(easing){if(easing)return isBezierDefinition(easing)?
cubicBezierAsString(easing):Array.isArray(easing)?easing.map(mapEasingToNativeEasing):supportedWaapiEasing[easing]}function animateStyle(element,valueName,keyframes,{delay=0,duration,repeat=0,repeatType="loop",ease,times}={}){valueName={[valueName]:keyframes};times&&(valueName.offset=times);ease=mapEasingToNativeEasing(ease);Array.isArray(ease)&&(valueName.easing=ease);return element.animate(valueName,{delay,duration,easing:Array.isArray(ease)?"linear":ease,fill:"both",iterations:repeat+1,direction:"reverse"===
repeatType?"alternate":"normal"})}function getFinalKeyframe(keyframes,{repeat,repeatType="loop"}){return keyframes[repeat&&"loop"!==repeatType&&1===repeat%2?0:keyframes.length-1]}function cubicBezier(mX1,mY1,mX2,mY2){return mX1===mY1&&mX2===mY2?noop:t=>{if(0!==t&&1!==t){var lowerBound=0,upperBound=1;let currentX,currentT,i=0;do currentT=lowerBound+(upperBound-lowerBound)/2,currentX=(((1-3*mX2+3*mX1)*currentT+(3*mX2-6*mX1))*currentT+3*mX1)*currentT-t,0<currentX?upperBound=currentT:lowerBound=currentT;
while(1E-7<Math.abs(currentX)&&12>++i);t=currentT;t*=((1-3*mY2+3*mY1)*t+(3*mY2-6*mY1))*t+3*mY1}return t}}function hueToRgb(p,q,t){0>t&&(t+=1);1<t&&--t;return t<1/6?p+6*(q-p)*t:.5>t?q:t<2/3?p+(q-p)*(2/3-t)*6:p}function hslaToRgba({hue,saturation,lightness,alpha}){hue/=360;saturation/=100;lightness/=100;if(saturation){const q=.5>lightness?lightness*(1+saturation):lightness+saturation-lightness*saturation,p=2*lightness-q;lightness=hueToRgb(p,q,hue+1/3);saturation=hueToRgb(p,q,hue);hue=hueToRgb(p,q,hue-
1/3)}else lightness=saturation=hue=lightness;return{red:Math.round(255*lightness),green:Math.round(255*saturation),blue:Math.round(255*hue),alpha}}function asRGBA(color){const type=getColorType(color);exports.invariant(!!type,`'${color}' is not an animatable color. Use the equivalent color code instead.`);color=type.parse(color);type===hsla&&(color=hslaToRgba(color));return color}function tokenise(info,{regex,countKey,token,parse}){const matches=info.tokenised.match(regex);matches&&(info["num"+countKey]=
matches.length,info.tokenised=info.tokenised.replace(regex,token),info.values.push(...matches.map(parse)))}function analyseComplexValue(value){value=value.toString();value={value,tokenised:value,values:[],numVars:0,numColors:0,numNumbers:0};value.value.includes("var(--")&&tokenise(value,cssVarTokeniser);tokenise(value,colorTokeniser);tokenise(value,numberTokeniser);return value}function parseComplexValue(v){return analyseComplexValue(v).values}function createTransformer(source){const {values,numColors,
numVars,tokenised}=analyseComplexValue(source),numValues=values.length;return v=>{let output=tokenised;for(let i=0;i<numValues;i++)output=i<numVars?output.replace(cssVarTokeniser.token,v[i]):i<numVars+numColors?output.replace(colorTokeniser.token,color$jscomp$0.transform(v[i])):output.replace(numberTokeniser.token,Math.round(1E5*v[i])/1E5);return output}}function getMixer$1(origin,target){return"number"===typeof origin?v=>-v*origin+v*target+origin:color$jscomp$0.test(origin)?mixColor(origin,target):
origin.startsWith("var(")?mixImmediate(origin,target):mixComplex(origin,target)}function detectMixerFactory(v){if("number"!==typeof v){if("string"===typeof v)return color$jscomp$0.test(v)?mixColor:mixComplex;if(Array.isArray(v))return mixArray;if("object"===typeof v)return mixObject}return mixNumber}function createMixers(output,ease,customMixer){const mixers=[];customMixer=customMixer||detectMixerFactory(output[0]);const numMixers=output.length-1;for(let i=0;i<numMixers;i++){let mixer=customMixer(output[i],
output[i+1]);ease&&(mixer=[Array.isArray(ease)?ease[i]||noop:ease,mixer].reduce(combineFunctions));mixers.push(mixer)}return mixers}function interpolate(input,output,{clamp:isClamp=!0,ease,mixer}={}){const inputLength=input.length;exports.invariant(inputLength===output.length,"Both input and output ranges must be the same length");if(1===inputLength)return()=>output[0];input[0]>input[inputLength-1]&&(input=[...input].reverse(),output=[...output].reverse());const mixers=createMixers(output,ease,mixer),
numMixers=mixers.length,interpolator=v=>{let i=0;if(1<numMixers)for(;i<input.length-2&&!(v<input[i+1]);i++);v=progress(input[i],input[i+1],v);return mixers[i](v)};return isClamp?v=>interpolator(clamp(input[0],input[inputLength-1],v)):interpolator}function fillOffset(offset,remaining){const min=offset[offset.length-1];for(let i=1;i<=remaining;i++){const offsetProgress=progress(0,remaining,i);offset.push(-offsetProgress*min+1*offsetProgress+min)}}function defaultOffset$1(arr){const offset=[0];fillOffset(offset,
arr.length-1);return offset}function convertOffsetToTimes(offset,duration){return offset.map(o=>o*duration)}function defaultEasing(values,easing){return values.map(()=>easing||easeInOut).splice(0,values.length-1)}function keyframes({duration=300,keyframes:keyframeValues,times,ease="easeInOut"}){ease=isEasingArray(ease)?ease.map(easingDefinitionToFunction):easingDefinitionToFunction(ease);const state={done:!1,value:keyframeValues[0]};times=convertOffsetToTimes(times&&times.length===keyframeValues.length?
times:defaultOffset$1(keyframeValues),duration);const mapTimeToKeyframe=interpolate(times,keyframeValues,{ease:Array.isArray(ease)?ease:defaultEasing(keyframeValues,ease)});return{calculatedDuration:duration,next:t=>{state.value=mapTimeToKeyframe(t);state.done=t>=duration;return state}}}function calcGeneratorVelocity(resolveValue,t,current){const prevT=Math.max(t-5,0);resolveValue=current-resolveValue(prevT);return(t-=prevT)?1E3/t*resolveValue:0}function findSpring({duration=800,bounce=.25,velocity=
0,mass=1}){let envelope;exports.warning(1E4>=duration,"Spring duration must be 10 seconds or less");let dampingRatio=1-bounce;dampingRatio=clamp(.05,1,dampingRatio);duration=clamp(.01,10,duration/1E3);1>dampingRatio?(envelope=undampedFreq=>{const exponentialDecay=undampedFreq*dampingRatio;return.001-(exponentialDecay-velocity)/(undampedFreq*Math.sqrt(1-dampingRatio*dampingRatio))*Math.exp(-(exponentialDecay*duration))},bounce=undampedFreq=>{var delta=undampedFreq*dampingRatio*duration;const d=delta*
velocity+velocity,e=Math.pow(dampingRatio,2)*Math.pow(undampedFreq,2)*duration;delta=Math.exp(-delta);const g=Math.pow(undampedFreq,2)*Math.sqrt(1-dampingRatio*dampingRatio);return(0<-envelope(undampedFreq)+.001?-1:1)*(d-e)*delta/g}):(envelope=undampedFreq=>-.001+Math.exp(-undampedFreq*duration)*((undampedFreq-velocity)*duration+1),bounce=undampedFreq=>Math.exp(-undampedFreq*duration)*(velocity-undampedFreq)*duration*duration);bounce=approximateRoot(envelope,bounce,5/duration);duration*=1E3;if(isNaN(bounce))return{stiffness:100,
damping:10,duration};bounce=Math.pow(bounce,2)*mass;return{stiffness:bounce,damping:2*dampingRatio*Math.sqrt(mass*bounce),duration}}function approximateRoot(envelope,derivative,initialGuess){for(let i=1;12>i;i++)initialGuess-=envelope(initialGuess)/derivative(initialGuess);return initialGuess}function isSpringType(options,keys){return keys.some(key=>void 0!==options[key])}function getSpringOptions(options){let springOptions={velocity:0,stiffness:100,damping:10,mass:1,isResolvedFromDuration:!1,...options};
!isSpringType(options,physicsKeys)&&isSpringType(options,durationKeys)&&(options=findSpring(options),springOptions={...springOptions,...options,mass:1,isResolvedFromDuration:!0});return springOptions}function spring({keyframes,restDelta,restSpeed,...options}){const origin=keyframes[0],target=keyframes[keyframes.length-1],state={done:!1,value:origin},{stiffness,damping,mass,duration,velocity,isResolvedFromDuration}=getSpringOptions({...options,velocity:-((options.velocity||0)/1E3)}),initialVelocity=
velocity||0,dampingRatio=damping/(2*Math.sqrt(stiffness*mass)),initialDelta=target-origin,undampedAngularFreq=Math.sqrt(stiffness/mass)/1E3;keyframes=5>Math.abs(initialDelta);restSpeed||(restSpeed=keyframes?.01:2);restDelta||(restDelta=keyframes?.005:.5);let resolveSpring;if(1>dampingRatio){const angularFreq=undampedAngularFreq*Math.sqrt(1-dampingRatio*dampingRatio);resolveSpring=t=>target-Math.exp(-dampingRatio*undampedAngularFreq*t)*((initialVelocity+dampingRatio*undampedAngularFreq*initialDelta)/
angularFreq*Math.sin(angularFreq*t)+initialDelta*Math.cos(angularFreq*t))}else if(1===dampingRatio)resolveSpring=t=>target-Math.exp(-undampedAngularFreq*t)*(initialDelta+(initialVelocity+undampedAngularFreq*initialDelta)*t);else{const dampedAngularFreq=undampedAngularFreq*Math.sqrt(dampingRatio*dampingRatio-1);resolveSpring=t=>{const freqForT=Math.min(dampedAngularFreq*t,300);return target-Math.exp(-dampingRatio*undampedAngularFreq*t)*((initialVelocity+dampingRatio*undampedAngularFreq*initialDelta)*
Math.sinh(freqForT)+dampedAngularFreq*initialDelta*Math.cosh(freqForT))/dampedAngularFreq}}return{calculatedDuration:isResolvedFromDuration?duration||null:null,next:t=>{const current=resolveSpring(t);if(isResolvedFromDuration)state.done=t>=duration;else{let currentVelocity=initialVelocity;0!==t&&(currentVelocity=1>dampingRatio?calcGeneratorVelocity(resolveSpring,t,current):0);t=Math.abs(target-current)<=restDelta;state.done=Math.abs(currentVelocity)<=restSpeed&&t}state.value=state.done?target:current;
return state}}}function inertia({keyframes,velocity=0,power=.8,timeConstant=325,bounceDamping=10,bounceStiffness=500,modifyTarget,min,max,restDelta=.5,restSpeed}){keyframes=keyframes[0];const state={done:!1,value:keyframes};let amplitude=power*velocity;velocity=keyframes+amplitude;const target=void 0===modifyTarget?velocity:modifyTarget(velocity);target!==velocity&&(amplitude=target-keyframes);const calcLatest=t=>target+-amplitude*Math.exp(-t/timeConstant),applyFriction=t=>{const latest=target+-amplitude*
Math.exp(-t/timeConstant);state.done=Math.abs(-amplitude*Math.exp(-t/timeConstant))<=restDelta;state.value=state.done?target:latest};let timeReachedBoundary,spring$1;const checkCatchBoundary=t=>{var v=state.value;if(void 0!==min&&v<min||void 0!==max&&v>max){timeReachedBoundary=t;v=state.value;var JSCompiler_inline_result=state.value;JSCompiler_inline_result=void 0===min?max:void 0===max?min:Math.abs(min-JSCompiler_inline_result)<Math.abs(max-JSCompiler_inline_result)?min:max;spring$1=spring({keyframes:[v,
JSCompiler_inline_result],velocity:calcGeneratorVelocity(calcLatest,t,state.value),damping:bounceDamping,stiffness:bounceStiffness,restDelta,restSpeed})}};checkCatchBoundary(0);return{calculatedDuration:null,next:t=>{let hasUpdatedFrame=!1;spring$1||void 0!==timeReachedBoundary||(hasUpdatedFrame=!0,applyFriction(t),checkCatchBoundary(t));if(void 0!==timeReachedBoundary&&t>timeReachedBoundary)return spring$1.next(t-timeReachedBoundary);!hasUpdatedFrame&&applyFriction(t);return state}}}function calcGeneratorDuration(generator){let duration=
0,state=generator.next(duration);for(;!state.done&&2E4>duration;)duration+=50,state=generator.next(duration);return 2E4<=duration?Infinity:duration}function animateValue({autoplay=!0,delay=0,driver=frameloopDriver,keyframes:keyframes$1,type="keyframes",repeat=0,repeatDelay=0,repeatType="loop",onPlay,onStop,onComplete,onUpdate,...options}){let speed=1,hasStopped=!1,resolveFinishedPromise,currentFinishedPromise;const updateFinishedPromise=()=>{currentFinishedPromise=new Promise(resolve=>{resolveFinishedPromise=
resolve})};updateFinishedPromise();let animationDriver;type=types[type]||keyframes;let mapNumbersToKeyframes;type!==keyframes&&"number"!==typeof keyframes$1[0]&&(exports.invariant(2===keyframes$1.length,`Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`),mapNumbersToKeyframes=interpolate([0,100],keyframes$1,{clamp:!1}),keyframes$1=[0,100]);const generator=type({...options,keyframes:keyframes$1});let mirroredGenerator;"mirror"===repeatType&&
(mirroredGenerator=type({...options,keyframes:[...keyframes$1].reverse(),velocity:-(options.velocity||0)}));let playState="idle",holdTime=null,startTime=null,cancelTime=null;null===generator.calculatedDuration&&repeat&&(generator.calculatedDuration=calcGeneratorDuration(generator));const {calculatedDuration}=generator;let resolvedDuration=Infinity,totalDuration=Infinity;null!==calculatedDuration&&(resolvedDuration=calculatedDuration+repeatDelay,totalDuration=resolvedDuration*(repeat+1)-repeatDelay);
let currentTime=0;const tick=timestamp=>{if(null!==startTime){0<speed&&(startTime=Math.min(startTime,timestamp));0>speed&&(startTime=Math.min(timestamp-totalDuration/speed,startTime));currentTime=null!==holdTime?holdTime:Math.round(timestamp-startTime)*speed;var timeWithoutDelay=currentTime-delay*(0<=speed?1:-1);timestamp=0<=speed?0>timeWithoutDelay:timeWithoutDelay>totalDuration;currentTime=Math.max(timeWithoutDelay,0);"finished"===playState&&null===holdTime&&(currentTime=totalDuration);var elapsed=
currentTime;timeWithoutDelay=generator;if(repeat){elapsed=Math.min(currentTime,totalDuration)/resolvedDuration;let currentIteration=Math.floor(elapsed),iterationProgress=elapsed%1;!iterationProgress&&1<=elapsed&&(iterationProgress=1);1===iterationProgress&&currentIteration--;currentIteration=Math.min(currentIteration,repeat+1);currentIteration%2&&("reverse"===repeatType?(iterationProgress=1-iterationProgress,repeatDelay&&(iterationProgress-=repeatDelay/resolvedDuration)):"mirror"===repeatType&&(timeWithoutDelay=
mirroredGenerator));elapsed=clamp(0,1,iterationProgress)*resolvedDuration}timeWithoutDelay=timestamp?{done:!1,value:keyframes$1[0]}:timeWithoutDelay.next(elapsed);mapNumbersToKeyframes&&(timeWithoutDelay.value=mapNumbersToKeyframes(timeWithoutDelay.value));({done:elapsed}=timeWithoutDelay);timestamp||null===calculatedDuration||(elapsed=0<=speed?currentTime>=totalDuration:0>=currentTime);timestamp=null===holdTime&&("finished"===playState||"running"===playState&&elapsed);onUpdate&&onUpdate(timeWithoutDelay.value);
timestamp&&(playState="finished",onComplete&&onComplete(),animationDriver&&animationDriver.stop(),animationDriver=void 0,resolveFinishedPromise());return timeWithoutDelay}};options=()=>{if(!hasStopped){animationDriver||(animationDriver=driver(tick));var now=animationDriver.now();onPlay&&onPlay();null!==holdTime?startTime=now-holdTime:startTime&&"finished"!==playState||(startTime=now);"finished"===playState&&updateFinishedPromise();cancelTime=startTime;holdTime=null;playState="running";animationDriver.start()}};
autoplay&&options();const controls={then(resolve,reject){return currentFinishedPromise.then(resolve,reject)},get time(){return currentTime/1E3},set time(newTime){currentTime=newTime*=1E3;null===holdTime&&animationDriver&&0!==speed?startTime=animationDriver.now()-newTime/speed:holdTime=newTime},get duration(){return(null===generator.calculatedDuration?calcGeneratorDuration(generator):generator.calculatedDuration)/1E3},get speed(){return speed},set speed(newSpeed){newSpeed!==speed&&animationDriver&&
(speed=newSpeed,controls.time=currentTime/1E3)},get state(){return playState},play:options,pause:()=>{playState="paused";holdTime=currentTime},stop:()=>{hasStopped=!0;"idle"!==playState&&(playState="idle",onStop&&onStop(),playState="idle",animationDriver&&animationDriver.stop(),animationDriver=void 0,resolveFinishedPromise(),updateFinishedPromise(),startTime=cancelTime=null)},cancel:()=>{null!==cancelTime&&tick(cancelTime);playState="idle";animationDriver&&animationDriver.stop();animationDriver=void 0;
resolveFinishedPromise();updateFinishedPromise();startTime=cancelTime=null},complete:()=>{playState="finished"},sample:elapsed=>{startTime=0;return tick(elapsed)}};return controls}function memo(callback){let result;return()=>{void 0===result&&(result=callback());return result}}function createAcceleratedAnimation(value,valueName,{onUpdate,onComplete,...options}){if(!supportsWaapi()||!acceleratedValues.has(valueName)||options.repeatDelay||"mirror"===options.repeatType||0===options.damping||"inertia"===
options.type)return!1;let hasStopped=!1,resolveFinishedPromise,currentFinishedPromise,pendingCancel=!1;const updateFinishedPromise=()=>{currentFinishedPromise=new Promise(resolve=>{resolveFinishedPromise=resolve})};updateFinishedPromise();let {keyframes,duration=300,ease,times}=options;if("spring"===options.type||"backgroundColor"===valueName||!isWaapiSupportedEasing(options.ease)){onUpdate=animateValue({...options,repeat:0,delay:0});let state={done:!1,value:keyframes[0]};const pregeneratedKeyframes=
[];let t=0;for(;!state.done&&2E4>t;)state=onUpdate.sample(t),pregeneratedKeyframes.push(state.value),t+=10;times=void 0;keyframes=pregeneratedKeyframes;duration=t-10;ease="linear"}const animation=animateStyle(value.owner.current,valueName,keyframes,{...options,duration,ease,times}),cancelAnimation=()=>{pendingCancel=!1;animation.cancel()},safeCancel=()=>{pendingCancel=!0;frame.update(cancelAnimation);resolveFinishedPromise();updateFinishedPromise()};animation.onfinish=()=>{pendingCancel||(value.set(getFinalKeyframe(keyframes,
options)),onComplete&&onComplete(),safeCancel())};return{then(resolve,reject){return currentFinishedPromise.then(resolve,reject)},attachTimeline(timeline){animation.timeline=timeline;animation.onfinish=null;return noop},get time(){return(animation.currentTime||0)/1E3},set time(newTime){animation.currentTime=1E3*newTime},get speed(){return animation.playbackRate},set speed(newSpeed){animation.playbackRate=newSpeed},get duration(){return duration/1E3},play:()=>{hasStopped||(animation.play(),cancelFrame(cancelAnimation))},
pause:()=>animation.pause(),stop:()=>{hasStopped=!0;if("idle"!==animation.playState){var {currentTime}=animation;if(currentTime){const sampleAnimation=animateValue({...options,autoplay:!1});value.setWithVelocity(sampleAnimation.sample(currentTime-10).value,sampleAnimation.sample(currentTime).value,10)}safeCancel()}},complete:()=>{pendingCancel||animation.finish()},cancel:safeCancel}}function createInstantAnimation({keyframes,delay,onUpdate,onComplete}){const setValue=()=>{onUpdate&&onUpdate(keyframes[keyframes.length-
1]);onComplete&&onComplete();return{time:0,speed:1,duration:0,play:noop,pause:noop,stop:noop,then:resolve=>{resolve();return Promise.resolve()},cancel:noop,complete:noop}};return delay?animateValue({keyframes:[0,1],duration:0,delay,onComplete:setValue}):setValue()}function applyDefaultFilter(v){const [name,value]=v.slice(0,-1).split("(");if("drop-shadow"===name)return v;const [number]=value.match(floatRegex)||[];if(!number)return v;v=value.replace(number,"");let defaultValue=maxDefaults.has(name)?
1:0;number!==value&&(defaultValue*=100);return name+"("+defaultValue+v+")"}function getAnimatableNone(key,value){key=defaultValueTypes[key];key!==filter&&(key=complex);return key.getAnimatableNone?key.getAnimatableNone(value):void 0}function getKeyframes(value,valueName,target,transition){var isTargetAnimatable=isAnimatable(valueName,target);target=Array.isArray(target)?[...target]:[null,target];const defaultOrigin=void 0!==transition.from?transition.from:value.get();value=void 0;transition=[];for(let i=
0;i<target.length;i++){null===target[i]&&(target[i]=0===i?defaultOrigin:target[i-1]);var JSCompiler_inline_result=target[i];JSCompiler_inline_result="number"===typeof JSCompiler_inline_result?0===JSCompiler_inline_result:null!==JSCompiler_inline_result?"none"===JSCompiler_inline_result||"0"===JSCompiler_inline_result||/^0[^.\s]+$/.test(JSCompiler_inline_result):void 0;JSCompiler_inline_result&&transition.push(i);"string"===typeof target[i]&&"none"!==target[i]&&"0"!==target[i]&&(value=target[i])}if(isTargetAnimatable&&
transition.length&&value)for(isTargetAnimatable=0;isTargetAnimatable<transition.length;isTargetAnimatable++)target[transition[isTargetAnimatable]]=getAnimatableNone(valueName,value);return target}function isTransitionDefined({when,delay:_delay,delayChildren,staggerChildren,staggerDirection,repeat,repeatType,repeatDelay,from,elapsed,...transition}){return!!Object.keys(transition).length}function getValueTransition$1(transition,key){return transition[key]||transition["default"]||transition}function isWillChangeMotionValue(value){return!!(value&&
value.getVelocity&&value.add)}function addUniqueItem(arr,item){-1===arr.indexOf(item)&&arr.push(item)}function removeItem(arr,item){item=arr.indexOf(item);-1<item&&arr.splice(item,1)}function warnOnce(condition,message,element){condition||warned.has(message)||(console.warn(message),element&&console.warn(element),warned.add(message))}function motionValue(init,options){return new MotionValue(init,options)}function setTarget(visualElement,definition){definition=resolveVariant(visualElement,definition);
let {transitionEnd={},transition={},...target}=definition?visualElement.makeTargetAnimatable(definition,!1):{};target={...target,...transitionEnd};for(const key in target){definition=target[key];var JSCompiler_inline_result=Array.isArray(definition)?definition[definition.length-1]||0:definition;definition=visualElement;var key$jscomp$0=key;definition.hasValue(key$jscomp$0)?definition.getValue(key$jscomp$0).set(JSCompiler_inline_result):definition.addValue(key$jscomp$0,motionValue(JSCompiler_inline_result))}}
function setVariants(visualElement,variantLabels){[...variantLabels].reverse().forEach(key=>{(key=visualElement.getVariant(key))&&setTarget(visualElement,key);visualElement.variantChildren&&visualElement.variantChildren.forEach(child=>{setVariants(child,variantLabels)})})}function checkTargetForNewValues(visualElement,target,origin){var _a,_b;const newValueKeys=Object.keys(target).filter(key=>!visualElement.hasValue(key)),numNewValues=newValueKeys.length;if(numNewValues)for(let i=0;i<numNewValues;i++){const key=
newValueKeys[i],targetValue=target[key];let value=null;Array.isArray(targetValue)&&(value=targetValue[0]);null===value&&(value=null!==(_b=null!==(_a=origin[key])&&void 0!==_a?_a:visualElement.readValue(key))&&void 0!==_b?_b:target[key]);void 0!==value&&null!==value&&("string"===typeof value&&(/^\-?\d*\.?\d+$/.test(value)||/^0[^.\s]+$/.test(value))?value=parseFloat(value):!valueTypes.find(testValueType(value))&&complex.test(targetValue)&&(value=getAnimatableNone(key,targetValue)),visualElement.addValue(key,
motionValue(value,{owner:visualElement})),void 0===origin[key]&&(origin[key]=value),null!==value&&visualElement.setBaseTarget(key,value))}}function getOrigin(target,transition,visualElement){const origin={};for(const key in target)target=transition?(transition[key]||transition["default"]||transition).from:void 0,void 0!==target?origin[key]=target:(target=visualElement.getValue(key))&&(origin[key]=target.get());return origin}function shouldBlockAnimation({protectedKeys,needsAnimating},key){protectedKeys=
protectedKeys.hasOwnProperty(key)&&!0!==needsAnimating[key];needsAnimating[key]=!1;return protectedKeys}function hasKeyframesChanged(value,target){value=value.get();if(Array.isArray(target))for(let i=0;i<target.length;i++){if(target[i]!==value)return!0}else return value!==target}function animateTarget(visualElement,definition,{delay=0,transitionOverride,type}={}){let {transition=visualElement.getDefaultTransition(),transitionEnd,...target}=visualElement.makeTargetAnimatable(definition);const willChange=
visualElement.getValue("willChange");transitionOverride&&(transition=transitionOverride);definition=[];type=type&&visualElement.animationState&&visualElement.animationState.getState()[type];for(const key in target){transitionOverride=visualElement.getValue(key);const valueTarget=target[key];if(!transitionOverride||void 0===valueTarget||type&&shouldBlockAnimation(type,key))continue;const valueTransition={delay,elapsed:0,...getValueTransition$1(transition||{},key)};if(window.HandoffAppearAnimations){var appearId=
visualElement.getProps()[optimizedAppearDataAttribute];appearId&&(appearId=window.HandoffAppearAnimations(appearId,key,transitionOverride,frame),null!==appearId&&(valueTransition.elapsed=appearId,valueTransition.isHandoff=!0))}appearId=!valueTransition.isHandoff&&!hasKeyframesChanged(transitionOverride,valueTarget);"spring"===valueTransition.type&&(transitionOverride.getVelocity()||valueTransition.velocity)&&(appearId=!1);transitionOverride.animation&&(appearId=!1);appearId||(transitionOverride.start(animateMotionValue(key,
transitionOverride,valueTarget,visualElement.shouldReduceMotion&&transformProps.has(key)?{type:!1}:valueTransition)),transitionOverride=transitionOverride.animation,isWillChangeMotionValue(willChange)&&(willChange.add(key),transitionOverride.then(()=>willChange.remove(key))),definition.push(transitionOverride))}transitionEnd&&Promise.all(definition).then(()=>{transitionEnd&&setTarget(visualElement,transitionEnd)});return definition}function convertBoundingBoxToBox({top,left,right,bottom}){return{x:{min:left,
max:right},y:{min:top,max:bottom}}}function transformBoxPoints(point,transformPoint){if(!transformPoint)return point;const topLeft=transformPoint({x:point.left,y:point.top});point=transformPoint({x:point.right,y:point.bottom});return{top:topLeft.y,left:topLeft.x,bottom:point.y,right:point.x}}function hasScale({scale,scaleX,scaleY}){return!(void 0===scale||1===scale)||!(void 0===scaleX||1===scaleX)||!(void 0===scaleY||1===scaleY)}function hasTransform(values){return hasScale(values)||has2DTranslate(values)||
values.z||values.rotate||values.rotateX||values.rotateY}function has2DTranslate(values){return is2DTranslate(values.x)||is2DTranslate(values.y)}function is2DTranslate(value){return value&&"0%"!==value}function scalePoint(point,scale,originPoint){return originPoint+scale*(point-originPoint)}function applyPointDelta(point,translate,scale,originPoint,boxScale){void 0!==boxScale&&(point=scalePoint(point,boxScale,originPoint));return scalePoint(point,scale,originPoint)+translate}function applyAxisDelta(axis,
translate=0,scale=1,originPoint,boxScale){axis.min=applyPointDelta(axis.min,translate,scale,originPoint,boxScale);axis.max=applyPointDelta(axis.max,translate,scale,originPoint,boxScale)}function applyBoxDelta(box,{x,y}){applyAxisDelta(box.x,x.translate,x.scale,x.originPoint);applyAxisDelta(box.y,y.translate,y.scale,y.originPoint)}function snapToDefault(scale){return Number.isInteger(scale)?scale:1.0000000000001<scale||.999999999999>scale?scale:1}function translateAxis(axis,distance){axis.min+=distance;
axis.max+=distance}function transformAxis(axis,transforms,[key,scaleKey,originKey]){originKey=void 0!==transforms[originKey]?transforms[originKey]:.5;var from=axis.min;applyAxisDelta(axis,transforms[key],transforms[scaleKey],-originKey*from+originKey*axis.max+from,transforms.scale)}function transformBox(box,transform){transformAxis(box.x,transform,xKeys);transformAxis(box.y,transform,yKeys)}function resolveElements(elements,scope,selectorCache){var _a;if("string"===typeof elements){let root=document;
scope&&(exports.invariant(!!scope.current,"Scope provided, but no element detected."),root=scope.current);selectorCache?(null!==(_a=selectorCache[elements])&&void 0!==_a?_a:selectorCache[elements]=root.querySelectorAll(elements),elements=selectorCache[elements]):elements=root.querySelectorAll(elements)}else elements instanceof Element&&(elements=[elements]);return Array.from(elements||[])}function observeTimeline(update,timeline){let prevProgress;const onFrame=()=>{var {currentTime}=timeline;currentTime=
(null===currentTime?0:currentTime.value)/100;prevProgress!==currentTime&&update(currentTime);prevProgress=currentTime};frame.update(onFrame,!0);return()=>cancelFrame(onFrame)}function isSVGElement(element){return element instanceof SVGElement&&"svg"!==element.tagName}function getVariableValue(current,element,depth=1){exports.invariant(4>=depth,`Max CSS variable fallback depth detected in property "${current}". This may indicate a circular fallback dependency.`);if(current=splitCSSVariableRegex.exec(current)){var [,
token,fallback]=current;current=[token,fallback]}else current=[,];const [token$jscomp$0,fallback$jscomp$0]=current;if(token$jscomp$0)return(current=window.getComputedStyle(element).getPropertyValue(token$jscomp$0))?(element=current.trim(),/^\-?\d*\.?\d+$/.test(element)?parseFloat(element):element):isCSSVariableToken(fallback$jscomp$0)?getVariableValue(fallback$jscomp$0,element,depth+1):fallback$jscomp$0}function resolveCSSVariables(visualElement,{...target},transitionEnd){const element=visualElement.current;
if(!(element instanceof Element))return{target,transitionEnd};transitionEnd&&(transitionEnd={...transitionEnd});visualElement.values.forEach(value=>{var current=value.get();isCSSVariableToken(current)&&(current=getVariableValue(current,element))&&value.set(current)});for(const key in target){visualElement=target[key];if(!isCSSVariableToken(visualElement))continue;const resolved=getVariableValue(visualElement,element);resolved&&(target[key]=resolved,transitionEnd||(transitionEnd={}),void 0===transitionEnd[key]&&
(transitionEnd[key]=visualElement))}return{target,transitionEnd}}function removeNonTranslationalTransform(visualElement){const removedTransforms=[];nonTranslationalTransformKeys.forEach(key=>{const value=visualElement.getValue(key);void 0!==value&&(removedTransforms.push([key,value.get()]),value.set(key.startsWith("scale")?1:0))});removedTransforms.length&&visualElement.render();return removedTransforms}function initPrefersReducedMotion(){hasReducedMotionListener.current=!0;if(isBrowser)if(window.matchMedia){const motionMediaQuery=
window.matchMedia("(prefers-reduced-motion)");motionMediaQuery.addListener(()=>prefersReducedMotion.current=motionMediaQuery.matches);prefersReducedMotion.current=motionMediaQuery.matches}else prefersReducedMotion.current=!1}function animateSingleValue(value,keyframes,options){value=value&&value.getVelocity?value:motionValue(value);value.start(animateMotionValue("",value,keyframes,options));return value.animation}function createGeneratorEasing(options,scale=100){const generator=spring({keyframes:[0,
scale],...options}),duration=Math.min(calcGeneratorDuration(generator),2E4);return{type:"keyframes",ease:progress=>generator.next(duration*progress).value/scale,duration:duration/1E3}}function calcNextTime(current,next,prev,labels){var _a;return"number"===typeof next?next:next.startsWith("-")||next.startsWith("+")?Math.max(0,current+parseFloat(next)):"\x3c"===next?prev:null!==(_a=labels.get(next))&&void 0!==_a?_a:current}function compareByTime(a,b){return a.at===b.at?null===a.value?1:null===b.value?
-1:0:a.at-b.at}function createAnimationsFromSequence(sequence,{defaultTransition={},...sequenceTransition}={},scope){const defaultDuration=defaultTransition.duration||.3,animationDefinitions=new Map,sequences=new Map,elementCache={},timeLabels=new Map;var prevTime=0;let currentTime=0,totalDuration=0;for(let i$jscomp$2=0;i$jscomp$2<sequence.length;i$jscomp$2++){var segment=sequence[i$jscomp$2];if("string"===typeof segment){timeLabels.set(segment,currentTime);continue}else if(!Array.isArray(segment)){timeLabels.set(segment.name,
calcNextTime(currentTime,segment.at,prevTime,timeLabels));continue}let [subject,keyframes,transition={}]=segment;void 0!==transition.at&&(currentTime=calcNextTime(currentTime,transition.at,prevTime,timeLabels));let maxDuration=0;prevTime=(valueKeyframes,valueTransition,valueSequence,elementIndex=0,numElements=0)=>{valueKeyframes=Array.isArray(valueKeyframes)?valueKeyframes:[valueKeyframes];const {delay=0,times=defaultOffset$1(valueKeyframes),type="keyframes",...remainingTransition}=valueTransition;
let {ease=defaultTransition.ease||"easeOut",duration}=valueTransition;valueTransition="function"===typeof delay?delay(elementIndex,numElements):delay;numElements=valueKeyframes.length;2>=numElements&&"spring"===type&&(elementIndex=100,2===numElements&&valueKeyframes.every(isNumber)&&(elementIndex=Math.abs(valueKeyframes[1]-valueKeyframes[0])),numElements={...remainingTransition},void 0!==duration&&(numElements.duration=1E3*duration),elementIndex=createGeneratorEasing(numElements,elementIndex),ease=
elementIndex.ease,duration=elementIndex.duration);null!==duration&&void 0!==duration?duration:duration=defaultDuration;elementIndex=currentTime+valueTransition;numElements=elementIndex+duration;1===times.length&&0===times[0]&&(times[1]=1);var remainder=times.length-valueKeyframes.length;0<remainder&&fillOffset(times,remainder);1===valueKeyframes.length&&valueKeyframes.unshift(null);remainder=ease;for(var i$jscomp$0=0;i$jscomp$0<valueSequence.length;i$jscomp$0++){var keyframe=valueSequence[i$jscomp$0];
keyframe.at>elementIndex&&keyframe.at<numElements&&(removeItem(valueSequence,keyframe),i$jscomp$0--)}for(let i=0;i<valueKeyframes.length;i++){i$jscomp$0=valueSequence;keyframe=i$jscomp$0.push;var JSCompiler_temp_const=valueKeyframes[i],JSCompiler_temp_const$jscomp$0=mix(elementIndex,numElements,times[i]);var JSCompiler_inline_result=remainder;var i$jscomp$1=i;JSCompiler_inline_result=isEasingArray(JSCompiler_inline_result)?JSCompiler_inline_result[wrap(0,JSCompiler_inline_result.length,i$jscomp$1)]:
JSCompiler_inline_result;keyframe.call(i$jscomp$0,{value:JSCompiler_temp_const,at:JSCompiler_temp_const$jscomp$0,easing:JSCompiler_inline_result})}maxDuration=Math.max(valueTransition+duration,maxDuration);totalDuration=Math.max(numElements,totalDuration)};if(subject&&subject.getVelocity)segment=getSubjectSequence(subject,sequences),prevTime(keyframes,transition,getValueSequence("default",segment));else{segment=resolveElements(subject,scope,elementCache);const numElements=segment.length;for(let elementIndex=
0;elementIndex<numElements;elementIndex++){const subjectSequence=getSubjectSequence(segment[elementIndex],sequences);for(const key in keyframes)prevTime(keyframes[key],transition[key]?{...transition,...transition[key]}:{...transition},getValueSequence(key,subjectSequence),elementIndex,numElements)}}prevTime=currentTime;currentTime+=maxDuration}sequences.forEach((valueSequences,element)=>{for(const key in valueSequences){var valueSequence=valueSequences[key];valueSequence.sort(compareByTime);const keyframes=
[],valueOffset=[],valueEasing=[];for(let i=0;i<valueSequence.length;i++){const {at,value,easing}=valueSequence[i];keyframes.push(value);valueOffset.push(progress(0,totalDuration,at));valueEasing.push(easing||"easeOut")}0!==valueOffset[0]&&(valueOffset.unshift(0),keyframes.unshift(keyframes[0]),valueEasing.unshift("easeInOut"));1!==valueOffset[valueOffset.length-1]&&(valueOffset.push(1),keyframes.push(null));animationDefinitions.has(element)||animationDefinitions.set(element,{keyframes:{},transition:{}});
valueSequence=animationDefinitions.get(element);valueSequence.keyframes[key]=keyframes;valueSequence.transition[key]={...defaultTransition,duration:totalDuration,ease:valueEasing,times:valueOffset,...sequenceTransition}}});return animationDefinitions}function getSubjectSequence(subject,sequences){!sequences.has(subject)&&sequences.set(subject,{});return sequences.get(subject)}function getValueSequence(name,sequences){sequences[name]||(sequences[name]=[]);return sequences[name]}function animateElements(elementOrSelector,
keyframes,options$jscomp$0,scope){elementOrSelector=resolveElements(elementOrSelector,scope);scope=elementOrSelector.length;exports.invariant(!!scope,"No valid element provided.");const animations=[];for(let i=0;i<scope;i++){var element=elementOrSelector[i];if(!visualElementStore.has(element)){var element$jscomp$0=element,options={presenceContext:null,props:{},visualState:{renderState:{transform:{},transformOrigin:{},style:{},vars:{},attrs:{}},latestValues:{}}};options=isSVGElement(element$jscomp$0)?
new SVGVisualElement(options,{enableHardwareAcceleration:!1}):new HTMLVisualElement(options,{enableHardwareAcceleration:!0});options.mount(element$jscomp$0);visualElementStore.set(element$jscomp$0,options)}element$jscomp$0=visualElementStore.get(element);element={...options$jscomp$0};"function"===typeof element.delay&&(element.delay=element.delay(i,scope));animations.push(...animateTarget(element$jscomp$0,{...keyframes,transition:element},{}))}return new GroupPlaybackControls(animations)}function animateSequence(sequence,
options,scope){const animations=[];createAnimationsFromSequence(sequence,options,scope).forEach(({keyframes,transition},subject)=>{keyframes=subject&&subject.getVelocity?animateSingleValue(subject,keyframes.default,transition.default):animateElements(subject,keyframes,transition);animations.push(keyframes)});return new GroupPlaybackControls(animations)}function notifyTarget({target,contentRect,borderBoxSize}){var _a;null===(_a=resizeHandlers.get(target))||void 0===_a?void 0:_a.forEach(handler=>{handler({target,
contentSize:contentRect,get size(){if(borderBoxSize){const {inlineSize,blockSize}=borderBoxSize[0];var JSCompiler_inline_result={width:inlineSize,height:blockSize}}else JSCompiler_inline_result=target instanceof SVGElement&&"getBBox"in target?target.getBBox():{width:target.offsetWidth,height:target.offsetHeight};return JSCompiler_inline_result}})})}function notifyAll(entries){entries.forEach(notifyTarget)}function resizeElement(target,handler){observer||"undefined"!==typeof ResizeObserver&&(observer=
new ResizeObserver(notifyAll));const elements=resolveElements(target);elements.forEach(element=>{let elementHandlers=resizeHandlers.get(element);elementHandlers||(elementHandlers=new Set,resizeHandlers.set(element,elementHandlers));elementHandlers.add(handler);null===observer||void 0===observer?void 0:observer.observe(element)});return()=>{elements.forEach(element=>{const elementHandlers=resizeHandlers.get(element);null===elementHandlers||void 0===elementHandlers?void 0:elementHandlers.delete(handler);
(null===elementHandlers||void 0===elementHandlers?0:elementHandlers.size)||(null===observer||void 0===observer?void 0:observer.unobserve(element))})}}function createWindowResizeHandler(){windowResizeHandler=()=>{const size={width:window.innerWidth,height:window.innerHeight},info={target:window,size,contentSize:size};windowCallbacks.forEach(callback=>callback(info))};window.addEventListener("resize",windowResizeHandler)}function resizeWindow(callback){windowCallbacks.add(callback);windowResizeHandler||
createWindowResizeHandler();return()=>{windowCallbacks.delete(callback);!windowCallbacks.size&&windowResizeHandler&&(windowResizeHandler=void 0)}}function resize(a,b){return"function"===typeof a?resizeWindow(a):resizeElement(a,b)}function updateAxisInfo(element,axisName,info,time){const axis=info[axisName],{length,position}=keys[axisName];axisName=axis.current;info=info.time;axis.current=element["scroll"+position];axis.scrollLength=element["scroll"+length]-element["client"+length];axis.offset.length=
0;axis.offset[0]=0;axis.offset[1]=axis.scrollLength;axis.progress=progress(0,axis.scrollLength,axis.current);element=time-info;axis.velocity=50<element?0:element?1E3/element*(axis.current-axisName):0}function resolveEdge(edge,length,inset=0){let delta=0;void 0!==namedEdges[edge]&&(edge=namedEdges[edge]);if("string"===typeof edge){const asNumber=parseFloat(edge);edge.endsWith("px")?delta=asNumber:edge.endsWith("%")?edge=asNumber/100:edge.endsWith("vw")?delta=asNumber/100*document.documentElement.clientWidth:
edge.endsWith("vh")?delta=asNumber/100*document.documentElement.clientHeight:edge=asNumber}"number"===typeof edge&&(delta=length*edge);return inset+delta}function measure(container,target=container,info){info.x.targetOffset=0;info.y.targetOffset=0;if(target!==container){let node=target;for(;node&&node!==container;)info.x.targetOffset+=node.offsetLeft,info.y.targetOffset+=node.offsetTop,node=node.offsetParent}info.x.targetLength=target===container?target.scrollWidth:target.clientWidth;info.y.targetLength=
target===container?target.scrollHeight:target.clientHeight;info.x.containerLength=container.clientWidth;info.y.containerLength=container.clientHeight;container&&target&&target!==container&&warnOnce("static"!==getComputedStyle(container).position,"Please ensure that the container has a non-static position, like 'relative', 'fixed', or 'absolute' to ensure scroll offset is calculated correctly.")}function createOnScrollHandler(element,onScroll,info,options={}){return{measure:()=>measure(element,options.target,
info),update:time=>{updateAxisInfo(element,"x",info,time);updateAxisInfo(element,"y",info,time);info.time=time;if(options.offset||options.target){({offset:time=ScrollOffset.All}=options);const {target=element,axis="y"}=options,lengthLabel="y"===axis?"height":"width";if(target!==element){var JSCompiler_temp={x:0,y:0};for(var current=target;current&&current!==element;)if(current instanceof HTMLElement)JSCompiler_temp.x+=current.offsetLeft,JSCompiler_temp.y+=current.offsetTop,current=current.offsetParent;
else if("svg"===current.tagName){var svgBoundingBox=current.getBoundingClientRect();current=current.parentElement;var parentBoundingBox=current.getBoundingClientRect();JSCompiler_temp.x+=svgBoundingBox.left-parentBoundingBox.left;JSCompiler_temp.y+=svgBoundingBox.top-parentBoundingBox.top}else if(current instanceof SVGGraphicsElement){const {x,y}=current.getBBox();JSCompiler_temp.x+=x;JSCompiler_temp.y+=y;svgBoundingBox=null;for(parentBoundingBox=current.parentNode;!svgBoundingBox;)"svg"===parentBoundingBox.tagName&&
(svgBoundingBox=parentBoundingBox),parentBoundingBox=current.parentNode;current=svgBoundingBox}else break}else JSCompiler_temp=point$jscomp$0;target===element?current={width:element.scrollWidth,height:element.scrollHeight}:(current=target,current="getBBox"in current&&"svg"!==current.tagName?current.getBBox():{width:current.clientWidth,height:current.clientHeight});svgBoundingBox={width:element.clientWidth,height:element.clientHeight};info[axis].offset.length=0;parentBoundingBox=!info[axis].interpolate;
const numOffsets=time.length;for(let i=0;i<numOffsets;i++){var containerPoint=void 0,targetPoint=void 0;targetPoint=time[i];containerPoint=svgBoundingBox[lengthLabel];var targetLength=current[lengthLabel],targetInset=JSCompiler_temp[axis];let offsetDefinition=Array.isArray(targetPoint)?targetPoint:defaultOffset;"number"===typeof targetPoint?offsetDefinition=[targetPoint,targetPoint]:"string"===typeof targetPoint&&(targetPoint=targetPoint.trim(),offsetDefinition=targetPoint.includes(" ")?targetPoint.split(" "):
[targetPoint,namedEdges[targetPoint]?targetPoint:"0"]);targetPoint=resolveEdge(offsetDefinition[0],targetLength,targetInset);containerPoint=resolveEdge(offsetDefinition[1],containerPoint);containerPoint=targetPoint-containerPoint;parentBoundingBox||containerPoint===info[axis].interpolatorOffsets[i]||(parentBoundingBox=!0);info[axis].offset[i]=containerPoint}parentBoundingBox&&(info[axis].interpolate=interpolate(info[axis].offset,defaultOffset$1(time)),info[axis].interpolatorOffsets=[...info[axis].offset]);
info[axis].progress=info[axis].interpolate(info[axis].current)}},notify:()=>onScroll(info)}}function scrollInfo(onScroll,{container=document.documentElement,...options}={}){let containerHandlers=onScrollHandlers.get(container);containerHandlers||(containerHandlers=new Set,onScrollHandlers.set(container,containerHandlers));const info={time:0,x:createAxisInfo(),y:createAxisInfo()},containerHandler=createOnScrollHandler(container,onScroll,info,options);containerHandlers.add(containerHandler);if(!scrollListeners.has(container)){const measureAll=
()=>{for(const handler of containerHandlers)handler.measure()},updateAll=()=>{for(const handler of containerHandlers)handler.update(frameData.timestamp)},notifyAll=()=>{for(const handler of containerHandlers)handler.notify()};onScroll=()=>{frame.read(measureAll,!1,!0);frame.read(updateAll,!1,!0);frame.update(notifyAll,!1,!0)};scrollListeners.set(container,onScroll);options=container===document.documentElement?window:container;window.addEventListener("resize",onScroll,{passive:!0});container!==document.documentElement&&
resizeListeners.set(container,resize(container,onScroll));options.addEventListener("scroll",onScroll,{passive:!0})}const listener=scrollListeners.get(container);frame.read(listener,!1,!0);return()=>{var _a;cancelFrame(listener);var currentHandlers=onScrollHandlers.get(container);currentHandlers&&(currentHandlers.delete(containerHandler),currentHandlers.size||(currentHandlers=scrollListeners.get(container),scrollListeners.delete(container),currentHandlers&&((container===document.documentElement?window:
container).removeEventListener("scroll",currentHandlers),null===(_a=resizeListeners.get(container))||void 0===_a?void 0:_a(),window.removeEventListener("resize",currentHandlers))))}}function scrollTimelineFallback({source,axis="y"}){const currentTime={value:0};source=scrollInfo(info=>{currentTime.value=100*info[axis].progress},{container:source,axis});return{currentTime,cancel:source}}function getTimeline({source=document.documentElement,axis="y"}={}){timelineCache.has(source)||timelineCache.set(source,
{});const elementCache=timelineCache.get(source);elementCache[axis]||(elementCache[axis]=supportsScrollTimeline()?new ScrollTimeline({source,axis}):scrollTimelineFallback({source,axis}));return elementCache[axis]}const isBrowser="undefined"!==typeof document,camelToDash=str=>str.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase(),optimizedAppearDataAttribute="data-"+camelToDash("framerAppearId"),variantPriorityOrder="animate whileInView whileFocus whileHover whileTap whileDrag exit".split(" "),variantProps=
["initial",...variantPriorityOrder],featureProps={animation:"animate variants whileHover whileTap exit whileInView whileFocus whileDrag".split(" "),exit:["exit"],drag:["drag","dragControls"],focus:["whileFocus"],hover:["whileHover","onHoverStart","onHoverEnd"],tap:["whileTap","onTap","onTapStart","onTapCancel"],pan:["onPan","onPanStart","onPanSessionStart","onPanEnd"],inView:["whileInView","onViewportEnter","onViewportLeave"],layout:["layout","layoutId"]},featureDefinitions={};for(const key in featureProps)featureDefinitions[key]=
{isEnabled:props=>featureProps[key].some(name=>!!props[name])};const scaleCorrectors={},transformPropOrder="transformPerspective x y z translateX translateY translateZ scale scaleX scaleY rotate rotateX rotateY rotateZ skew skewX skewY".split(" "),transformProps=new Set(transformPropOrder),translateAlias={x:"translateX",y:"translateY",z:"translateZ",transformPerspective:"perspective"},numTransforms=transformPropOrder.length,checkStringStartsWith=token=>key=>"string"===typeof key&&key.startsWith(token),
isCSSVariableName=checkStringStartsWith("--"),isCSSVariableToken=checkStringStartsWith("var(--"),clamp=(min,max,v)=>Math.min(Math.max(v,min),max),number$jscomp$0={test:v=>"number"===typeof v,parse:parseFloat,transform:v=>v},alpha$jscomp$0={...number$jscomp$0,transform:v=>clamp(0,1,v)},scale$jscomp$0={...number$jscomp$0,default:1},floatRegex=/(-)?([\d]*\.?[\d])+/g,colorRegex=/(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[,\/]?\s*[\d\.]*%?\))/gi,singleColorRegex=/^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[,\/]?\s*[\d\.]*%?\))$/i,
createUnitType=unit=>({test:v=>isString(v)&&v.endsWith(unit)&&1===v.split(" ").length,parse:parseFloat,transform:v=>`${v}${unit}`}),degrees=createUnitType("deg"),percent=createUnitType("%"),px=createUnitType("px"),vh=createUnitType("vh"),vw=createUnitType("vw"),progressPercentage={...percent,parse:v=>percent.parse(v)/100,transform:v=>percent.transform(100*v)},int={...number$jscomp$0,transform:Math.round},numberValueTypes={borderWidth:px,borderTopWidth:px,borderRightWidth:px,borderBottomWidth:px,borderLeftWidth:px,
borderRadius:px,radius:px,borderTopLeftRadius:px,borderTopRightRadius:px,borderBottomRightRadius:px,borderBottomLeftRadius:px,width:px,maxWidth:px,height:px,maxHeight:px,size:px,top:px,right:px,bottom:px,left:px,padding:px,paddingTop:px,paddingRight:px,paddingBottom:px,paddingLeft:px,margin:px,marginTop:px,marginRight:px,marginBottom:px,marginLeft:px,rotate:degrees,rotateX:degrees,rotateY:degrees,rotateZ:degrees,scale:scale$jscomp$0,scaleX:scale$jscomp$0,scaleY:scale$jscomp$0,scaleZ:scale$jscomp$0,
skew:degrees,skewX:degrees,skewY:degrees,distance:px,translateX:px,translateY:px,translateZ:px,x:px,y:px,z:px,perspective:px,transformPerspective:px,opacity:alpha$jscomp$0,originX:progressPercentage,originY:progressPercentage,originZ:px,zIndex:int,fillOpacity:alpha$jscomp$0,strokeOpacity:alpha$jscomp$0,numOctaves:int},dashKeys={offset:"stroke-dashoffset",array:"stroke-dasharray"},camelKeys={offset:"strokeDashoffset",array:"strokeDasharray"},isSVGTag=tag=>"string"===typeof tag&&"svg"===tag.toLowerCase(),
camelCaseAttributes=new Set("baseFrequency diffuseConstant kernelMatrix kernelUnitLength keySplines keyTimes limitingConeAngle markerHeight markerWidth numOctaves targetX targetY surfaceScale specularConstant specularExponent stdDeviation tableValues viewBox gradientTransform pathLength startOffset textLength lengthAdjust".split(" ")),noop=any=>any;class Queue{constructor(){this.order=[];this.scheduled=new Set}add(process){if(!this.scheduled.has(process))return this.scheduled.add(process),this.order.push(process),
!0}remove(process){const index=this.order.indexOf(process);-1!==index&&(this.order.splice(index,1),this.scheduled.delete(process))}clear(){this.order.length=0;this.scheduled.clear()}}const stepsOrder="prepare read update preRender render postRender".split(" "),{schedule:frame,cancel:cancelFrame,state:frameData,steps}=function(scheduleNextBatch,allowKeepAlive){let runNextFrame=!1,useDefaultElapsed=!0;const state={delta:0,timestamp:0,isProcessing:!1},steps=stepsOrder.reduce((acc,key)=>{acc[key]=createRenderStep(()=>
runNextFrame=!0);return acc},{}),processStep=stepId=>steps[stepId].process(state),processBatch=()=>{const timestamp=performance.now();runNextFrame=!1;state.delta=useDefaultElapsed?1E3/60:Math.max(Math.min(timestamp-state.timestamp,40),1);state.timestamp=timestamp;state.isProcessing=!0;stepsOrder.forEach(processStep);state.isProcessing=!1;runNextFrame&&allowKeepAlive&&(useDefaultElapsed=!1,scheduleNextBatch(processBatch))};return{schedule:stepsOrder.reduce((acc,key)=>{const step=steps[key];acc[key]=
(process,keepAlive=!1,immediate=!1)=>{runNextFrame||(useDefaultElapsed=runNextFrame=!0,state.isProcessing||scheduleNextBatch(processBatch));return step.schedule(process,keepAlive,immediate)};return acc},{}),cancel:process=>stepsOrder.forEach(key=>steps[key].cancel(process)),state,steps}}("undefined"!==typeof requestAnimationFrame?requestAnimationFrame:noop,!0),combineFunctions=(a,b)=>v=>b(a(v));exports.warning=noop;exports.invariant=noop;exports.warning=(check,message)=>{check||"undefined"===typeof console||
console.warn(message)};exports.invariant=(check,message)=>{if(!check)throw Error(message);};const instantAnimationState={current:!1},isBezierDefinition=easing=>Array.isArray(easing)&&"number"===typeof easing[0],cubicBezierAsString=([a,b,c,d])=>`cubic-bezier(${a}, ${b}, ${c}, ${d})`,supportedWaapiEasing={linear:"linear",ease:"ease",easeIn:"ease-in",easeOut:"ease-out",easeInOut:"ease-in-out",circIn:cubicBezierAsString([0,.65,.55,1]),circOut:cubicBezierAsString([.55,0,1,.45]),backIn:cubicBezierAsString([.31,
.01,.66,-.59]),backOut:cubicBezierAsString([.33,1.53,.69,.99])},easeIn=cubicBezier(.42,0,1,1),easeOut=cubicBezier(0,0,.58,1),easeInOut=cubicBezier(.42,0,.58,1),isEasingArray=ease=>Array.isArray(ease)&&"number"!==typeof ease[0],mirrorEasing=easing=>p=>.5>=p?easing(2*p)/2:(2-easing(2*(1-p)))/2,reverseEasing=easing=>p=>1-easing(1-p),circIn=p=>1-Math.sin(Math.acos(p)),circOut=reverseEasing(circIn),circInOut=mirrorEasing(circIn),backOut=cubicBezier(.33,1.53,.69,.99),backIn=reverseEasing(backOut),backInOut=
mirrorEasing(backIn),anticipate=p=>1>(p*=2)?.5*backIn(p):.5*(2-Math.pow(2,-10*(p-1))),easingLookup={linear:noop,easeIn,easeInOut,easeOut,circIn,circInOut,circOut,backIn,backInOut,backOut,anticipate},easingDefinitionToFunction=definition=>{if(Array.isArray(definition)){exports.invariant(4===definition.length,"Cubic bezier arrays must contain four numerical values.");const [x1,y1,x2,y2]=definition;return cubicBezier(x1,y1,x2,y2)}return"string"===typeof definition?(exports.invariant(void 0!==easingLookup[definition],
`Invalid easing type '${definition}'`),easingLookup[definition]):definition},isColorString=(type,testProp)=>v=>!!(isString(v)&&singleColorRegex.test(v)&&v.startsWith(type)||testProp&&Object.prototype.hasOwnProperty.call(v,testProp)),splitColor=(aName,bName,cName)=>v=>{if(!isString(v))return v;const [a,b,c,alpha]=v.match(floatRegex);return{[aName]:parseFloat(a),[bName]:parseFloat(b),[cName]:parseFloat(c),alpha:void 0!==alpha?parseFloat(alpha):1}},rgbUnit={...number$jscomp$0,transform:v=>Math.round(clamp(0,
255,v))},rgba={test:isColorString("rgb","red"),parse:splitColor("red","green","blue"),transform:({red,green,blue,alpha:alpha$1=1})=>"rgba("+rgbUnit.transform(red)+", "+rgbUnit.transform(green)+", "+rgbUnit.transform(blue)+", "+Math.round(1E5*alpha$jscomp$0.transform(alpha$1))/1E5+")"},hex={test:isColorString("#"),parse:function(v){let r,g,b;5<v.length?(r=v.substring(1,3),g=v.substring(3,5),b=v.substring(5,7),v=v.substring(7,9)):(r=v.substring(1,2),g=v.substring(2,3),b=v.substring(3,4),v=v.substring(4,
5),r+=r,g+=g,b+=b,v+=v);return{red:parseInt(r,16),green:parseInt(g,16),blue:parseInt(b,16),alpha:v?parseInt(v,16)/255:1}},transform:rgba.transform},hsla={test:isColorString("hsl","hue"),parse:splitColor("hue","saturation","lightness"),transform:({hue,saturation,lightness,alpha:alpha$1=1})=>"hsla("+Math.round(hue)+", "+percent.transform(Math.round(1E5*saturation)/1E5)+", "+percent.transform(Math.round(1E5*lightness)/1E5)+", "+Math.round(1E5*alpha$jscomp$0.transform(alpha$1))/1E5+")"},color$jscomp$0=
{test:v=>rgba.test(v)||hex.test(v)||hsla.test(v),parse:v=>rgba.test(v)?rgba.parse(v):hsla.test(v)?hsla.parse(v):hex.parse(v),transform:v=>isString(v)?v:v.hasOwnProperty("red")?rgba.transform(v):hsla.transform(v)},mix=(from,to,progress)=>-progress*from+progress*to+from,mixLinearColor=(from,to,v)=>{from*=from;return Math.sqrt(Math.max(0,v*(to*to-from)+from))},colorTypes=[hex,rgba,hsla],getColorType=v=>colorTypes.find(type=>type.test(v)),mixColor=(from$jscomp$0,to)=>{const fromRGBA=asRGBA(from$jscomp$0),
toRGBA=asRGBA(to),blended={...fromRGBA};return v=>{blended.red=mixLinearColor(fromRGBA.red,toRGBA.red,v);blended.green=mixLinearColor(fromRGBA.green,toRGBA.green,v);blended.blue=mixLinearColor(fromRGBA.blue,toRGBA.blue,v);var from=fromRGBA.alpha;blended.alpha=-v*from+v*toRGBA.alpha+from;return rgba.transform(blended)}},cssVarTokeniser={regex:/var\s*\(\s*--[\w-]+(\s*,\s*(?:(?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)+)?\s*\)/g,countKey:"Vars",token:"${v}",parse:noop},colorTokeniser={regex:colorRegex,countKey:"Colors",
token:"${c}",parse:color$jscomp$0.parse},numberTokeniser={regex:floatRegex,countKey:"Numbers",token:"${n}",parse:number$jscomp$0.parse},convertNumbersToZero=v=>"number"===typeof v?0:v,complex={test:function(v){var _a,_b;return isNaN(v)&&isString(v)&&0<((null===(_a=v.match(floatRegex))||void 0===_a?void 0:_a.length)||0)+((null===(_b=v.match(colorRegex))||void 0===_b?void 0:_b.length)||0)},parse:parseComplexValue,createTransformer,getAnimatableNone:function(v){const parsed=parseComplexValue(v);return createTransformer(v)(parsed.map(convertNumbersToZero))}},
mixImmediate=(origin,target)=>p=>`${0<p?target:origin}`,mixArray=(from,to)=>{const output=[...from],numValues=output.length,blendValue=from.map((fromThis,i)=>getMixer$1(fromThis,to[i]));return v=>{for(let i=0;i<numValues;i++)output[i]=blendValue[i](v);return output}},mixObject=(origin,target)=>{const output={...origin,...target},blendValue={};for(const key in output)void 0!==origin[key]&&void 0!==target[key]&&(blendValue[key]=getMixer$1(origin[key],target[key]));return v=>{for(const key in blendValue)output[key]=
blendValue[key](v);return output}},mixComplex=(origin,target)=>{const template=complex.createTransformer(target),originStats=analyseComplexValue(origin),targetStats=analyseComplexValue(target);if(originStats.numVars===targetStats.numVars&&originStats.numColors===targetStats.numColors&&originStats.numNumbers>=targetStats.numNumbers)return[mixArray(originStats.values,targetStats.values),template].reduce(combineFunctions);exports.warning(!0,`Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);
return mixImmediate(origin,target)},progress=(from,to,value)=>{to-=from;return 0===to?1:(value-from)/to},mixNumber=(from,to)=>p=>-p*from+p*to+from,durationKeys=["duration","bounce"],physicsKeys=["stiffness","damping","mass"],frameloopDriver=update=>{const passTimestamp=({timestamp})=>update(timestamp);return{start:()=>frame.update(passTimestamp,!0),stop:()=>cancelFrame(passTimestamp),now:()=>frameData.isProcessing?frameData.timestamp:performance.now()}},types={decay:inertia,inertia,tween:keyframes,
keyframes,spring},supportsWaapi=memo(()=>Object.hasOwnProperty.call(Element.prototype,"animate")),acceleratedValues=new Set(["opacity","clipPath","filter","transform","backgroundColor"]),underDampedSpring={type:"spring",stiffness:500,damping:25,restSpeed:10},keyframesTransition={type:"keyframes",duration:.8},ease={type:"keyframes",ease:[.25,.1,.35,1],duration:.3},getDefaultTransition=(valueKey,{keyframes})=>2<keyframes.length?keyframesTransition:transformProps.has(valueKey)?valueKey.startsWith("scale")?
{type:"spring",stiffness:550,damping:0===keyframes[1]?2*Math.sqrt(550):30,restSpeed:10}:underDampedSpring:ease,isAnimatable=(key,value)=>"zIndex"===key?!1:"number"===typeof value||Array.isArray(value)||"string"===typeof value&&(complex.test(value)||"0"===value)&&!value.startsWith("url(")?!0:!1,maxDefaults=new Set(["brightness","contrast","saturate","opacity"]),functionRegex=/([a-z-]*)\(.*?\)/g,filter={...complex,getAnimatableNone:v=>{const functions=v.match(functionRegex);return functions?functions.map(applyDefaultFilter).join(" "):
v}},defaultValueTypes={...numberValueTypes,color:color$jscomp$0,backgroundColor:color$jscomp$0,outlineColor:color$jscomp$0,fill:color$jscomp$0,stroke:color$jscomp$0,borderColor:color$jscomp$0,borderTopColor:color$jscomp$0,borderRightColor:color$jscomp$0,borderBottomColor:color$jscomp$0,borderLeftColor:color$jscomp$0,filter,WebkitFilter:filter},MotionGlobalConfig={skipAnimations:!1},animateMotionValue=(valueName,value,target,transition={})=>onComplete=>{const valueTransition=getValueTransition$1(transition,
valueName)||{};var delay=valueTransition.delay||transition.delay||0,{elapsed=0}=transition;elapsed-=1E3*delay;const keyframes=getKeyframes(value,valueName,target,valueTransition),originKeyframe=keyframes[0],targetKeyframe=keyframes[keyframes.length-1];delay=isAnimatable(valueName,originKeyframe);const isTargetAnimatable=isAnimatable(valueName,targetKeyframe);exports.warning(delay===isTargetAnimatable,`You are trying to animate ${valueName} from "${originKeyframe}" to "${targetKeyframe}". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \`style\` property.`);
elapsed={keyframes,velocity:value.getVelocity(),ease:"easeOut",...valueTransition,delay:-elapsed,onUpdate:v=>{value.set(v);valueTransition.onUpdate&&valueTransition.onUpdate(v)},onComplete:()=>{onComplete();valueTransition.onComplete&&valueTransition.onComplete()}};isTransitionDefined(valueTransition)||(elapsed={...elapsed,...getDefaultTransition(valueName,elapsed)});elapsed.duration&&(elapsed.duration*=1E3);elapsed.repeatDelay&&(elapsed.repeatDelay*=1E3);return!delay||!isTargetAnimatable||instantAnimationState.current||
!1===valueTransition.type||MotionGlobalConfig.skipAnimations?createInstantAnimation(instantAnimationState.current?{...elapsed,delay:0}:elapsed):!transition.isHandoff&&value.owner&&value.owner.current instanceof HTMLElement&&!value.owner.getProps().onUpdate&&(delay=createAcceleratedAnimation(value,valueName,elapsed))?delay:animateValue(elapsed)};class SubscriptionManager{constructor(){this.subscriptions=[]}add(handler){addUniqueItem(this.subscriptions,handler);return()=>removeItem(this.subscriptions,
handler)}notify(a,b,c){const numSubscriptions=this.subscriptions.length;if(numSubscriptions)if(1===numSubscriptions)this.subscriptions[0](a,b,c);else for(let i=0;i<numSubscriptions;i++){const handler=this.subscriptions[i];handler&&handler(a,b,c)}}getSize(){return this.subscriptions.length}clear(){this.subscriptions.length=0}}const warned=new Set,collectMotionValues={current:void 0};class MotionValue{constructor(init,options={}){this.version="10.18.0";this.lastUpdated=this.timeDelta=0;this.canTrackVelocity=
!1;this.events={};this.updateAndNotify=(v,render=!0)=>{this.prev=this.current;this.current=v;const {delta,timestamp}=frameData;this.lastUpdated!==timestamp&&(this.timeDelta=delta,this.lastUpdated=timestamp,frame.postRender(this.scheduleVelocityCheck));this.prev!==this.current&&this.events.change&&this.events.change.notify(this.current);this.events.velocityChange&&this.events.velocityChange.notify(this.getVelocity());render&&this.events.renderRequest&&this.events.renderRequest.notify(this.current)};
this.scheduleVelocityCheck=()=>frame.postRender(this.velocityCheck);this.velocityCheck=({timestamp})=>{timestamp!==this.lastUpdated&&(this.prev=this.current,this.events.velocityChange&&this.events.velocityChange.notify(this.getVelocity()))};this.hasAnimated=!1;this.prev=this.current=init;this.canTrackVelocity=!isNaN(parseFloat(this.current));this.owner=options.owner}onChange(subscription){warnOnce(!1,'value.onChange(callback) is deprecated. Switch to value.on("change", callback).');return this.on("change",
subscription)}on(eventName,callback){this.events[eventName]||(this.events[eventName]=new SubscriptionManager);const unsubscribe=this.events[eventName].add(callback);return"change"===eventName?()=>{unsubscribe();frame.read(()=>{this.events.change.getSize()||this.stop()})}:unsubscribe}clearListeners(){for(const eventManagers in this.events)this.events[eventManagers].clear()}attach(passiveEffect,stopPassiveEffect){this.passiveEffect=passiveEffect;this.stopPassiveEffect=stopPassiveEffect}set(v,render=
!0){render&&this.passiveEffect?this.passiveEffect(v,this.updateAndNotify):this.updateAndNotify(v,render)}setWithVelocity(prev,current,delta){this.set(current);this.prev=prev;this.timeDelta=delta}jump(v){this.updateAndNotify(v);this.prev=v;this.stop();this.stopPassiveEffect&&this.stopPassiveEffect()}get(){collectMotionValues.current&&collectMotionValues.current.push(this);return this.current}getPrevious(){return this.prev}getVelocity(){if(this.canTrackVelocity){var JSCompiler_temp=parseFloat(this.current)-
parseFloat(this.prev);var frameDuration=this.timeDelta;JSCompiler_temp=frameDuration?1E3/frameDuration*JSCompiler_temp:0}else JSCompiler_temp=0;return JSCompiler_temp}start(startAnimation){this.stop();return(new Promise(resolve=>{this.hasAnimated=!0;this.animation=startAnimation(resolve);this.events.animationStart&&this.events.animationStart.notify()})).then(()=>{this.events.animationComplete&&this.events.animationComplete.notify();this.clearAnimation()})}stop(){this.animation&&(this.animation.stop(),
this.events.animationCancel&&this.events.animationCancel.notify());this.clearAnimation()}isAnimating(){return!!this.animation}clearAnimation(){delete this.animation}destroy(){this.clearListeners();this.stop();this.stopPassiveEffect&&this.stopPassiveEffect()}}const testValueType=v=>type=>type.test(v),dimensionValueTypes=[number$jscomp$0,px,percent,degrees,vw,vh,{test:v=>"auto"===v,parse:v=>v}],valueTypes=[...dimensionValueTypes,color$jscomp$0,complex],createAxisDelta=()=>({translate:0,scale:1,origin:0,
originPoint:0}),createBox=()=>({x:{min:0,max:0},y:{min:0,max:0}}),xKeys=["x","scaleX","originX"],yKeys=["y","scaleY","originY"],visualElementStore=new WeakMap,supportsScrollTimeline=memo(()=>void 0!==window.ScrollTimeline);class GroupPlaybackControls{constructor(animations){this.animations=animations.filter(Boolean)}then(onResolve,onReject){return Promise.all(this.animations).then(onResolve).catch(onReject)}getAll(propName){return this.animations[0][propName]}setAll(propName,newValue){for(let i=0;i<
this.animations.length;i++)this.animations[i][propName]=newValue}attachTimeline(timeline){const cancelAll=this.animations.map(animation=>{if(supportsScrollTimeline()&&animation.attachTimeline)animation.attachTimeline(timeline);else return animation.pause(),observeTimeline(progress=>{animation.time=animation.duration*progress},timeline)});return()=>{cancelAll.forEach((cancelTimeline,i)=>{cancelTimeline&&cancelTimeline();this.animations[i].stop()})}}get time(){return this.getAll("time")}set time(time){this.setAll("time",
time)}get speed(){return this.getAll("speed")}set speed(speed){this.setAll("speed",speed)}get duration(){let max=0;for(let i=0;i<this.animations.length;i++)max=Math.max(max,this.animations[i].duration);return max}runAll(methodName){this.animations.forEach(controls=>controls[methodName]())}play(){this.runAll("play")}pause(){this.runAll("pause")}stop(){this.runAll("stop")}cancel(){this.runAll("cancel")}complete(){this.runAll("complete")}}const splitCSSVariableRegex=/var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/,
positionalKeys=new Set("width height top left right bottom x y translateX translateY".split(" ")),isPositionalKey=key=>positionalKeys.has(key),getTranslateFromMatrix=(pos2,pos3)=>(_bbox,{transform})=>"none"!==transform&&transform?(_bbox=transform.match(/^matrix3d\((.+)\)$/))?parseFloat(_bbox[1].split(", ")[pos3]):(transform=transform.match(/^matrix\((.+)\)$/))?parseFloat(transform[1].split(", ")[pos2]):0:0,transformKeys=new Set(["x","y","z"]),nonTranslationalTransformKeys=transformPropOrder.filter(key=>
!transformKeys.has(key)),positionalValues={width:({x},{paddingLeft="0",paddingRight="0"})=>x.max-x.min-parseFloat(paddingLeft)-parseFloat(paddingRight),height:({y},{paddingTop="0",paddingBottom="0"})=>y.max-y.min-parseFloat(paddingTop)-parseFloat(paddingBottom),top:(_bbox,{top})=>parseFloat(top),left:(_bbox,{left})=>parseFloat(left),bottom:({y},{top})=>parseFloat(top)+(y.max-y.min),right:({x},{left})=>parseFloat(left)+(x.max-x.min),x:getTranslateFromMatrix(4,13),y:getTranslateFromMatrix(5,14)};positionalValues.translateX=
positionalValues.x;positionalValues.translateY=positionalValues.y;const convertChangedValueTypes=(target,visualElement,changedKeys)=>{const originBbox=visualElement.measureViewportBox(),elementComputedStyle=getComputedStyle(visualElement.current),{display}=elementComputedStyle,origin={};"none"===display&&visualElement.setStaticValue("display",target.display||"block");changedKeys.forEach(key=>{origin[key]=positionalValues[key](originBbox,elementComputedStyle)});visualElement.render();const targetBbox=
visualElement.measureViewportBox();changedKeys.forEach(key=>{const value=visualElement.getValue(key);value&&value.jump(origin[key]);target[key]=positionalValues[key](targetBbox,elementComputedStyle)});return target},checkAndConvertChangedValueTypes=(visualElement,target,origin={},transitionEnd={})=>{target={...target};transitionEnd={...transitionEnd};let removedTransformValues=[],hasAttemptedToRemoveTransformValues=!1;const changedValueTypeKeys=[];Object.keys(target).filter(isPositionalKey).forEach(key=>
{const value=visualElement.getValue(key);if(visualElement.hasValue(key)){var from=origin[key],fromType=dimensionValueTypes.find(testValueType(from)),to=target[key];if(Array.isArray(to)){const numKeyframes=to.length;var fromIndex=null===to[0]?1:0;from=to[fromIndex];for(fromType=dimensionValueTypes.find(testValueType(from));fromIndex<numKeyframes&&null!==to[fromIndex];fromIndex++)if(toType)exports.invariant(dimensionValueTypes.find(testValueType(to[fromIndex]))===toType,"All keyframes must be of the same type");
else{var toType=dimensionValueTypes.find(testValueType(to[fromIndex]));exports.invariant(toType===fromType||(fromType===number$jscomp$0||fromType===px)&&(toType===number$jscomp$0||toType===px),"Keyframes must be of the same dimension as the current value")}}else toType=dimensionValueTypes.find(testValueType(to));fromType!==toType&&(fromType!==number$jscomp$0&&fromType!==px||toType!==number$jscomp$0&&toType!==px?(null===fromType||void 0===fromType?0:fromType.transform)&&(null===toType||void 0===toType?
0:toType.transform)&&(0===from||0===to)?0===from?value.set(toType.transform(from)):target[key]=fromType.transform(to):(hasAttemptedToRemoveTransformValues||(removedTransformValues=removeNonTranslationalTransform(visualElement),hasAttemptedToRemoveTransformValues=!0),changedValueTypeKeys.push(key),transitionEnd[key]=void 0!==transitionEnd[key]?transitionEnd[key]:target[key],value.jump(to)):(from=value.get(),"string"===typeof from&&value.set(parseFloat(from)),"string"===typeof to?target[key]=parseFloat(to):
Array.isArray(to)&&toType===px&&(target[key]=to.map(parseFloat))))}});if(changedValueTypeKeys.length){const scrollY=0<=changedValueTypeKeys.indexOf("height")?window.pageYOffset:null,convertedTarget=convertChangedValueTypes(target,visualElement,changedValueTypeKeys);removedTransformValues.length&&removedTransformValues.forEach(([key,value])=>{visualElement.getValue(key).set(value)});visualElement.render();isBrowser&&null!==scrollY&&window.scrollTo({top:scrollY});return{target:convertedTarget,transitionEnd}}return{target,
transitionEnd}},prefersReducedMotion={current:null},hasReducedMotionListener={current:!1},featureNames=Object.keys(featureDefinitions),numFeatures=featureNames.length,propEventHandlers="AnimationStart AnimationComplete Update BeforeLayoutMeasure LayoutMeasure LayoutAnimationStart LayoutAnimationComplete".split(" "),numVariantProps=variantProps.length;class VisualElement{constructor({parent,props,presenceContext,reducedMotionConfig,visualState},options={}){this.current=null;this.children=new Set;this.isControllingVariants=
this.isVariantNode=!1;this.shouldReduceMotion=null;this.values=new Map;this.features={};this.valueSubscriptions=new Map;this.prevMotionValues={};this.events={};this.propEventSubscriptions={};this.notifyUpdate=()=>this.notify("Update",this.latestValues);this.render=()=>{this.current&&(this.triggerBuild(),this.renderInstance(this.current,this.renderState,this.props.style,this.projection))};this.scheduleRender=()=>frame.render(this.render,!1,!0);const {latestValues,renderState}=visualState;this.latestValues=
latestValues;this.baseTarget={...latestValues};this.initialValues=props.initial?{...latestValues}:{};this.renderState=renderState;this.parent=parent;this.props=props;this.presenceContext=presenceContext;this.depth=parent?parent.depth+1:0;this.reducedMotionConfig=reducedMotionConfig;this.options=options;this.isControllingVariants=isControllingVariants(props);if(this.isVariantNode=isVariantNode(props))this.variantChildren=new Set;this.manuallyAnimateOnMount=!(!parent||!parent.current);const {willChange,
...initialMotionValues}=this.scrapeMotionValuesFromProps(props,{});for(const key in initialMotionValues)parent=initialMotionValues[key],void 0!==latestValues[key]&&parent&&parent.getVelocity&&(parent.set(latestValues[key],!1),isWillChangeMotionValue(willChange)&&willChange.add(key))}scrapeMotionValuesFromProps(_props,_prevProps){return{}}mount(instance){this.current=instance;visualElementStore.set(instance,this);this.projection&&!this.projection.instance&&this.projection.mount(instance);this.parent&&
this.isVariantNode&&!this.isControllingVariants&&(this.removeFromVariantTree=this.parent.addVariantChild(this));this.values.forEach((value,key)=>this.bindToMotionValue(key,value));hasReducedMotionListener.current||initPrefersReducedMotion();this.shouldReduceMotion="never"===this.reducedMotionConfig?!1:"always"===this.reducedMotionConfig?!0:prefersReducedMotion.current;warnOnce(!0!==this.shouldReduceMotion,"You have Reduced Motion enabled on your device. Animations may not appear as expected.");this.parent&&
this.parent.children.add(this);this.update(this.props,this.presenceContext)}unmount(){visualElementStore.delete(this.current);this.projection&&this.projection.unmount();cancelFrame(this.notifyUpdate);cancelFrame(this.render);this.valueSubscriptions.forEach(remove=>remove());this.removeFromVariantTree&&this.removeFromVariantTree();this.parent&&this.parent.children.delete(this);for(const key in this.events)this.events[key].clear();for(const key in this.features)this.features[key].unmount();this.current=
null}bindToMotionValue(key,value){const valueIsTransform=transformProps.has(key),removeOnChange=value.on("change",latestValue=>{this.latestValues[key]=latestValue;this.props.onUpdate&&frame.update(this.notifyUpdate,!1,!0);valueIsTransform&&this.projection&&(this.projection.isTransformDirty=!0)}),removeOnRenderRequest=value.on("renderRequest",this.scheduleRender);this.valueSubscriptions.set(key,()=>{removeOnChange();removeOnRenderRequest()})}sortNodePosition(other){return this.current&&this.sortInstanceNodePosition&&
this.type===other.type?this.sortInstanceNodePosition(this.current,other.current):0}loadFeatures({children,...renderedProps},isStrict,preloadedFeatures,initialLayoutGroupConfig){let ProjectionNodeConstructor,MeasureLayout;preloadedFeatures&&isStrict&&(renderedProps.ignoreStrict?exports.warning(!1,"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead."):exports.invariant(!1,"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead."));
for(children=0;children<numFeatures;children++){isStrict=featureNames[children];const {isEnabled,Feature:FeatureConstructor,ProjectionNode,MeasureLayout:MeasureLayoutComponent}=featureDefinitions[isStrict];ProjectionNode&&(ProjectionNodeConstructor=ProjectionNode);isEnabled(renderedProps)&&(!this.features[isStrict]&&FeatureConstructor&&(this.features[isStrict]=new FeatureConstructor(this)),MeasureLayoutComponent&&(MeasureLayout=MeasureLayoutComponent))}if(("html"===this.type||"svg"===this.type)&&
!this.projection&&ProjectionNodeConstructor){this.projection=new ProjectionNodeConstructor(this.latestValues,this.parent&&this.parent.projection);const {layoutId,layout,drag,dragConstraints,layoutScroll,layoutRoot}=renderedProps;this.projection.setOptions({layoutId,layout,alwaysMeasureLayout:!!drag||dragConstraints&&isRefObject(dragConstraints),visualElement:this,scheduleRender:()=>this.scheduleRender(),animationType:"string"===typeof layout?layout:"both",initialPromotionConfig:initialLayoutGroupConfig,
layoutScroll,layoutRoot})}return MeasureLayout}updateFeatures(){for(const key in this.features){const feature=this.features[key];feature.isMounted?feature.update():(feature.mount(),feature.isMounted=!0)}}triggerBuild(){this.build(this.renderState,this.latestValues,this.options,this.props)}measureViewportBox(){return this.current?this.measureInstanceViewportBox(this.current,this.props):createBox()}getStaticValue(key){return this.latestValues[key]}setStaticValue(key,value){this.latestValues[key]=value}makeTargetAnimatable(target,
canMutate=!0){return this.makeTargetAnimatableFromInstance(target,this.props,canMutate)}update(props,presenceContext){(props.transformTemplate||this.props.transformTemplate)&&this.scheduleRender();this.prevProps=this.props;this.props=props;this.prevPresenceContext=this.presenceContext;this.presenceContext=presenceContext;for(presenceContext=0;presenceContext<propEventHandlers.length;presenceContext++){var key$jscomp$0=propEventHandlers[presenceContext];this.propEventSubscriptions[key$jscomp$0]&&(this.propEventSubscriptions[key$jscomp$0](),
delete this.propEventSubscriptions[key$jscomp$0]);var listener=props["on"+key$jscomp$0];listener&&(this.propEventSubscriptions[key$jscomp$0]=this.on(key$jscomp$0,listener))}props=this.scrapeMotionValuesFromProps(props,this.prevProps);presenceContext=this.prevMotionValues;({willChange:key$jscomp$0}=props);for(const key in props){listener=props[key];var prevValue=presenceContext[key];listener&&listener.getVelocity?(this.addValue(key,listener),isWillChangeMotionValue(key$jscomp$0)&&key$jscomp$0.add(key),
warnOnce("10.18.0"===listener.version,`Attempting to mix Framer Motion versions ${listener.version} with 10.18.0 may not work as expected.`)):prevValue&&prevValue.getVelocity?(this.addValue(key,motionValue(listener,{owner:this})),isWillChangeMotionValue(key$jscomp$0)&&key$jscomp$0.remove(key)):prevValue!==listener&&(this.hasValue(key)?(prevValue=this.getValue(key),!prevValue.hasAnimated&&prevValue.set(listener)):(prevValue=this.getStaticValue(key),this.addValue(key,motionValue(void 0!==prevValue?
prevValue:listener,{owner:this}))))}for(const key in presenceContext)void 0===props[key]&&this.removeValue(key);this.prevMotionValues=props;this.handleChildMotionValue&&this.handleChildMotionValue()}getProps(){return this.props}getVariant(name){return this.props.variants?this.props.variants[name]:void 0}getDefaultTransition(){return this.props.transition}getTransformPagePoint(){return this.props.transformPagePoint}getClosestVariantNode(){return this.isVariantNode?this:this.parent?this.parent.getClosestVariantNode():
void 0}getVariantContext(startAtParent=!1){if(startAtParent)return this.parent?this.parent.getVariantContext():void 0;if(!this.isControllingVariants)return startAtParent=this.parent?this.parent.getVariantContext()||{}:{},void 0!==this.props.initial&&(startAtParent.initial=this.props.initial),startAtParent;startAtParent={};for(let i=0;i<numVariantProps;i++){const name=variantProps[i],prop=this.props[name];if(isVariantLabel(prop)||!1===prop)startAtParent[name]=prop}return startAtParent}addVariantChild(child){const closestVariantNode=
this.getClosestVariantNode();if(closestVariantNode)return closestVariantNode.variantChildren&&closestVariantNode.variantChildren.add(child),()=>closestVariantNode.variantChildren.delete(child)}addValue(key,value){value!==this.values.get(key)&&(this.removeValue(key),this.bindToMotionValue(key,value));this.values.set(key,value);this.latestValues[key]=value.get()}removeValue(key){this.values.delete(key);const unsubscribe=this.valueSubscriptions.get(key);unsubscribe&&(unsubscribe(),this.valueSubscriptions.delete(key));
delete this.latestValues[key];this.removeValueFromRenderState(key,this.renderState)}hasValue(key){return this.values.has(key)}getValue(key,defaultValue){if(this.props.values&&this.props.values[key])return this.props.values[key];let value=this.values.get(key);void 0===value&&void 0!==defaultValue&&(value=motionValue(defaultValue,{owner:this}),this.addValue(key,value));return value}readValue(key){var _a;return void 0===this.latestValues[key]&&this.current?null!==(_a=this.getBaseTargetFromProps(this.props,
key))&&void 0!==_a?_a:this.readValueFromInstance(this.current,key,this.options):this.latestValues[key]}setBaseTarget(key,value){this.baseTarget[key]=value}getBaseTarget(key){var _a;const {initial}=this.props,valueFromInitial="string"===typeof initial||"object"===typeof initial?null===(_a=resolveVariantFromProps(this.props,initial))||void 0===_a?void 0:_a[key]:void 0;if(initial&&void 0!==valueFromInitial)return valueFromInitial;_a=this.getBaseTargetFromProps(this.props,key);return void 0===_a||_a&&
_a.getVelocity?void 0!==this.initialValues[key]&&void 0===valueFromInitial?void 0:this.baseTarget[key]:_a}on(eventName,callback){this.events[eventName]||(this.events[eventName]=new SubscriptionManager);return this.events[eventName].add(callback)}notify(eventName,...args){this.events[eventName]&&this.events[eventName].notify(...args)}}class DOMVisualElement extends VisualElement{sortInstanceNodePosition(a,b){return a.compareDocumentPosition(b)&2?1:-1}getBaseTargetFromProps(props,key){return props.style?
props.style[key]:void 0}removeValueFromRenderState(key,{vars,style}){delete vars[key];delete style[key]}makeTargetAnimatableFromInstance({transition,transitionEnd,...target},{transformValues},isMounted){let origin=getOrigin(target,transition||{},this);transformValues&&(transitionEnd&&(transitionEnd=transformValues(transitionEnd)),target&&(target=transformValues(target)),origin&&(origin=transformValues(origin)));isMounted&&(checkTargetForNewValues(this,target,origin),transformValues=origin,target=
resolveCSSVariables(this,target,transitionEnd),transitionEnd=target.target,target=target.transitionEnd,transformValues=Object.keys(transitionEnd).some(isPositionalKey)?checkAndConvertChangedValueTypes(this,transitionEnd,transformValues,target):{target:transitionEnd,transitionEnd:target},transitionEnd=transformValues.transitionEnd,target=transformValues.target);return{transition,transitionEnd,...target}}}class SVGVisualElement extends DOMVisualElement{constructor(){super(...arguments);this.type="svg";
this.isSVGTag=!1}getBaseTargetFromProps(props,key){return props[key]}readValueFromInstance(instance,key){if(transformProps.has(key))return(instance=defaultValueTypes[key])?instance.default||0:0;key=camelCaseAttributes.has(key)?key:camelToDash(key);return instance.getAttribute(key)}measureInstanceViewportBox(){return createBox()}scrapeMotionValuesFromProps(props,prevProps){return scrapeMotionValuesFromProps(props,prevProps)}build(renderState,latestValues,options,props){buildSVGAttrs(renderState,latestValues,
options,this.isSVGTag,props.transformTemplate)}renderInstance(instance,renderState,styleProp,projection){renderSVG(instance,renderState,styleProp,projection)}mount(instance){this.isSVGTag=isSVGTag(instance.tagName);super.mount(instance)}}class HTMLVisualElement extends DOMVisualElement{constructor(){super(...arguments);this.type="html"}readValueFromInstance(instance,key){if(transformProps.has(key))return(key=defaultValueTypes[key])?key.default||0:0;instance=window.getComputedStyle(instance);key=(isCSSVariableName(key)?
instance.getPropertyValue(key):instance[key])||0;return"string"===typeof key?key.trim():key}measureInstanceViewportBox(instance,{transformPagePoint}){return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(),transformPagePoint))}build(renderState,latestValues,options,props){buildHTMLStyles(renderState,latestValues,options,props.transformTemplate)}scrapeMotionValuesFromProps(props,prevProps){return scrapeMotionValuesFromProps$1(props,prevProps)}handleChildMotionValue(){this.childSubscription&&
(this.childSubscription(),delete this.childSubscription);const {children}=this.props;children&&children.getVelocity&&(this.childSubscription=children.on("change",latest=>{this.current&&(this.current.textContent=`${latest}`)}))}renderInstance(instance,renderState,styleProp,projection){renderHTML(instance,renderState,styleProp,projection)}}const wrap=(min,max,v)=>{max-=min;return((v-min)%max+max)%max+min},isNumber=keyframe=>"number"===typeof keyframe,createScopedAnimate=scope=>function(valueOrElementOrSequence,
keyframes,options){valueOrElementOrSequence=Array.isArray(valueOrElementOrSequence)&&Array.isArray(valueOrElementOrSequence[0])?animateSequence(valueOrElementOrSequence,keyframes,scope):"object"!==typeof keyframes||Array.isArray(keyframes)?animateSingleValue(valueOrElementOrSequence,keyframes,options):animateElements(valueOrElementOrSequence,keyframes,options,scope);scope&&scope.animations.push(valueOrElementOrSequence);return valueOrElementOrSequence},animate=createScopedAnimate(),resizeHandlers=
new WeakMap;let observer;const windowCallbacks=new Set;let windowResizeHandler;const createAxisInfo=()=>({current:0,offset:[],progress:0,scrollLength:0,targetOffset:0,targetLength:0,containerLength:0,velocity:0}),keys={x:{length:"Width",position:"Left"},y:{length:"Height",position:"Top"}},ScrollOffset={Enter:[[0,1],[1,1]],Exit:[[0,0],[1,0]],Any:[[1,0],[0,1]],All:[[0,0],[1,1]]},namedEdges={start:0,center:.5,end:1},defaultOffset=[0,0],point$jscomp$0={x:0,y:0},scrollListeners=new WeakMap,resizeListeners=
new WeakMap,onScrollHandlers=new WeakMap,timelineCache=new Map,thresholds={some:0,all:1},sync=frame,cancelSync=stepsOrder.reduce((acc,key)=>{acc[key]=process=>cancelFrame(process);return acc},{});exports.HTMLVisualElement=HTMLVisualElement;exports.MotionGlobalConfig=MotionGlobalConfig;exports.MotionValue=MotionValue;exports.SVGVisualElement=SVGVisualElement;exports.SubscriptionManager=SubscriptionManager;exports.VisualElement=VisualElement;exports.addScaleCorrector=function(correctors){Object.assign(scaleCorrectors,
correctors)};exports.addUniqueItem=addUniqueItem;exports.animate=animate;exports.animateMotionValue=animateMotionValue;exports.animateSingleValue=animateSingleValue;exports.animateStyle=animateStyle;exports.animateTarget=animateTarget;exports.animateValue=animateValue;exports.anticipate=anticipate;exports.applyBoxDelta=applyBoxDelta;exports.applyTreeDeltas=function(box,treeScale,treePath,isSharedTransition=!1){const treeLength=treePath.length;if(treeLength){treeScale.x=treeScale.y=1;for(let i=0;i<
treeLength;i++){var node=treePath[i];var delta=node.projectionDelta;const instance=node.instance;instance&&instance.style&&"contents"===instance.style.display||(isSharedTransition&&node.options.layoutScroll&&node.scroll&&node!==node.root&&transformBox(box,{x:-node.scroll.offset.x,y:-node.scroll.offset.y}),delta&&(treeScale.x*=delta.x.scale,treeScale.y*=delta.y.scale,applyBoxDelta(box,delta)),isSharedTransition&&hasTransform(node.latestValues)&&transformBox(box,node.latestValues))}treeScale.x=snapToDefault(treeScale.x);
treeScale.y=snapToDefault(treeScale.y)}};exports.backIn=backIn;exports.backInOut=backInOut;exports.backOut=backOut;exports.buildHTMLStyles=buildHTMLStyles;exports.buildSVGAttrs=buildSVGAttrs;exports.buildTransform=buildTransform;exports.camelToDash=camelToDash;exports.cancelFrame=cancelFrame;exports.cancelSync=cancelSync;exports.checkTargetForNewValues=checkTargetForNewValues;exports.circIn=circIn;exports.circInOut=circInOut;exports.circOut=circOut;exports.clamp=clamp;exports.collectMotionValues=
collectMotionValues;exports.color=color$jscomp$0;exports.complex=complex;exports.convertBoundingBoxToBox=convertBoundingBoxToBox;exports.convertBoxToBoundingBox=function({x,y}){return{top:y.min,right:x.max,bottom:y.max,left:x.min}};exports.createBox=createBox;exports.createDelta=()=>({x:createAxisDelta(),y:createAxisDelta()});exports.createScopedAnimate=createScopedAnimate;exports.cubicBezier=cubicBezier;exports.delay=function(callback,timeout){const start=performance.now(),checkElapsed=({timestamp})=>
{timestamp-=start;timestamp>=timeout&&(cancelFrame(checkElapsed),callback(timestamp-timeout))};frame.read(checkElapsed,!0);return()=>cancelFrame(checkElapsed)};exports.distance=(a,b)=>Math.abs(a-b);exports.distance2D=function(a,b){return Math.sqrt(Math.abs(a.x-b.x)**2+Math.abs(a.y-b.y)**2)};exports.easeIn=easeIn;exports.easeInOut=easeInOut;exports.easeOut=easeOut;exports.featureDefinitions=featureDefinitions;exports.frame=frame;exports.frameData=frameData;exports.getOrigin=getOrigin;exports.getValueTransition=
getValueTransition$1;exports.has2DTranslate=has2DTranslate;exports.hasReducedMotionListener=hasReducedMotionListener;exports.hasScale=hasScale;exports.hasTransform=hasTransform;exports.inView=function(elementOrSelector,onStart,{root,margin:rootMargin,amount="some"}={}){elementOrSelector=resolveElements(elementOrSelector);const activeIntersections=new WeakMap,observer=new IntersectionObserver(entries=>{entries.forEach(entry=>{var onEnd=activeIntersections.get(entry.target);entry.isIntersecting!==!!onEnd&&
(entry.isIntersecting?(onEnd=onStart(entry),"function"===typeof onEnd?activeIntersections.set(entry.target,onEnd):observer.unobserve(entry.target)):onEnd&&(onEnd(entry),activeIntersections.delete(entry.target)))})},{root,rootMargin,threshold:"number"===typeof amount?amount:thresholds[amount]});elementOrSelector.forEach(element=>observer.observe(element));return()=>observer.disconnect()};exports.initPrefersReducedMotion=initPrefersReducedMotion;exports.instantAnimationState=instantAnimationState;exports.interpolate=
interpolate;exports.isAnimationControls=isAnimationControls;exports.isBrowser=isBrowser;exports.isCSSVariableName=isCSSVariableName;exports.isControllingVariants=isControllingVariants;exports.isCustomValue=v=>!!(v&&"object"===typeof v&&v.mix&&v.toValue);exports.isForcedMotionValue=isForcedMotionValue;exports.isKeyframesTarget=v=>Array.isArray(v);exports.isMotionValue=value=>!(!value||!value.getVelocity);exports.isRefObject=isRefObject;exports.isSVGElement=isSVGElement;exports.isSVGTag=isSVGTag;exports.isVariantLabel=
isVariantLabel;exports.isVariantNode=isVariantNode;exports.measurePageBox=function(element,rootProjectionNode,transformPagePoint){element=convertBoundingBoxToBox(transformBoxPoints(element.getBoundingClientRect(),transformPagePoint));({scroll:rootProjectionNode}=rootProjectionNode);rootProjectionNode&&(translateAxis(element.x,rootProjectionNode.offset.x),translateAxis(element.y,rootProjectionNode.offset.y));return element};exports.millisecondsToSeconds=milliseconds=>milliseconds/1E3;exports.mirrorEasing=
mirrorEasing;exports.mix=mix;exports.motionValue=motionValue;exports.moveItem=function([...arr],fromIndex,toIndex){const startIndex=0>fromIndex?arr.length+fromIndex:fromIndex;0<=startIndex&&startIndex<arr.length&&(toIndex=0>toIndex?arr.length+toIndex:toIndex,[fromIndex]=arr.splice(fromIndex,1),arr.splice(toIndex,0,fromIndex));return arr};exports.noop=noop;exports.optimizedAppearDataAttribute=optimizedAppearDataAttribute;exports.optimizedAppearDataId="framerAppearId";exports.percent=percent;exports.pipe=
(...transformers)=>transformers.reduce(combineFunctions);exports.prefersReducedMotion=prefersReducedMotion;exports.progress=progress;exports.px=px;exports.removeItem=removeItem;exports.renderSVG=renderSVG;exports.resolveVariant=resolveVariant;exports.resolveVariantFromProps=resolveVariantFromProps;exports.reverseEasing=reverseEasing;exports.scaleCorrectors=scaleCorrectors;exports.scalePoint=scalePoint;exports.scrapeMotionValuesFromProps=scrapeMotionValuesFromProps;exports.scrapeMotionValuesFromProps$1=
scrapeMotionValuesFromProps$1;exports.scroll=function(onScroll,options){options=getTimeline(options);return"function"===typeof onScroll?observeTimeline(onScroll,options):onScroll.attachTimeline(options)};exports.scrollInfo=scrollInfo;exports.secondsToMilliseconds=seconds=>1E3*seconds;exports.setValues=function(visualElement,definition){if(Array.isArray(definition))return setVariants(visualElement,definition);if("string"===typeof definition)return setVariants(visualElement,[definition]);setTarget(visualElement,
definition)};exports.spring=spring;exports.stagger=function(duration=.1,{startDelay=0,from=0,ease}={}){return(i,total)=>{if("number"===typeof from)var JSCompiler_temp=from;else"first"===from?JSCompiler_temp=0:(JSCompiler_temp=total-1,JSCompiler_temp="last"===from?JSCompiler_temp:JSCompiler_temp/2);i=duration*Math.abs(JSCompiler_temp-i);ease&&(total*=duration,i=easingDefinitionToFunction(ease)(i/total)*total);return startDelay+i}};exports.steps=steps;exports.sync=sync;exports.transform=function(...args){const useImmediate=
!Array.isArray(args[0]),argOffset=useImmediate?0:-1,inputValue=args[0+argOffset],outputRange=args[2+argOffset];var v=outputRange[0];args=interpolate(args[1+argOffset],outputRange,{mixer:v&&"object"===typeof v&&v.mix?v.mix:void 0,...args[3+argOffset]});return useImmediate?args(inputValue):args};exports.transformBox=transformBox;exports.transformProps=transformProps;exports.translateAxis=translateAxis;exports.variantPriorityOrder=variantPriorityOrder;exports.visualElementStore=visualElementStore;exports.warnOnce=
warnOnce;exports.wrap=wrap}
//# sourceMappingURL=module$node_modules$framer_motion$dist$cjs$index_legacy_87714a68.js.map
