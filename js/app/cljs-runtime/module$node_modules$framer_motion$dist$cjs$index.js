import "./cljs_env.js";
import "./shadow.js.js";
import "./module$node_modules$react$index.js";
import "./module$node_modules$framer_motion$dist$cjs$index_legacy_87714a68.js";
import "./module$node_modules$framer_motion$node_modules$$emotion$is_prop_valid$dist$is_prop_valid_browser_cjs.js";
shadow$provide.module$node_modules$framer_motion$dist$cjs$index=function(global,require,module,exports){function useVisualElement(Component,visualState,props,createVisualElement){const {visualElement:parent}=React.useContext(MotionContext),lazyContext=React.useContext(LazyContext),presenceContext=React.useContext(PresenceContext),reducedMotionConfig=React.useContext(MotionConfigContext).reducedMotion,visualElementRef=React.useRef();createVisualElement=createVisualElement||lazyContext.renderer;!visualElementRef.current&&
createVisualElement&&(visualElementRef.current=createVisualElement(Component,{visualState,parent,props,presenceContext,blockInitialAnimation:presenceContext?!1===presenceContext.initial:!1,reducedMotionConfig}));const visualElement=visualElementRef.current;React.useInsertionEffect(()=>{visualElement&&visualElement.update(props,presenceContext)});const wantsHandoff=React.useRef(!(!props[indexLegacy.optimizedAppearDataAttribute]||window.HandoffComplete));useIsomorphicLayoutEffect(()=>{visualElement&&
(visualElement.render(),wantsHandoff.current&&visualElement.animationState&&visualElement.animationState.animateChanges())});React.useEffect(()=>{visualElement&&(visualElement.updateFeatures(),!wantsHandoff.current&&visualElement.animationState&&visualElement.animationState.animateChanges(),wantsHandoff.current&&(wantsHandoff.current=!1,window.HandoffComplete=!0))});return visualElement}function useMotionRef(visualState,visualElement,externalRef){return React.useCallback(instance=>{instance&&visualState.mount&&
visualState.mount(instance);visualElement&&(instance?visualElement.mount(instance):visualElement.unmount());externalRef&&("function"===typeof externalRef?externalRef(instance):indexLegacy.isRefObject(externalRef)&&(externalRef.current=instance))},[visualElement])}function getCurrentTreeVariants(props,context){if(indexLegacy.isControllingVariants(props)){const {initial,animate}=props;return{initial:!1===initial||indexLegacy.isVariantLabel(initial)?initial:void 0,animate:indexLegacy.isVariantLabel(animate)?
animate:void 0}}return!1!==props.inherit?context:{}}function useCreateMotionContext(props){const {initial,animate}=getCurrentTreeVariants(props,React.useContext(MotionContext));return React.useMemo(()=>({initial,animate}),[variantLabelsAsDependency(initial),variantLabelsAsDependency(animate)])}function variantLabelsAsDependency(prop){return Array.isArray(prop)?prop.join(" "):prop}function loadFeatures(features){for(const key in features)indexLegacy.featureDefinitions[key]={...indexLegacy.featureDefinitions[key],
...features[key]}}function createMotionComponent({preloadedFeatures,createVisualElement,useRender,useVisualState,Component}){preloadedFeatures&&loadFeatures(preloadedFeatures);const ForwardRefComponent=React.forwardRef(function(props,externalRef){let MeasureLayout;const configAndProps={...React.useContext(MotionConfigContext),...props,layoutId:useLayoutId(props)},{isStatic}=configAndProps,context=useCreateMotionContext(props),visualState=useVisualState(props,isStatic);if(!isStatic&&indexLegacy.isBrowser){context.visualElement=
useVisualElement(Component,visualState,configAndProps,createVisualElement);const initialLayoutGroupConfig=React.useContext(SwitchLayoutGroupContext),isStrict=React.useContext(LazyContext).strict;context.visualElement&&(MeasureLayout=context.visualElement.loadFeatures(configAndProps,isStrict,preloadedFeatures,initialLayoutGroupConfig))}return React__namespace.createElement(MotionContext.Provider,{value:context},MeasureLayout&&context.visualElement?React__namespace.createElement(MeasureLayout,{visualElement:context.visualElement,
...configAndProps}):null,useRender(Component,props,useMotionRef(visualState,context.visualElement,externalRef),visualState,isStatic,context.visualElement))});ForwardRefComponent[motionComponentSymbol]=Component;return ForwardRefComponent}function useLayoutId({layoutId}){const layoutGroupId=React.useContext(LayoutGroupContext).id;return layoutGroupId&&void 0!==layoutId?layoutGroupId+"-"+layoutId:layoutId}function createMotionProxy(createConfig){function custom(Component,customMotionComponentConfig=
{}){return createMotionComponent(createConfig(Component,customMotionComponentConfig))}if("undefined"===typeof Proxy)return custom;const componentCache=new Map;return new Proxy(custom,{get:(_target,key)=>{componentCache.has(key)||componentCache.set(key,custom(key));return componentCache.get(key)}})}function isSVGComponent(Component){return"string"===typeof Component&&!Component.includes("-")&&(-1<lowercaseSVGElements.indexOf(Component)||/[A-Z]/.test(Component))?!0:!1}function copyRawValuesOnly(target,
source,props){for(const key in source)indexLegacy.isMotionValue(source[key])||indexLegacy.isForcedMotionValue(key,props)||(target[key]=source[key])}function useInitialMotionValues({transformTemplate},visualState,isStatic){return React.useMemo(()=>{const state=createHtmlRenderState();indexLegacy.buildHTMLStyles(state,visualState,{enableHardwareAcceleration:!isStatic},transformTemplate);return Object.assign({},state.vars,state.style)},[visualState])}function useHTMLProps(props,visualState,isStatic){const htmlProps=
{},style={};copyRawValuesOnly(style,props.style||{},props);Object.assign(style,useInitialMotionValues(props,visualState,isStatic));visualState=props.transformValues?props.transformValues(style):style;props.drag&&!1!==props.dragListener&&(htmlProps.draggable=!1,visualState.userSelect=visualState.WebkitUserSelect=visualState.WebkitTouchCallout="none",visualState.touchAction=!0===props.drag?"none":`pan-${"x"===props.drag?"y":"x"}`);void 0===props.tabIndex&&(props.onTap||props.onTapStart||props.whileTap)&&
(htmlProps.tabIndex=0);htmlProps.style=visualState;return htmlProps}function isValidMotionProp(key){return key.startsWith("while")||key.startsWith("drag")&&"draggable"!==key||key.startsWith("layout")||key.startsWith("onTap")||key.startsWith("onPan")||key.startsWith("onLayout")||validMotionProps.has(key)}function loadExternalIsValidProp(isValidProp){isValidProp&&(shouldForward=key=>key.startsWith("on")?!isValidMotionProp(key):isValidProp(key))}function filterProps(props,isDom,forwardMotionProps){const filteredProps=
{};for(const key in props)if("values"!==key||"object"!==typeof props.values)if(shouldForward(key)||!0===forwardMotionProps&&isValidMotionProp(key)||!isDom&&!isValidMotionProp(key)||props.draggable&&key.startsWith("onDrag"))filteredProps[key]=props[key];return filteredProps}function useSVGProps(props,visualState,_isStatic,Component){_isStatic=React.useMemo(()=>{const state=createSvgRenderState();indexLegacy.buildSVGAttrs(state,visualState,{enableHardwareAcceleration:!1},indexLegacy.isSVGTag(Component),
props.transformTemplate);return{...state.attrs,style:{...state.style}}},[visualState]);if(props.style){const rawStyles={};copyRawValuesOnly(rawStyles,props.style,props);_isStatic.style={...rawStyles,..._isStatic.style}}return _isStatic}function createUseRender(forwardMotionProps=!1){return(Component,props,ref,{latestValues},isStatic)=>{latestValues=(isSVGComponent(Component)?useSVGProps:useHTMLProps)(props,latestValues,isStatic,Component);ref={...filterProps(props,"string"===typeof Component,forwardMotionProps),
...latestValues,ref};const {children}=props;props=React.useMemo(()=>indexLegacy.isMotionValue(children)?children.get():children,[children]);return React.createElement(Component,{...ref,children:props})}}function useConstant(init){const ref=React.useRef(null);null===ref.current&&(ref.current=init());return ref.current}function resolveMotionValue(value){value=indexLegacy.isMotionValue(value)?value.get():value;return indexLegacy.isCustomValue(value)?value.toValue():value}function makeState({scrapeMotionValuesFromProps,
createRenderState,onMount},props,context,presenceContext){const state={latestValues:makeLatestValues(props,context,presenceContext,scrapeMotionValuesFromProps),renderState:createRenderState()};onMount&&(state.mount=instance=>onMount(props,instance,state));return state}function makeLatestValues(props,context,presenceContext,scrapeMotionValues){const values={};scrapeMotionValues=scrapeMotionValues(props,{});for(var key$jscomp$0 in scrapeMotionValues)values[key$jscomp$0]=resolveMotionValue(scrapeMotionValues[key$jscomp$0]);
let {initial,animate}=props;key$jscomp$0=indexLegacy.isControllingVariants(props);scrapeMotionValues=indexLegacy.isVariantNode(props);context&&scrapeMotionValues&&!key$jscomp$0&&!1!==props.inherit&&(void 0===initial&&(initial=context.initial),void 0===animate&&(animate=context.animate));let isInitialAnimationBlocked=presenceContext?!1===presenceContext.initial:!1;(context=(isInitialAnimationBlocked=isInitialAnimationBlocked||!1===initial)?animate:initial)&&"boolean"!==typeof context&&!indexLegacy.isAnimationControls(context)&&
(Array.isArray(context)?context:[context]).forEach(definition=>{if(definition=indexLegacy.resolveVariantFromProps(props,definition)){var {transitionEnd,transition,...target}=definition;for(const key in target)definition=target[key],Array.isArray(definition)&&(definition=definition[isInitialAnimationBlocked?definition.length-1:0]),null!==definition&&(values[key]=definition);for(const key in transitionEnd)values[key]=transitionEnd[key]}});return values}function createDomMotionConfig(Component,{forwardMotionProps=
!1},preloadedFeatures,createVisualElement){return{...(isSVGComponent(Component)?svgMotionConfig:htmlMotionConfig),preloadedFeatures,useRender:createUseRender(forwardMotionProps),createVisualElement,Component}}function addDomEvent(target,eventName,handler,options={passive:!0}){target.addEventListener(eventName,handler,options);return()=>target.removeEventListener(eventName,handler)}function extractEventInfo(event,pointType="page"){return{point:{x:event[pointType+"X"],y:event[pointType+"Y"]}}}function addPointerEvent(target,
eventName,handler,options){return addDomEvent(target,eventName,addPointerInfo(handler),options)}function createLock(name){let lock=null;return()=>null===lock?(lock=name,()=>{lock=null}):!1}function getGlobalLock(drag){let lock=!1;if("y"===drag)lock=globalVerticalLock();else if("x"===drag)lock=globalHorizontalLock();else{const openHorizontal=globalHorizontalLock(),openVertical=globalVerticalLock();openHorizontal&&openVertical?lock=()=>{openHorizontal();openVertical()}:(openHorizontal&&openHorizontal(),
openVertical&&openVertical())}return lock}function isDragActive(){const openGestureLock=getGlobalLock(!0);if(!openGestureLock)return!0;openGestureLock();return!1}function addHoverEvent(node,isActive){const callbackName="onHover"+(isActive?"Start":"End");return addPointerEvent(node.current,"pointer"+(isActive?"enter":"leave"),(event,info)=>{if("touch"!==event.pointerType&&!isDragActive()){var props=node.getProps();node.animationState&&props.whileHover&&node.animationState.setActive("whileHover",isActive);
props[callbackName]&&indexLegacy.frame.update(()=>props[callbackName](event,info))}},{passive:!node.getProps()[callbackName]})}function fireSyntheticPointerEvent(name,handler){handler&&(name=new PointerEvent("pointer"+name),handler(name,extractEventInfo(name)))}function initIntersectionObserver({root,...options}){var lookupRoot=root||document;observers.has(lookupRoot)||observers.set(lookupRoot,{});lookupRoot=observers.get(lookupRoot);const key=JSON.stringify(options);lookupRoot[key]||(lookupRoot[key]=
new IntersectionObserver(fireAllObserverCallbacks,{root,...options}));return lookupRoot[key]}function observeIntersection(element,options,callback){const rootInteresectionObserver=initIntersectionObserver(options);observerCallbacks.set(element,callback);rootInteresectionObserver.observe(element);return()=>{observerCallbacks.delete(element);rootInteresectionObserver.unobserve(element)}}function hasViewportOptionChanged({viewport={}},{viewport:prevViewport={}}={}){return name=>viewport[name]!==prevViewport[name]}
function shallowCompare(next,prev){if(!Array.isArray(prev))return!1;const prevLength=prev.length;if(prevLength!==next.length)return!1;for(let i=0;i<prevLength;i++)if(prev[i]!==next[i])return!1;return!0}function animateVariant(visualElement,variant,options={}){const resolved=indexLegacy.resolveVariant(visualElement,variant,options.custom);let {transition=visualElement.getDefaultTransition()||{}}=resolved||{};options.transitionOverride&&(transition=options.transitionOverride);const getAnimation=resolved?
()=>Promise.all(indexLegacy.animateTarget(visualElement,resolved,options)):()=>Promise.resolve(),getChildAnimations=visualElement.variantChildren&&visualElement.variantChildren.size?(forwardDelay=0)=>{const {delayChildren=0,staggerChildren,staggerDirection}=transition;return animateChildren(visualElement,variant,delayChildren+forwardDelay,staggerChildren,staggerDirection,options)}:()=>Promise.resolve(),{when}=transition;if(when){const [first,last]="beforeChildren"===when?[getAnimation,getChildAnimations]:
[getChildAnimations,getAnimation];return first().then(()=>last())}return Promise.all([getAnimation(),getChildAnimations(options.delay)])}function animateChildren(visualElement,variant,delayChildren=0,staggerChildren=0,staggerDirection=1,options){const animations=[],maxStaggerDuration=(visualElement.variantChildren.size-1)*staggerChildren,generateStaggerDuration=1===staggerDirection?(i=0)=>i*staggerChildren:(i=0)=>maxStaggerDuration-i*staggerChildren;Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child,
i)=>{child.notify("AnimationStart",variant);animations.push(animateVariant(child,variant,{...options,delay:delayChildren+generateStaggerDuration(i)}).then(()=>child.notify("AnimationComplete",variant)))});return Promise.all(animations)}function sortByTreeOrder(a,b){return a.sortNodePosition(b)}function animateVisualElement(visualElement,definition,options={}){visualElement.notify("AnimationStart",definition);if(Array.isArray(definition)){var animation=definition.map(variant=>animateVariant(visualElement,
variant,options));animation=Promise.all(animation)}else"string"===typeof definition?animation=animateVariant(visualElement,definition,options):(animation="function"===typeof definition?indexLegacy.resolveVariant(visualElement,definition,options.custom):definition,animation=Promise.all(indexLegacy.animateTarget(visualElement,animation,options)));return animation.then(()=>visualElement.notify("AnimationComplete",definition))}function animateList(visualElement){return animations=>Promise.all(animations.map(({animation,
options})=>animateVisualElement(visualElement,animation,options)))}function createAnimationState(visualElement){function animateChanges(options,changedActiveType){const props=visualElement.getProps(),context=visualElement.getVariantContext(!0)||{},animations=[],removedKeys=new Set;let encounteredKeys={},removedVariantIndex=Infinity;for(let i=0;i<numAnimationTypes;i++){const type=reversePriorityOrder[i],typeState=state[type],prop=void 0!==props[type]?props[type]:context[type];var propIsVariant=indexLegacy.isVariantLabel(prop),
activeDelta=type===changedActiveType?typeState.isActive:null;!1===activeDelta&&(removedVariantIndex=i);let isInherited=prop===context[type]&&prop!==props[type]&&propIsVariant;isInherited&&isInitialRender&&visualElement.manuallyAnimateOnMount&&(isInherited=!1);typeState.protectedKeys={...encounteredKeys};if(!typeState.isActive&&null===activeDelta||!prop&&!typeState.prevProp||indexLegacy.isAnimationControls(prop)||"boolean"===typeof prop)continue;let shouldAnimateType=checkVariantsDidChange(typeState.prevProp,
prop)||type===changedActiveType&&typeState.isActive&&!isInherited&&propIsVariant||i>removedVariantIndex&&propIsVariant,handledRemovedValues=!1;propIsVariant=Array.isArray(prop)?prop:[prop];let resolvedValues=propIsVariant.reduce(buildResolvedTypeValues,{});!1===activeDelta&&(resolvedValues={});({prevResolvedValues:activeDelta={}}=typeState);var allKeys={...activeDelta,...resolvedValues};const markToAnimate=key=>{shouldAnimateType=!0;removedKeys.has(key)&&(handledRemovedValues=!0,removedKeys.delete(key));
typeState.needsAnimating[key]=!0};for(const key in allKeys){allKeys=resolvedValues[key];const prev=activeDelta[key];if(encounteredKeys.hasOwnProperty(key))continue;let valueHasChanged=!1;(valueHasChanged=indexLegacy.isKeyframesTarget(allKeys)&&indexLegacy.isKeyframesTarget(prev)?!shallowCompare(allKeys,prev):allKeys!==prev)?void 0!==allKeys?markToAnimate(key):removedKeys.add(key):void 0!==allKeys&&removedKeys.has(key)?markToAnimate(key):typeState.protectedKeys[key]=!0}typeState.prevProp=prop;typeState.prevResolvedValues=
resolvedValues;typeState.isActive&&(encounteredKeys={...encounteredKeys,...resolvedValues});isInitialRender&&visualElement.blockInitialAnimation&&(shouldAnimateType=!1);!shouldAnimateType||isInherited&&!handledRemovedValues||animations.push(...propIsVariant.map(animation=>({animation,options:{type,...options}})))}if(removedKeys.size){const fallbackAnimation={};removedKeys.forEach(key=>{const fallbackTarget=visualElement.getBaseTarget(key);void 0!==fallbackTarget&&(fallbackAnimation[key]=fallbackTarget)});
animations.push({animation:fallbackAnimation})}changedActiveType=!!animations.length;!isInitialRender||!1!==props.initial&&props.initial!==props.animate||visualElement.manuallyAnimateOnMount||(changedActiveType=!1);isInitialRender=!1;return changedActiveType?animate(animations):Promise.resolve()}let animate=animateList(visualElement);const state={animate:createTypeState(!0),whileInView:createTypeState(),whileHover:createTypeState(),whileTap:createTypeState(),whileDrag:createTypeState(),whileFocus:createTypeState(),
exit:createTypeState()};let isInitialRender=!0;const buildResolvedTypeValues=(acc,definition)=>{if(definition=indexLegacy.resolveVariant(visualElement,definition)){const {transition,transitionEnd,...target}=definition;acc={...acc,...target,...transitionEnd}}return acc};return{animateChanges,setActive:function(type,isActive,options){var _a$jscomp$0;if(state[type].isActive===isActive)return Promise.resolve();null===(_a$jscomp$0=visualElement.variantChildren)||void 0===_a$jscomp$0?void 0:_a$jscomp$0.forEach(child=>
{var _a;return null===(_a=child.animationState)||void 0===_a?void 0:_a.setActive(type,isActive)});state[type].isActive=isActive;options=animateChanges(options,type);for(const key in state)state[key].protectedKeys={};return options},setAnimateFunction:function(makeAnimator){animate=makeAnimator(visualElement)},getState:()=>state}}function checkVariantsDidChange(prev,next){return"string"===typeof next?next!==prev:Array.isArray(next)?!shallowCompare(next,prev):!1}function createTypeState(isActive=!1){return{isActive,
protectedKeys:{},needsAnimating:{},prevResolvedValues:{}}}function transformPoint(info,transformPagePoint){return transformPagePoint?{point:transformPagePoint(info.point)}:info}function subtractPoint(a,b){return{x:a.x-b.x,y:a.y-b.y}}function getPanInfo({point},history){return{point,delta:subtractPoint(point,history[history.length-1]),offset:subtractPoint(point,history[0]),velocity:getVelocity(history,.1)}}function getVelocity(history,timeDelta){if(2>history.length)return{x:0,y:0};let i=history.length-
1;var timestampedPoint=null;const lastPoint=history[history.length-1];for(;0<=i;){timestampedPoint=history[i];if(lastPoint.timestamp-timestampedPoint.timestamp>indexLegacy.secondsToMilliseconds(timeDelta))break;i--}if(!timestampedPoint)return{x:0,y:0};history=indexLegacy.millisecondsToSeconds(lastPoint.timestamp-timestampedPoint.timestamp);if(0===history)return{x:0,y:0};timestampedPoint={x:(lastPoint.x-timestampedPoint.x)/history,y:(lastPoint.y-timestampedPoint.y)/history};Infinity===timestampedPoint.x&&
(timestampedPoint.x=0);Infinity===timestampedPoint.y&&(timestampedPoint.y=0);return timestampedPoint}function calcLength(axis){return axis.max-axis.min}function isNear(value,target=0,maxDistance=.01){return Math.abs(value-target)<=maxDistance}function calcAxisDelta(delta,source,target,origin=.5){delta.origin=origin;delta.originPoint=indexLegacy.mix(source.min,source.max,delta.origin);delta.scale=calcLength(target)/calcLength(source);if(isNear(delta.scale,1,1E-4)||isNaN(delta.scale))delta.scale=1;
delta.translate=indexLegacy.mix(target.min,target.max,delta.origin)-delta.originPoint;if(isNear(delta.translate)||isNaN(delta.translate))delta.translate=0}function calcBoxDelta(delta,source,target,origin){calcAxisDelta(delta.x,source.x,target.x,origin?origin.originX:void 0);calcAxisDelta(delta.y,source.y,target.y,origin?origin.originY:void 0)}function calcRelativePosition(target$jscomp$0,layout$jscomp$0,parent){var target=target$jscomp$0.x,layout=layout$jscomp$0.x;target.min=layout.min-parent.x.min;
target.max=target.min+calcLength(layout);target$jscomp$0=target$jscomp$0.y;layout$jscomp$0=layout$jscomp$0.y;target$jscomp$0.min=layout$jscomp$0.min-parent.y.min;target$jscomp$0.max=target$jscomp$0.min+calcLength(layout$jscomp$0)}function applyConstraints(point,{min,max},elastic){void 0!==min&&point<min?point=elastic?indexLegacy.mix(min,point,elastic.min):Math.max(point,min):void 0!==max&&point>max&&(point=elastic?indexLegacy.mix(max,point,elastic.max):Math.min(point,max));return point}function calcRelativeAxisConstraints(axis,
min,max){return{min:void 0!==min?axis.min+min:void 0,max:void 0!==max?axis.max+max-(axis.max-axis.min):void 0}}function calcRelativeConstraints(layoutBox,{top,left,bottom,right}){return{x:calcRelativeAxisConstraints(layoutBox.x,left,right),y:calcRelativeAxisConstraints(layoutBox.y,top,bottom)}}function calcViewportAxisConstraints(layoutAxis,constraintsAxis){let min=constraintsAxis.min-layoutAxis.min,max=constraintsAxis.max-layoutAxis.max;constraintsAxis.max-constraintsAxis.min<layoutAxis.max-layoutAxis.min&&
([min,max]=[max,min]);return{min,max}}function resolveDragElastic(dragElastic=.35){!1===dragElastic?dragElastic=0:!0===dragElastic&&(dragElastic=.35);var JSCompiler_inline_result=dragElastic;JSCompiler_inline_result={min:resolvePointElastic(JSCompiler_inline_result,"left"),max:resolvePointElastic(JSCompiler_inline_result,"right")};dragElastic={min:resolvePointElastic(dragElastic,"top"),max:resolvePointElastic(dragElastic,"bottom")};return{x:JSCompiler_inline_result,y:dragElastic}}function resolvePointElastic(dragElastic,
label){return"number"===typeof dragElastic?dragElastic:dragElastic[label]||0}function eachAxis(callback){return[callback("x"),callback("y")]}function shouldDrag(direction,drag,currentDirection){return(!0===drag||drag===direction)&&(null===currentDirection||currentDirection===direction)}function getCurrentDirection(offset,lockThreshold=10){let direction=null;Math.abs(offset.y)>lockThreshold?direction="y":Math.abs(offset.x)>lockThreshold&&(direction="x");return direction}function compress(min,max,easing){return p=>
p<min?0:p>max?1:easing(indexLegacy.progress(min,max,p))}function copyBoxInto(box,originBox){var axis=box.x,originAxis=originBox.x;axis.min=originAxis.min;axis.max=originAxis.max;box=box.y;originBox=originBox.y;box.min=originBox.min;box.max=originBox.max}function removePointDelta(point,translate,scale,originPoint,boxScale){point=indexLegacy.scalePoint(point-translate,1/scale,originPoint);void 0!==boxScale&&(point=indexLegacy.scalePoint(point,1/boxScale,originPoint));return point}function removeAxisDelta(axis,
translate=0,scale=1,origin=.5,boxScale,originAxis=axis,sourceAxis=axis){indexLegacy.percent.test(translate)&&(translate=parseFloat(translate),translate=indexLegacy.mix(sourceAxis.min,sourceAxis.max,translate/100)-sourceAxis.min);"number"===typeof translate&&(origin=indexLegacy.mix(originAxis.min,originAxis.max,origin),axis===originAxis&&(origin-=translate),axis.min=removePointDelta(axis.min,translate,scale,origin,boxScale),axis.max=removePointDelta(axis.max,translate,scale,origin,boxScale))}function removeAxisTransforms(axis,
transforms,[key,scaleKey,originKey],origin,sourceAxis){removeAxisDelta(axis,transforms[key],transforms[scaleKey],transforms[originKey],transforms.scale,origin,sourceAxis)}function removeBoxTransforms(box,transforms,originBox,sourceBox){removeAxisTransforms(box.x,transforms,xKeys,originBox?originBox.x:void 0,sourceBox?sourceBox.x:void 0);removeAxisTransforms(box.y,transforms,yKeys,originBox?originBox.y:void 0,sourceBox?sourceBox.y:void 0)}function isAxisDeltaZero(delta){return 0===delta.translate&&
1===delta.scale}function isDeltaZero(delta){return isAxisDeltaZero(delta.x)&&isAxisDeltaZero(delta.y)}function boxEqualsRounded(a,b){return Math.round(a.x.min)===Math.round(b.x.min)&&Math.round(a.x.max)===Math.round(b.x.max)&&Math.round(a.y.min)===Math.round(b.y.min)&&Math.round(a.y.max)===Math.round(b.y.max)}function aspectRatio(box){return calcLength(box.x)/calcLength(box.y)}function buildProjectionTransform(delta,treeScale,latestTransform){let transform="";const xTranslate=delta.x.translate/treeScale.x,
yTranslate=delta.y.translate/treeScale.y;if(xTranslate||yTranslate)transform=`translate3d(${xTranslate}px, ${yTranslate}px, 0) `;if(1!==treeScale.x||1!==treeScale.y)transform+=`scale(${1/treeScale.x}, ${1/treeScale.y}) `;if(latestTransform){const {rotate,rotateX,rotateY}=latestTransform;rotate&&(transform+=`rotate(${rotate}deg) `);rotateX&&(transform+=`rotateX(${rotateX}deg) `);rotateY&&(transform+=`rotateY(${rotateY}deg) `)}latestTransform=delta.x.scale*treeScale.x;delta=delta.y.scale*treeScale.y;
if(1!==latestTransform||1!==delta)transform+=`scale(${latestTransform}, ${delta})`;return transform||"none"}function createProjectionNode({attachResizeListener,defaultParent,measureScroll,checkIsScrollRoot,resetTransform}){return class{constructor(latestValues={},parent=null===defaultParent||void 0===defaultParent?void 0:defaultParent()){this.id=id$1++;this.animationId=0;this.children=new Set;this.options={};this.shouldResetTransform=this.needsReset=this.isSVG=this.isUpdating=this.updateBlockedByResize=
this.updateManuallyBlocked=this.isTransformDirty=this.isSharedProjectionDirty=this.isProjectionDirty=this.isLayoutDirty=this.isAnimationBlocked=this.isTreeAnimating=!1;this.treeScale={x:1,y:1};this.eventHandlers=new Map;this.projectionUpdateScheduled=this.updateScheduled=this.hasTreeAnimated=!1;this.checkUpdateFailed=()=>{this.isUpdating&&(this.isUpdating=!1,this.clearAllSnapshots())};this.updateProjection=()=>{this.projectionUpdateScheduled=!1;projectionFrameData.totalNodes=projectionFrameData.resolvedTargetDeltas=
projectionFrameData.recalculatedProjection=0;this.nodes.forEach(propagateDirtyNodes);this.nodes.forEach(resolveTargetDelta);this.nodes.forEach(calcProjection);this.nodes.forEach(cleanDirtyNodes);window.MotionDebug&&window.MotionDebug.record(projectionFrameData)};this.hasProjected=!1;this.isVisible=!0;this.animationProgress=0;this.sharedNodes=new Map;this.latestValues=latestValues;this.root=parent?parent.root||parent:this;this.path=parent?[...parent.path,parent]:[];this.depth=(this.parent=parent)?
parent.depth+1:0;for(latestValues=0;latestValues<this.path.length;latestValues++)this.path[latestValues].shouldResetTransform=!0;this.root===this&&(this.nodes=new FlatTree)}addEventListener(name,handler){this.eventHandlers.has(name)||this.eventHandlers.set(name,new indexLegacy.SubscriptionManager);return this.eventHandlers.get(name).add(handler)}notifyListeners(name,...args){(name=this.eventHandlers.get(name))&&name.notify(...args)}hasListeners(name){return this.eventHandlers.has(name)}mount(instance,
isLayoutDirty=this.root.hasTreeAnimated){if(!this.instance){this.isSVG=indexLegacy.isSVGElement(instance);this.instance=instance;var {layoutId,layout,visualElement}=this.options;visualElement&&!visualElement.current&&visualElement.mount(instance);this.root.nodes.add(this);this.parent&&this.parent.children.add(this);isLayoutDirty&&(layout||layoutId)&&(this.isLayoutDirty=!0);if(attachResizeListener){let cancelDelay;const resizeUnblockUpdate=()=>this.root.updateBlockedByResize=!1;attachResizeListener(instance,
()=>{this.root.updateBlockedByResize=!0;cancelDelay&&cancelDelay();cancelDelay=indexLegacy.delay(resizeUnblockUpdate,250);globalProjectionState.hasAnimatedSinceResize&&(globalProjectionState.hasAnimatedSinceResize=!1,this.nodes.forEach(finishAnimation))})}layoutId&&this.root.registerSharedNode(layoutId,this);!1!==this.options.animate&&visualElement&&(layoutId||layout)&&this.addEventListener("didUpdate",({delta,hasLayoutChanged,hasRelativeTargetChanged,layout:newLayout})=>{if(this.isTreeAnimationBlocked())this.relativeTarget=
this.target=void 0;else{var layoutTransition=this.options.transition||visualElement.getDefaultTransition()||defaultLayoutTransition,{onLayoutAnimationStart,onLayoutAnimationComplete}=visualElement.getProps(),targetChanged=!this.targetLayout||!boxEqualsRounded(this.targetLayout,newLayout)||hasRelativeTargetChanged;hasRelativeTargetChanged=!hasLayoutChanged&&hasRelativeTargetChanged;if(this.options.layoutRoot||this.resumeFrom&&this.resumeFrom.instance||hasRelativeTargetChanged||hasLayoutChanged&&(targetChanged||
!this.currentAnimation)){this.resumeFrom&&(this.resumingFrom=this.resumeFrom,this.resumingFrom.resumingFrom=void 0);this.setAnimationOrigin(delta,hasRelativeTargetChanged);delta={...indexLegacy.getValueTransition(layoutTransition,"layout"),onPlay:onLayoutAnimationStart,onComplete:onLayoutAnimationComplete};if(visualElement.shouldReduceMotion||this.options.layoutRoot)delta.delay=0,delta.type=!1;this.startAnimation(delta)}else if(hasLayoutChanged||finishAnimation(this),this.isLead()&&this.options.onExitComplete)this.options.onExitComplete();
this.targetLayout=newLayout}})}}unmount(){this.options.layoutId&&this.willUpdate();this.root.nodes.remove(this);const stack=this.getStack();stack&&stack.remove(this);this.parent&&this.parent.children.delete(this);this.instance=void 0;indexLegacy.cancelFrame(this.updateProjection)}blockUpdate(){this.updateManuallyBlocked=!0}unblockUpdate(){this.updateManuallyBlocked=!1}isUpdateBlocked(){return this.updateManuallyBlocked||this.updateBlockedByResize}isTreeAnimationBlocked(){return this.isAnimationBlocked||
this.parent&&this.parent.isTreeAnimationBlocked()||!1}startUpdate(){this.isUpdateBlocked()||(this.isUpdating=!0,this.nodes&&this.nodes.forEach(resetRotation),this.animationId++)}getTransformTemplate(){const {visualElement}=this.options;return visualElement&&visualElement.getProps().transformTemplate}willUpdate(shouldNotifyListeners=!0){this.root.hasTreeAnimated=!0;if(this.root.isUpdateBlocked())this.options.onExitComplete&&this.options.onExitComplete();else if(!this.root.isUpdating&&this.root.startUpdate(),
!this.isLayoutDirty){this.isLayoutDirty=!0;for(var i=0;i<this.path.length;i++){const node=this.path[i];node.shouldResetTransform=!0;node.updateScroll("snapshot");node.options.layoutRoot&&node.willUpdate(!1)}var {layoutId,layout}=this.options;if(void 0!==layoutId||layout)this.prevTransformTemplateValue=(i=this.getTransformTemplate())?i(this.latestValues,""):void 0,this.updateSnapshot(),shouldNotifyListeners&&this.notifyListeners("willUpdate")}}update(){this.updateScheduled=!1;if(this.isUpdateBlocked())this.unblockUpdate(),
this.clearAllSnapshots(),this.nodes.forEach(clearMeasurements);else{this.isUpdating||this.nodes.forEach(clearIsLayoutDirty);this.isUpdating=!1;this.nodes.forEach(resetTransformStyle);this.nodes.forEach(updateLayout);this.nodes.forEach(notifyLayoutUpdate);this.clearAllSnapshots();var now=performance.now();indexLegacy.frameData.delta=indexLegacy.clamp(0,1E3/60,now-indexLegacy.frameData.timestamp);indexLegacy.frameData.timestamp=now;indexLegacy.frameData.isProcessing=!0;indexLegacy.steps.update.process(indexLegacy.frameData);
indexLegacy.steps.preRender.process(indexLegacy.frameData);indexLegacy.steps.render.process(indexLegacy.frameData);indexLegacy.frameData.isProcessing=!1}}didUpdate(){this.updateScheduled||(this.updateScheduled=!0,queueMicrotask(()=>this.update()))}clearAllSnapshots(){this.nodes.forEach(clearSnapshot);this.sharedNodes.forEach(removeLeadSnapshots)}scheduleUpdateProjection(){this.projectionUpdateScheduled||(this.projectionUpdateScheduled=!0,indexLegacy.frame.preRender(this.updateProjection,!1,!0))}scheduleCheckAfterUnmount(){indexLegacy.frame.postRender(()=>
{this.isLayoutDirty?this.root.didUpdate():this.root.checkUpdateFailed()})}updateSnapshot(){!this.snapshot&&this.instance&&(this.snapshot=this.measure())}updateLayout(){if(this.instance&&(this.updateScroll(),this.options.alwaysMeasureLayout&&this.isLead()||this.isLayoutDirty)){if(this.resumeFrom&&!this.resumeFrom.instance)for(var i=0;i<this.path.length;i++)this.path[i].updateScroll();i=this.layout;this.layout=this.measure(!1);this.layoutCorrected=indexLegacy.createBox();this.isLayoutDirty=!1;this.projectionDelta=
void 0;this.notifyListeners("measure",this.layout.layoutBox);var {visualElement}=this.options;visualElement&&visualElement.notify("LayoutMeasure",this.layout.layoutBox,i?i.layoutBox:void 0)}}updateScroll(phase="measure"){let needsMeasurement=!(!this.options.layoutScroll||!this.instance);this.scroll&&this.scroll.animationId===this.root.animationId&&this.scroll.phase===phase&&(needsMeasurement=!1);needsMeasurement&&(this.scroll={animationId:this.root.animationId,phase,isRoot:checkIsScrollRoot(this.instance),
offset:measureScroll(this.instance)})}resetTransform(){if(resetTransform){var isResetRequested=this.isLayoutDirty||this.shouldResetTransform,hasProjection=this.projectionDelta&&!isDeltaZero(this.projectionDelta),transformTemplate=this.getTransformTemplate();transformTemplate=transformTemplate?transformTemplate(this.latestValues,""):void 0;var transformTemplateHasChanged=transformTemplate!==this.prevTransformTemplateValue;isResetRequested&&(hasProjection||indexLegacy.hasTransform(this.latestValues)||
transformTemplateHasChanged)&&(resetTransform(this.instance,transformTemplate),this.shouldResetTransform=!1,this.scheduleRender())}}measure(removeTransform=!0){const pageBox=this.measurePageBox();let layoutBox=this.removeElementScroll(pageBox);removeTransform&&(layoutBox=this.removeTransform(layoutBox));removeTransform=layoutBox;roundAxis(removeTransform.x);roundAxis(removeTransform.y);return{animationId:this.root.animationId,measuredBox:pageBox,layoutBox,latestValues:{},source:this.id}}measurePageBox(){var {visualElement}=
this.options;if(!visualElement)return indexLegacy.createBox();visualElement=visualElement.measureViewportBox();const {scroll}=this.root;scroll&&(indexLegacy.translateAxis(visualElement.x,scroll.offset.x),indexLegacy.translateAxis(visualElement.y,scroll.offset.y));return visualElement}removeElementScroll(box){const boxWithoutScroll=indexLegacy.createBox();copyBoxInto(boxWithoutScroll,box);for(let i=0;i<this.path.length;i++){var node=this.path[i];const {scroll,options}=node;node!==this.root&&scroll&&
options.layoutScroll&&(scroll.isRoot&&(copyBoxInto(boxWithoutScroll,box),{scroll:node}=this.root,node&&(indexLegacy.translateAxis(boxWithoutScroll.x,-node.offset.x),indexLegacy.translateAxis(boxWithoutScroll.y,-node.offset.y))),indexLegacy.translateAxis(boxWithoutScroll.x,scroll.offset.x),indexLegacy.translateAxis(boxWithoutScroll.y,scroll.offset.y))}return boxWithoutScroll}applyTransform(box,transformOnly=!1){const withTransforms=indexLegacy.createBox();copyBoxInto(withTransforms,box);for(box=0;box<
this.path.length;box++){const node=this.path[box];!transformOnly&&node.options.layoutScroll&&node.scroll&&node!==node.root&&indexLegacy.transformBox(withTransforms,{x:-node.scroll.offset.x,y:-node.scroll.offset.y});indexLegacy.hasTransform(node.latestValues)&&indexLegacy.transformBox(withTransforms,node.latestValues)}indexLegacy.hasTransform(this.latestValues)&&indexLegacy.transformBox(withTransforms,this.latestValues);return withTransforms}removeTransform(box){const boxWithoutTransform=indexLegacy.createBox();
copyBoxInto(boxWithoutTransform,box);for(box=0;box<this.path.length;box++){const node=this.path[box];if(!node.instance)continue;if(!indexLegacy.hasTransform(node.latestValues))continue;indexLegacy.hasScale(node.latestValues)&&node.updateSnapshot();const sourceBox=indexLegacy.createBox(),nodeBox=node.measurePageBox();copyBoxInto(sourceBox,nodeBox);removeBoxTransforms(boxWithoutTransform,node.latestValues,node.snapshot?node.snapshot.layoutBox:void 0,sourceBox)}indexLegacy.hasTransform(this.latestValues)&&
removeBoxTransforms(boxWithoutTransform,this.latestValues);return boxWithoutTransform}setTargetDelta(delta){this.targetDelta=delta;this.root.scheduleUpdateProjection();this.isProjectionDirty=!0}setOptions(options){this.options={...this.options,...options,crossfade:void 0!==options.crossfade?options.crossfade:!0}}clearMeasurements(){this.target=this.targetDelta=this.prevTransformTemplateValue=this.snapshot=this.layout=this.scroll=void 0;this.isLayoutDirty=!1}forceRelativeParentToResolveTarget(){this.relativeParent&&
this.relativeParent.resolvedRelativeTargetAt!==indexLegacy.frameData.timestamp&&this.relativeParent.resolveTargetDelta(!0)}resolveTargetDelta(forceRecalculation=!1){var _a,lead=this.getLead();this.isProjectionDirty||(this.isProjectionDirty=lead.isProjectionDirty);this.isTransformDirty||(this.isTransformDirty=lead.isTransformDirty);this.isSharedProjectionDirty||(this.isSharedProjectionDirty=lead.isSharedProjectionDirty);lead=!!this.resumingFrom||this!==lead;if(forceRecalculation||lead&&this.isSharedProjectionDirty||
this.isProjectionDirty||(null===(_a=this.parent)||void 0===_a?0:_a.isProjectionDirty)||this.attemptToResolveRelativeTarget){var {layout,layoutId}=this.options;if(this.layout&&(layout||layoutId)&&(this.resolvedRelativeTargetAt=indexLegacy.frameData.timestamp,this.targetDelta||this.relativeTarget||((forceRecalculation=this.getClosestProjectingParent())&&forceRecalculation.layout&&1!==this.animationProgress?(this.relativeParent=forceRecalculation,this.forceRelativeParentToResolveTarget(),this.relativeTarget=
indexLegacy.createBox(),this.relativeTargetOrigin=indexLegacy.createBox(),calcRelativePosition(this.relativeTargetOrigin,this.layout.layoutBox,forceRecalculation.layout.layoutBox),copyBoxInto(this.relativeTarget,this.relativeTargetOrigin)):this.relativeParent=this.relativeTarget=void 0),this.relativeTarget||this.targetDelta)){this.target||(this.target=indexLegacy.createBox(),this.targetWithTransforms=indexLegacy.createBox());if(this.relativeTarget&&this.relativeTargetOrigin&&this.relativeParent&&
this.relativeParent.target){this.forceRelativeParentToResolveTarget();lead=this.target;_a=this.relativeTarget;forceRecalculation=this.relativeParent.target;var target=lead.x,relative=_a.x;target.min=forceRecalculation.x.min+relative.min;target.max=target.min+calcLength(relative);lead=lead.y;_a=_a.y;lead.min=forceRecalculation.y.min+_a.min;lead.max=lead.min+calcLength(_a)}else this.targetDelta?(this.resumingFrom?this.target=this.applyTransform(this.layout.layoutBox):copyBoxInto(this.target,this.layout.layoutBox),
indexLegacy.applyBoxDelta(this.target,this.targetDelta)):copyBoxInto(this.target,this.layout.layoutBox);this.attemptToResolveRelativeTarget&&(this.attemptToResolveRelativeTarget=!1,(forceRecalculation=this.getClosestProjectingParent())&&!!forceRecalculation.resumingFrom===!!this.resumingFrom&&!forceRecalculation.options.layoutScroll&&forceRecalculation.target&&1!==this.animationProgress?(this.relativeParent=forceRecalculation,this.forceRelativeParentToResolveTarget(),this.relativeTarget=indexLegacy.createBox(),
this.relativeTargetOrigin=indexLegacy.createBox(),calcRelativePosition(this.relativeTargetOrigin,this.target,forceRecalculation.target),copyBoxInto(this.relativeTarget,this.relativeTargetOrigin)):this.relativeParent=this.relativeTarget=void 0);projectionFrameData.resolvedTargetDeltas++}}}getClosestProjectingParent(){if(this.parent&&!indexLegacy.hasScale(this.parent.latestValues)&&!indexLegacy.has2DTranslate(this.parent.latestValues))return this.parent.isProjecting()?this.parent:this.parent.getClosestProjectingParent()}isProjecting(){return!(!(this.relativeTarget||
this.targetDelta||this.options.layoutRoot)||!this.layout)}calcProjection(){var _a,lead=this.getLead(),isShared=!!this.resumingFrom||this!==lead,canSkip=!0;if(this.isProjectionDirty||(null===(_a=this.parent)||void 0===_a?0:_a.isProjectionDirty))canSkip=!1;isShared&&(this.isSharedProjectionDirty||this.isTransformDirty)&&(canSkip=!1);this.resolvedRelativeTargetAt===indexLegacy.frameData.timestamp&&(canSkip=!1);if(!canSkip){var {layout,layoutId}=this.options;this.isTreeAnimating=!!(this.parent&&this.parent.isTreeAnimating||
this.currentAnimation||this.pendingAnimation);this.isTreeAnimating||(this.targetDelta=this.relativeTarget=void 0);if(this.layout&&(layout||layoutId))if(copyBoxInto(this.layoutCorrected,this.layout.layoutBox),_a=this.treeScale.x,canSkip=this.treeScale.y,indexLegacy.applyTreeDeltas(this.layoutCorrected,this.treeScale,this.path,isShared),!lead.layout||lead.target||1===this.treeScale.x&&1===this.treeScale.y||(lead.target=lead.layout.layoutBox),{target:lead}=lead,lead){this.projectionDelta||(this.projectionDelta=
indexLegacy.createDelta(),this.projectionDeltaWithTransform=indexLegacy.createDelta());isShared=this.projectionTransform;calcBoxDelta(this.projectionDelta,this.layoutCorrected,lead,this.latestValues);this.projectionTransform=buildProjectionTransform(this.projectionDelta,this.treeScale);if(this.projectionTransform!==isShared||this.treeScale.x!==_a||this.treeScale.y!==canSkip)this.hasProjected=!0,this.scheduleRender(),this.notifyListeners("projectionUpdate",lead);projectionFrameData.recalculatedProjection++}else this.projectionTransform&&
(this.projectionDelta=indexLegacy.createDelta(),this.projectionTransform="none",this.scheduleRender())}}hide(){this.isVisible=!1}show(){this.isVisible=!0}scheduleRender(notifyAll=!0){this.options.scheduleRender&&this.options.scheduleRender();notifyAll&&(notifyAll=this.getStack())&&notifyAll.scheduleRender();this.resumingFrom&&!this.resumingFrom.instance&&(this.resumingFrom=void 0)}setAnimationOrigin(delta,hasOnlyRelativeTargetChanged=!1){const snapshot=this.snapshot,snapshotLatestValues=snapshot?
snapshot.latestValues:{},mixedValues={...this.latestValues},targetDelta=indexLegacy.createDelta();this.relativeParent&&this.relativeParent.options.layoutRoot||(this.relativeTarget=this.relativeTargetOrigin=void 0);this.attemptToResolveRelativeTarget=!hasOnlyRelativeTargetChanged;const relativeLayout=indexLegacy.createBox(),isSharedLayoutAnimation=(snapshot?snapshot.source:void 0)!==(this.layout?this.layout.source:void 0);hasOnlyRelativeTargetChanged=this.getStack();const isOnlyMember=!hasOnlyRelativeTargetChanged||
1>=hasOnlyRelativeTargetChanged.members.length,shouldCrossfadeOpacity=!(!isSharedLayoutAnimation||isOnlyMember||!0!==this.options.crossfade||this.path.some(hasOpacityCrossfade));this.animationProgress=0;let prevRelativeTarget;this.mixTargetDelta=latest=>{latest/=1E3;mixAxisDelta(targetDelta.x,delta.x,latest);mixAxisDelta(targetDelta.y,delta.y,latest);this.setTargetDelta(targetDelta);if(this.relativeTarget&&this.relativeTargetOrigin&&this.layout&&this.relativeParent&&this.relativeParent.layout){calcRelativePosition(relativeLayout,
this.layout.layoutBox,this.relativeParent.layout.layoutBox);var output=this.relativeTarget,from=this.relativeTargetOrigin,output$jscomp$0=output.x,from$jscomp$0=from.x,to=relativeLayout.x;output$jscomp$0.min=indexLegacy.mix(from$jscomp$0.min,to.min,latest);output$jscomp$0.max=indexLegacy.mix(from$jscomp$0.max,to.max,latest);output=output.y;from=from.y;output$jscomp$0=relativeLayout.y;output.min=indexLegacy.mix(from.min,output$jscomp$0.min,latest);output.max=indexLegacy.mix(from.max,output$jscomp$0.max,
latest);if(from=prevRelativeTarget)from=this.relativeTarget,from=from.x.min===prevRelativeTarget.x.min&&from.x.max===prevRelativeTarget.x.max&&from.y.min===prevRelativeTarget.y.min&&from.y.max===prevRelativeTarget.y.max;from&&(this.isProjectionDirty=!1);prevRelativeTarget||(prevRelativeTarget=indexLegacy.createBox());copyBoxInto(prevRelativeTarget,this.relativeTarget)}if(isSharedLayoutAnimation){this.animationValues=mixedValues;from=this.latestValues;shouldCrossfadeOpacity?(mixedValues.opacity=indexLegacy.mix(0,
void 0!==from.opacity?from.opacity:1,easeCrossfadeIn(latest)),mixedValues.opacityExit=indexLegacy.mix(void 0!==snapshotLatestValues.opacity?snapshotLatestValues.opacity:1,0,easeCrossfadeOut(latest))):isOnlyMember&&(mixedValues.opacity=indexLegacy.mix(void 0!==snapshotLatestValues.opacity?snapshotLatestValues.opacity:1,void 0!==from.opacity?from.opacity:1,latest));for(output=0;output<numBorders;output++)if(output$jscomp$0=`border${borders[output]}Radius`,from$jscomp$0=void 0!==snapshotLatestValues[output$jscomp$0]?
snapshotLatestValues[output$jscomp$0]:snapshotLatestValues.borderRadius,to=void 0!==from[output$jscomp$0]?from[output$jscomp$0]:from.borderRadius,void 0!==from$jscomp$0||void 0!==to)if(from$jscomp$0||(from$jscomp$0=0),to||(to=0),0===from$jscomp$0||0===to||("number"===typeof from$jscomp$0||indexLegacy.px.test(from$jscomp$0))===("number"===typeof to||indexLegacy.px.test(to))){if(mixedValues[output$jscomp$0]=Math.max(indexLegacy.mix(asNumber(from$jscomp$0),asNumber(to),latest),0),indexLegacy.percent.test(to)||
indexLegacy.percent.test(from$jscomp$0))mixedValues[output$jscomp$0]+="%"}else mixedValues[output$jscomp$0]=to;if(snapshotLatestValues.rotate||from.rotate)mixedValues.rotate=indexLegacy.mix(snapshotLatestValues.rotate||0,from.rotate||0,latest)}this.root.scheduleUpdateProjection();this.scheduleRender();this.animationProgress=latest};this.mixTargetDelta(this.options.layoutRoot?1E3:0)}startAnimation(options){this.notifyListeners("animationStart");this.currentAnimation&&this.currentAnimation.stop();this.resumingFrom&&
this.resumingFrom.currentAnimation&&this.resumingFrom.currentAnimation.stop();this.pendingAnimation&&(indexLegacy.cancelFrame(this.pendingAnimation),this.pendingAnimation=void 0);this.pendingAnimation=indexLegacy.frame.update(()=>{globalProjectionState.hasAnimatedSinceResize=!0;this.currentAnimation=indexLegacy.animateSingleValue(0,1E3,{...options,onUpdate:latest=>{this.mixTargetDelta(latest);options.onUpdate&&options.onUpdate(latest)},onComplete:()=>{options.onComplete&&options.onComplete();this.completeAnimation()}});
this.resumingFrom&&(this.resumingFrom.currentAnimation=this.currentAnimation);this.pendingAnimation=void 0})}completeAnimation(){this.resumingFrom&&(this.resumingFrom.currentAnimation=void 0,this.resumingFrom.preserveOpacity=void 0);const stack=this.getStack();stack&&stack.exitAnimationComplete();this.resumingFrom=this.currentAnimation=this.animationValues=void 0;this.notifyListeners("animationComplete")}finishAnimation(){this.currentAnimation&&(this.mixTargetDelta&&this.mixTargetDelta(1E3),this.currentAnimation.stop());
this.completeAnimation()}applyTransformsToTarget(){const lead=this.getLead();let {targetWithTransforms,target,layout,latestValues}=lead;if(targetWithTransforms&&target&&layout){if(this!==lead&&this.layout&&layout&&shouldAnimatePositionOnly(this.options.animationType,this.layout.layoutBox,layout.layoutBox)){target=this.target||indexLegacy.createBox();var xLength=calcLength(this.layout.layoutBox.x);target.x.min=lead.target.x.min;target.x.max=target.x.min+xLength;xLength=calcLength(this.layout.layoutBox.y);
target.y.min=lead.target.y.min;target.y.max=target.y.min+xLength}copyBoxInto(targetWithTransforms,target);indexLegacy.transformBox(targetWithTransforms,latestValues);calcBoxDelta(this.projectionDeltaWithTransform,this.layoutCorrected,targetWithTransforms,latestValues)}}registerSharedNode(layoutId,node){this.sharedNodes.has(layoutId)||this.sharedNodes.set(layoutId,new NodeStack);this.sharedNodes.get(layoutId).add(node);layoutId=node.options.initialPromotionConfig;node.promote({transition:layoutId?
layoutId.transition:void 0,preserveFollowOpacity:layoutId&&layoutId.shouldPreserveFollowOpacity?layoutId.shouldPreserveFollowOpacity(node):void 0})}isLead(){const stack=this.getStack();return stack?stack.lead===this:!0}getLead(){var _a;const {layoutId}=this.options;return layoutId?(null===(_a=this.getStack())||void 0===_a?void 0:_a.lead)||this:this}getPrevLead(){var _a;const {layoutId}=this.options;return layoutId?null===(_a=this.getStack())||void 0===_a?void 0:_a.prevLead:void 0}getStack(){const {layoutId}=
this.options;if(layoutId)return this.root.sharedNodes.get(layoutId)}promote({needsReset,transition,preserveFollowOpacity}={}){const stack=this.getStack();stack&&stack.promote(this,preserveFollowOpacity);needsReset&&(this.projectionDelta=void 0,this.needsReset=!0);transition&&this.setOptions({transition})}relegate(){const stack=this.getStack();return stack?stack.relegate(this):!1}resetRotation(){const {visualElement}=this.options;if(visualElement){var hasRotate=!1,{latestValues}=visualElement;if(latestValues.rotate||
latestValues.rotateX||latestValues.rotateY||latestValues.rotateZ)hasRotate=!0;if(hasRotate){hasRotate={};for(let i=0;i<transformAxes.length;i++){const key="rotate"+transformAxes[i];latestValues[key]&&(hasRotate[key]=latestValues[key],visualElement.setStaticValue(key,0))}visualElement.render();for(const key in hasRotate)visualElement.setStaticValue(key,hasRotate[key]);visualElement.scheduleRender()}}}getProjectionStyles(styleProp){var _a,_b;if(this.instance&&!this.isSVG){if(!this.isVisible)return hiddenVisibility;
var styles={visibility:""},transformTemplate=this.getTransformTemplate();if(this.needsReset)return this.needsReset=!1,styles.opacity="",styles.pointerEvents=resolveMotionValue(null===styleProp||void 0===styleProp?void 0:styleProp.pointerEvents)||"",styles.transform=transformTemplate?transformTemplate(this.latestValues,""):"none",styles;var lead=this.getLead();if(!this.projectionDelta||!this.layout||!lead.target)return styles={},this.options.layoutId&&(styles.opacity=void 0!==this.latestValues.opacity?
this.latestValues.opacity:1,styles.pointerEvents=resolveMotionValue(null===styleProp||void 0===styleProp?void 0:styleProp.pointerEvents)||""),this.hasProjected&&!indexLegacy.hasTransform(this.latestValues)&&(styles.transform=transformTemplate?transformTemplate({},""):"none",this.hasProjected=!1),styles;var valuesToRender=lead.animationValues||lead.latestValues;this.applyTransformsToTarget();styles.transform=buildProjectionTransform(this.projectionDeltaWithTransform,this.treeScale,valuesToRender);
transformTemplate&&(styles.transform=transformTemplate(valuesToRender,styles.transform));var {x,y}=this.projectionDelta;styles.transformOrigin=`${100*x.origin}% ${100*y.origin}% 0`;styles.opacity=lead.animationValues?lead===this?null!==(_b=null!==(_a=valuesToRender.opacity)&&void 0!==_a?_a:this.latestValues.opacity)&&void 0!==_b?_b:1:this.preserveOpacity?this.latestValues.opacity:valuesToRender.opacityExit:lead===this?void 0!==valuesToRender.opacity?valuesToRender.opacity:"":void 0!==valuesToRender.opacityExit?
valuesToRender.opacityExit:0;for(const key in indexLegacy.scaleCorrectors){if(void 0===valuesToRender[key])continue;const {correct,applyTo}=indexLegacy.scaleCorrectors[key];transformTemplate="none"===styles.transform?valuesToRender[key]:correct(valuesToRender[key],lead);if(applyTo)for(_a=applyTo.length,_b=0;_b<_a;_b++)styles[applyTo[_b]]=transformTemplate;else styles[key]=transformTemplate}this.options.layoutId&&(styles.pointerEvents=lead===this?resolveMotionValue(null===styleProp||void 0===styleProp?
void 0:styleProp.pointerEvents)||"":"none");return styles}}clearSnapshot(){this.resumeFrom=this.snapshot=void 0}resetTree(){this.root.nodes.forEach(node=>{var _a;return null===(_a=node.currentAnimation)||void 0===_a?void 0:_a.stop()});this.root.nodes.forEach(clearMeasurements);this.root.sharedNodes.clear()}}}function updateLayout(node){node.updateLayout()}function notifyLayoutUpdate(node){var _a;const snapshot=(null===(_a=node.resumeFrom)||void 0===_a?void 0:_a.snapshot)||node.snapshot;if(node.isLead()&&
node.layout&&snapshot&&node.hasListeners("didUpdate")){const {layoutBox:layout,measuredBox:measuredLayout}=node.layout;({animationType:_a}=node.options);const isShared=snapshot.source!==node.layout.source;"size"===_a?eachAxis(axis=>{const axisSnapshot=isShared?snapshot.measuredBox[axis]:snapshot.layoutBox[axis],length=calcLength(axisSnapshot);axisSnapshot.min=layout[axis].min;axisSnapshot.max=axisSnapshot.min+length}):shouldAnimatePositionOnly(_a,snapshot.layoutBox,layout)&&eachAxis(axis=>{const axisSnapshot=
isShared?snapshot.measuredBox[axis]:snapshot.layoutBox[axis],length=calcLength(layout[axis]);axisSnapshot.max=axisSnapshot.min+length;node.relativeTarget&&!node.currentAnimation&&(node.isProjectionDirty=!0,node.relativeTarget[axis].max=node.relativeTarget[axis].min+length)});_a=indexLegacy.createDelta();calcBoxDelta(_a,layout,snapshot.layoutBox);const visualDelta=indexLegacy.createDelta();isShared?calcBoxDelta(visualDelta,node.applyTransform(measuredLayout,!0),snapshot.measuredBox):calcBoxDelta(visualDelta,
layout,snapshot.layoutBox);const hasLayoutChanged=!isDeltaZero(_a);let hasRelativeTargetChanged=!1;if(!node.resumeFrom){const relativeParent=node.getClosestProjectingParent();if(relativeParent&&!relativeParent.resumeFrom){const {snapshot:parentSnapshot,layout:parentLayout}=relativeParent;if(parentSnapshot&&parentLayout){const relativeSnapshot=indexLegacy.createBox();calcRelativePosition(relativeSnapshot,snapshot.layoutBox,parentSnapshot.layoutBox);const relativeLayout=indexLegacy.createBox();calcRelativePosition(relativeLayout,
layout,parentLayout.layoutBox);boxEqualsRounded(relativeSnapshot,relativeLayout)||(hasRelativeTargetChanged=!0);relativeParent.options.layoutRoot&&(node.relativeTarget=relativeLayout,node.relativeTargetOrigin=relativeSnapshot,node.relativeParent=relativeParent)}}}node.notifyListeners("didUpdate",{layout,snapshot,delta:visualDelta,layoutDelta:_a,hasLayoutChanged,hasRelativeTargetChanged})}else node.isLead()&&({onExitComplete:_a}=node.options,_a&&_a());node.options.transition=void 0}function propagateDirtyNodes(node){projectionFrameData.totalNodes++;
node.parent&&(node.isProjecting()||(node.isProjectionDirty=node.parent.isProjectionDirty),node.isSharedProjectionDirty||(node.isSharedProjectionDirty=!!(node.isProjectionDirty||node.parent.isProjectionDirty||node.parent.isSharedProjectionDirty)),node.isTransformDirty||(node.isTransformDirty=node.parent.isTransformDirty))}function cleanDirtyNodes(node){node.isProjectionDirty=node.isSharedProjectionDirty=node.isTransformDirty=!1}function clearSnapshot(node){node.clearSnapshot()}function clearMeasurements(node){node.clearMeasurements()}
function clearIsLayoutDirty(node){node.isLayoutDirty=!1}function resetTransformStyle(node){const {visualElement}=node.options;visualElement&&visualElement.getProps().onBeforeLayoutMeasure&&visualElement.notify("BeforeLayoutMeasure");node.resetTransform()}function finishAnimation(node){node.finishAnimation();node.targetDelta=node.relativeTarget=node.target=void 0;node.isProjectionDirty=!0}function resolveTargetDelta(node){node.resolveTargetDelta()}function calcProjection(node){node.calcProjection()}
function resetRotation(node){node.resetRotation()}function removeLeadSnapshots(stack){stack.removeLeadSnapshot()}function mixAxisDelta(output,delta,p){output.translate=indexLegacy.mix(delta.translate,0,p);output.scale=indexLegacy.mix(delta.scale,1,p);output.origin=delta.origin;output.originPoint=delta.originPoint}function hasOpacityCrossfade(node){return node.animationValues&&void 0!==node.animationValues.opacityExit}function roundAxis(axis){axis.min=roundPoint(axis.min);axis.max=roundPoint(axis.max)}
function shouldAnimatePositionOnly(animationType,snapshot,layout){return"position"===animationType||"preserve-aspect"===animationType&&!isNear(aspectRatio(snapshot),aspectRatio(layout),.2)}function nodeGroup(){const nodes=new Set,subscriptions=new WeakMap,dirtyAll=()=>nodes.forEach(notify);return{add:node=>{nodes.add(node);subscriptions.set(node,node.addEventListener("willUpdate",dirtyAll))},remove:node=>{nodes.delete(node);const unsubscribe=subscriptions.get(node);unsubscribe&&(unsubscribe(),subscriptions.delete(node));
nodes.forEach(notify)},dirty:dirtyAll}}function pixelsToPercent(pixels,axis){return axis.max===axis.min?0:pixels/(axis.max-axis.min)*100}function usePresence(){const context=React.useContext(PresenceContext);if(null===context)return[!0,null];const {isPresent,onExitComplete,register}=context,id=React.useId();React.useEffect(()=>register(id),[]);return!isPresent&&onExitComplete?[!1,()=>onExitComplete&&onExitComplete(id)]:[!0]}function MeasureLayout$jscomp$0(props){const [isPresent,safeToRemove]=usePresence(),
layoutGroup=React.useContext(LayoutGroupContext);return React__default["default"].createElement(MeasureLayoutWithContext,{...props,layoutGroup,switchLayoutGroup:React.useContext(SwitchLayoutGroupContext),isPresent,safeToRemove})}function useIsMounted(){const isMounted=React.useRef(!1);useIsomorphicLayoutEffect(()=>{isMounted.current=!0;return()=>{isMounted.current=!1}},[]);return isMounted}function useForceUpdate(){const isMounted=useIsMounted(),[forcedRenderCount,setForcedRenderCount]=React.useState(0),
forceRender=React.useCallback(()=>{isMounted.current&&setForcedRenderCount(forcedRenderCount+1)},[forcedRenderCount]);return[React.useCallback(()=>indexLegacy.frame.postRender(forceRender),[forceRender]),forcedRenderCount]}function PopChild({children,isPresent}){const id=React.useId(),ref=React.useRef(null),size=React.useRef({width:0,height:0,top:0,left:0});React.useInsertionEffect(()=>{const {width,height,top,left}=size.current;if(!isPresent&&ref.current&&width&&height){ref.current.dataset.motionPopId=
id;var style=document.createElement("style");document.head.appendChild(style);style.sheet&&style.sheet.insertRule(`
          [data-motion-pop-id="${id}"] {
            position: absolute !important;
            width: ${width}px !important;
            height: ${height}px !important;
            top: ${top}px !important;
            left: ${left}px !important;
          }
        `);return()=>{document.head.removeChild(style)}}},[isPresent]);return React__namespace.createElement(PopChildMeasure,{isPresent,childRef:ref,sizeRef:size},React__namespace.cloneElement(children,{ref}))}function newChildrenMap(){return new Map}function useUnmountEffect(callback){return React.useEffect(()=>()=>callback(),[])}function updateChildLookup(children,allChildren){children.forEach(child=>{allChildren.set(child.key||"",child)})}function onlyElements(children){const filtered=[];React.Children.forEach(children,
child=>{React.isValidElement(child)&&filtered.push(child)});return filtered}function isLazyBundle(features){return"function"===typeof features}function checkReorder(order,value,offset,velocity){if(!velocity)return order;const index=order.findIndex(item=>item.value===value);if(-1===index)return order;velocity=0<velocity?1:-1;var nextItem=order[index+velocity];if(!nextItem)return order;const item$jscomp$0=order[index];nextItem=nextItem.layout;nextItem=indexLegacy.mix(nextItem.min,nextItem.max,.5);return 1===
velocity&&item$jscomp$0.layout.max+offset>nextItem||-1===velocity&&item$jscomp$0.layout.min+offset<nextItem?indexLegacy.moveItem(order,index,index+velocity):order}function getValue(item){return item.value}function compareMin(a,b){return a.layout.min-b.layout.min}function useMotionValue(initial){const value=useConstant(()=>indexLegacy.motionValue(initial)),{isStatic}=React.useContext(MotionConfigContext);if(isStatic){const [,setLatest]=React.useState(initial);React.useEffect(()=>value.on("change",
setLatest),[])}return value}function useCombineMotionValues(values,combineValues){const value=useMotionValue(combineValues()),updateValue=()=>value.set(combineValues());value.set(combineValues());useIsomorphicLayoutEffect(()=>{const scheduleUpdate=()=>indexLegacy.frame.update(updateValue,!1,!0),subscriptions=values.map(v=>v.on("change",scheduleUpdate));return()=>{subscriptions.forEach(unsubscribe=>unsubscribe());indexLegacy.cancelFrame(updateValue)}});return value}function useComputed(compute){indexLegacy.collectMotionValues.current=
[];compute();compute=useCombineMotionValues(indexLegacy.collectMotionValues.current,compute);indexLegacy.collectMotionValues.current=void 0;return compute}function useTransform(input,inputRangeOrTransformer,outputRange,options){if("function"===typeof input)return useComputed(input);const transformer="function"===typeof inputRangeOrTransformer?inputRangeOrTransformer:indexLegacy.transform(inputRangeOrTransformer,outputRange,options);return Array.isArray(input)?useListTransform(input,transformer):useListTransform([input],
([latest])=>transformer(latest))}function useListTransform(values,transformer){const latest=useConstant(()=>[]);return useCombineMotionValues(values,()=>{latest.length=0;const numValues=values.length;for(let i=0;i<numValues;i++)latest[i]=values[i].get();return transformer(latest)})}function useDefaultMotionValue(value,defaultValue=0){return indexLegacy.isMotionValue(value)?value:useMotionValue(defaultValue)}function useMotionValueEvent(value,event,callback){React.useInsertionEffect(()=>value.on(event,
callback),[value,event,callback])}function refWarning(name,ref){indexLegacy.warning(!(ref&&!ref.current),`You have defined a ${name} options but the provided ref is not yet hydrated, probably because it's defined higher up the tree. Try calling useScroll() in the same component as the ref, or setting its \`layoutEffect: false\` option.`)}function useScroll({container,target,layoutEffect=!0,...options}={}){const values=useConstant(createScrollMotionValues);(layoutEffect?useIsomorphicLayoutEffect:React.useEffect)(()=>
{refWarning("target",target);refWarning("container",container);return indexLegacy.scrollInfo(({x,y})=>{values.scrollX.set(x.current);values.scrollXProgress.set(x.progress);values.scrollY.set(y.current);values.scrollYProgress.set(y.progress)},{...options,container:(null===container||void 0===container?void 0:container.current)||void 0,target:(null===target||void 0===target?void 0:target.current)||void 0})},[container,target,JSON.stringify(options.offset)]);return values}function useAnimationFrame(callback){const initialTimestamp=
React.useRef(0),{isStatic}=React.useContext(MotionConfigContext);React.useEffect(()=>{if(!isStatic){var provideTimeSinceStart=({timestamp,delta})=>{initialTimestamp.current||(initialTimestamp.current=timestamp);callback(timestamp-initialTimestamp.current,delta)};indexLegacy.frame.update(provideTimeSinceStart,!0);return()=>indexLegacy.cancelFrame(provideTimeSinceStart)}},[callback])}function useReducedMotion(){!indexLegacy.hasReducedMotionListener.current&&indexLegacy.initPrefersReducedMotion();const [shouldReduceMotion]=
React.useState(indexLegacy.prefersReducedMotion.current);indexLegacy.warnOnce(!0!==shouldReduceMotion,"You have Reduced Motion enabled on your device. Animations may not appear as expected.");return shouldReduceMotion}function stopAnimation(visualElement){visualElement.values.forEach(value=>value.stop())}function animationControls(){let hasMounted=!1;const subscribers=new Set,controls={subscribe(visualElement){subscribers.add(visualElement);return()=>void subscribers.delete(visualElement)},start(definition,
transitionOverride){indexLegacy.invariant(hasMounted,"controls.start() should only be called after a component has mounted. Consider calling within a useEffect hook.");const animations=[];subscribers.forEach(visualElement=>{animations.push(animateVisualElement(visualElement,definition,{transitionOverride}))});return Promise.all(animations)},set(definition){indexLegacy.invariant(hasMounted,"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.");
return subscribers.forEach(visualElement=>{indexLegacy.setValues(visualElement,definition)})},stop(){subscribers.forEach(visualElement=>{stopAnimation(visualElement)})},mount(){hasMounted=!0;return()=>{hasMounted=!1;controls.stop()}}};return controls}function useAnimationControls(){const controls=useConstant(animationControls);useIsomorphicLayoutEffect(controls.mount,[]);return controls}function isMotionComponent(component){return null!==component&&"object"===typeof component&&motionComponentSymbol in
component}function startTransition(callback){rootProjectionNode.current&&(rootProjectionNode.current.isUpdating=!1,rootProjectionNode.current.blockUpdate(),callback&&callback())}function handoffOptimizedAppearAnimation(elementId,valueName,_value,_frame){valueName=indexLegacy.transformProps.has(valueName)?"transform":valueName;elementId=`${elementId}: ${valueName}`;valueName=appearAnimationStore.get(elementId);if(!valueName)return null;const {animation,startTime}=valueName;if(null===startTime||window.HandoffComplete){appearAnimationStore.delete(elementId);
try{animation.cancel()}catch(error){}return null}void 0===handoffFrameTime&&(handoffFrameTime=performance.now());return handoffFrameTime-startTime||0}Object.defineProperty(exports,"__esModule",{value:!0});var React=require("module$node_modules$react$index"),indexLegacy=require("module$node_modules$framer_motion$dist$cjs$index_legacy_87714a68"),React__namespace=function(e){if(e&&e.__esModule)return e;var n=Object.create(null);e&&Object.keys(e).forEach(function(k){if("default"!==k){var d=Object.getOwnPropertyDescriptor(e,
k);Object.defineProperty(n,k,d.get?d:{enumerable:!0,get:function(){return e[k]}})}});n["default"]=e;return Object.freeze(n)}(React),React__default=React&&"object"===typeof React&&"default"in React?React:{"default":React};const MotionConfigContext=React.createContext({transformPagePoint:p=>p,isStatic:!1,reducedMotion:"never"}),MotionContext=React.createContext({}),PresenceContext=React.createContext(null),useIsomorphicLayoutEffect=indexLegacy.isBrowser?React.useLayoutEffect:React.useEffect,LazyContext=
React.createContext({strict:!1}),LayoutGroupContext=React.createContext({}),SwitchLayoutGroupContext=React.createContext({}),motionComponentSymbol=Symbol.for("motionComponentSymbol"),lowercaseSVGElements="animate circle defs desc ellipse g image line filter marker mask metadata path pattern polygon polyline rect stop switch symbol svg text tspan use view".split(" "),createHtmlRenderState=()=>({style:{},transform:{},transformOrigin:{},vars:{}}),validMotionProps=new Set("animate exit variants initial style values variants transition transformTemplate transformValues custom inherit onBeforeLayoutMeasure onAnimationStart onAnimationComplete onUpdate onDragStart onDrag onDragEnd onMeasureDragConstraints onDirectionLock onDragTransitionEnd _dragX _dragY onHoverStart onHoverEnd onViewportEnter onViewportLeave globalTapTarget ignoreStrict viewport".split(" "));
let shouldForward=key=>!isValidMotionProp(key);try{loadExternalIsValidProp(require("module$node_modules$framer_motion$node_modules$$emotion$is_prop_valid$dist$is_prop_valid_browser_cjs").default)}catch(_a){}const createSvgRenderState=()=>({...createHtmlRenderState(),attrs:{}}),makeUseVisualState=config=>(props,isStatic)=>{const context=React.useContext(MotionContext),presenceContext=React.useContext(PresenceContext),make=()=>makeState(config,props,context,presenceContext);return isStatic?make():useConstant(make)},
svgMotionConfig={useVisualState:makeUseVisualState({scrapeMotionValuesFromProps:indexLegacy.scrapeMotionValuesFromProps,createRenderState:createSvgRenderState,onMount:(props,instance,{renderState,latestValues})=>{indexLegacy.frame.read(()=>{try{renderState.dimensions="function"===typeof instance.getBBox?instance.getBBox():instance.getBoundingClientRect()}catch(e){renderState.dimensions={x:0,y:0,width:0,height:0}}});indexLegacy.frame.render(()=>{indexLegacy.buildSVGAttrs(renderState,latestValues,{enableHardwareAcceleration:!1},
indexLegacy.isSVGTag(instance.tagName),props.transformTemplate);indexLegacy.renderSVG(instance,renderState)})}})},htmlMotionConfig={useVisualState:makeUseVisualState({scrapeMotionValuesFromProps:indexLegacy.scrapeMotionValuesFromProps$1,createRenderState:createHtmlRenderState})},isPrimaryPointer=event=>"mouse"===event.pointerType?"number"!==typeof event.button||0>=event.button:!1!==event.isPrimary,addPointerInfo=handler=>event=>isPrimaryPointer(event)&&handler(event,extractEventInfo(event)),globalHorizontalLock=
createLock("dragHorizontal"),globalVerticalLock=createLock("dragVertical");class Feature{constructor(node){this.isMounted=!1;this.node=node}update(){}}class HoverGesture extends Feature{mount(){this.unmount=indexLegacy.pipe(addHoverEvent(this.node,!0),addHoverEvent(this.node,!1))}unmount(){}}class FocusGesture extends Feature{constructor(){super(...arguments);this.isActive=!1}onFocus(){let isFocusVisible=!1;try{isFocusVisible=this.node.current.matches(":focus-visible")}catch(e){isFocusVisible=!0}isFocusVisible&&
this.node.animationState&&(this.node.animationState.setActive("whileFocus",!0),this.isActive=!0)}onBlur(){this.isActive&&this.node.animationState&&(this.node.animationState.setActive("whileFocus",!1),this.isActive=!1)}mount(){this.unmount=indexLegacy.pipe(addDomEvent(this.node.current,"focus",()=>this.onFocus()),addDomEvent(this.node.current,"blur",()=>this.onBlur()))}unmount(){}}const isNodeOrChild=(parent,child)=>child?parent===child?!0:isNodeOrChild(parent,child.parentElement):!1;class PressGesture extends Feature{constructor(){super(...arguments);
this.removeAccessibleListeners=this.removeEndListeners=this.removeStartListeners=indexLegacy.noop;this.startPointerPress=(startEvent,startInfo)=>{if(!this.isPressing){this.removeEndListeners();var props=this.node.getProps(),removePointerUpListener=addPointerEvent(window,"pointerup",(endEvent,endInfo)=>{if(this.checkPressEnd()){var {onTap,onTapCancel,globalTapTarget}=this.node.getProps();indexLegacy.frame.update(()=>{globalTapTarget||isNodeOrChild(this.node.current,endEvent.target)?onTap&&onTap(endEvent,
endInfo):onTapCancel&&onTapCancel(endEvent,endInfo)})}},{passive:!(props.onTap||props.onPointerUp)});props=addPointerEvent(window,"pointercancel",(cancelEvent,cancelInfo)=>this.cancelPress(cancelEvent,cancelInfo),{passive:!(props.onTapCancel||props.onPointerCancel)});this.removeEndListeners=indexLegacy.pipe(removePointerUpListener,props);this.startPress(startEvent,startInfo)}};this.startAccessiblePress=()=>{const removeKeydownListener=addDomEvent(this.node.current,"keydown",keydownEvent=>{"Enter"!==
keydownEvent.key||this.isPressing||(this.removeEndListeners(),this.removeEndListeners=addDomEvent(this.node.current,"keyup",keyupEvent=>{"Enter"===keyupEvent.key&&this.checkPressEnd()&&fireSyntheticPointerEvent("up",(event,info)=>{const {onTap}=this.node.getProps();onTap&&indexLegacy.frame.update(()=>onTap(event,info))})}),fireSyntheticPointerEvent("down",(event,info)=>{this.startPress(event,info)}))}),removeBlurListener=addDomEvent(this.node.current,"blur",()=>{this.isPressing&&fireSyntheticPointerEvent("cancel",
(cancelEvent,cancelInfo)=>this.cancelPress(cancelEvent,cancelInfo))});this.removeAccessibleListeners=indexLegacy.pipe(removeKeydownListener,removeBlurListener)}}startPress(event,info){this.isPressing=!0;const {onTapStart,whileTap}=this.node.getProps();whileTap&&this.node.animationState&&this.node.animationState.setActive("whileTap",!0);onTapStart&&indexLegacy.frame.update(()=>onTapStart(event,info))}checkPressEnd(){this.removeEndListeners();this.isPressing=!1;this.node.getProps().whileTap&&this.node.animationState&&
this.node.animationState.setActive("whileTap",!1);return!isDragActive()}cancelPress(event,info){if(this.checkPressEnd()){var {onTapCancel}=this.node.getProps();onTapCancel&&indexLegacy.frame.update(()=>onTapCancel(event,info))}}mount(){var props=this.node.getProps();props=addPointerEvent(props.globalTapTarget?window:this.node.current,"pointerdown",this.startPointerPress,{passive:!(props.onTapStart||props.onPointerStart)});const removeFocusListener=addDomEvent(this.node.current,"focus",this.startAccessiblePress);
this.removeStartListeners=indexLegacy.pipe(props,removeFocusListener)}unmount(){this.removeStartListeners();this.removeEndListeners();this.removeAccessibleListeners()}}const observerCallbacks=new WeakMap,observers=new WeakMap,fireObserverCallback=entry=>{const callback=observerCallbacks.get(entry.target);callback&&callback(entry)},fireAllObserverCallbacks=entries=>{entries.forEach(fireObserverCallback)},thresholdNames={some:0,all:1};class InViewFeature extends Feature{constructor(){super(...arguments);
this.isInView=this.hasEnteredView=!1}startObserver(){this.unmount();const {viewport={}}=this.node.getProps(),{root,margin:rootMargin,amount="some",once}=viewport;return observeIntersection(this.node.current,{root:root?root.current:void 0,rootMargin,threshold:"number"===typeof amount?amount:thresholdNames[amount]},entry=>{var {isIntersecting}=entry;if(this.isInView!==isIntersecting&&(this.isInView=isIntersecting,!once||isIntersecting||!this.hasEnteredView)){isIntersecting&&(this.hasEnteredView=!0);
this.node.animationState&&this.node.animationState.setActive("whileInView",isIntersecting);var {onViewportEnter,onViewportLeave}=this.node.getProps();(isIntersecting=isIntersecting?onViewportEnter:onViewportLeave)&&isIntersecting(entry)}})}mount(){this.startObserver()}update(){if("undefined"!==typeof IntersectionObserver){var {props,prevProps}=this.node;["amount","margin","root"].some(hasViewportOptionChanged(props,prevProps))&&this.startObserver()}}unmount(){}}const gestureAnimations={inView:{Feature:InViewFeature},
tap:{Feature:PressGesture},focus:{Feature:FocusGesture},hover:{Feature:HoverGesture}},reversePriorityOrder=[...indexLegacy.variantPriorityOrder].reverse(),numAnimationTypes=indexLegacy.variantPriorityOrder.length;class AnimationFeature extends Feature{constructor(node){super(node);node.animationState||(node.animationState=createAnimationState(node))}updateAnimationControlsSubscription(){const {animate}=this.node.getProps();this.unmount();indexLegacy.isAnimationControls(animate)&&(this.unmount=animate.subscribe(this.node))}mount(){this.updateAnimationControlsSubscription()}update(){const {animate}=
this.node.getProps(),{animate:prevAnimate}=this.node.prevProps||{};animate!==prevAnimate&&this.updateAnimationControlsSubscription()}unmount(){}}let id$2=0;class ExitAnimationFeature extends Feature{constructor(){super(...arguments);this.id=id$2++}update(){if(this.node.presenceContext){var {isPresent,onExitComplete,custom}=this.node.presenceContext,{isPresent:prevIsPresent}=this.node.prevPresenceContext||{};this.node.animationState&&isPresent!==prevIsPresent&&(prevIsPresent=this.node.animationState.setActive("exit",
!isPresent,{custom:null!==custom&&void 0!==custom?custom:this.node.getProps().custom}),onExitComplete&&!isPresent&&prevIsPresent.then(()=>onExitComplete(this.id)))}}mount(){const {register}=this.node.presenceContext||{};register&&(this.unmount=register(this.id))}unmount(){}}const animations$jscomp$0={animation:{Feature:AnimationFeature},exit:{Feature:ExitAnimationFeature}};class PanSession{constructor(event$jscomp$0,handlers,{transformPagePoint,contextWindow,dragSnapToOrigin=!1}={}){this.lastMoveEventInfo=
this.lastMoveEvent=this.startEvent=null;this.handlers={};this.contextWindow=window;this.updatePoint=()=>{if(this.lastMoveEvent&&this.lastMoveEventInfo){var info=getPanInfo(this.lastMoveEventInfo,this.history),isPanStarted=null!==this.startEvent,isDistancePastThreshold=3<=indexLegacy.distance2D(info.offset,{x:0,y:0});if(isPanStarted||isDistancePastThreshold){({point:isDistancePastThreshold}=info);var {timestamp}=indexLegacy.frameData;this.history.push({...isDistancePastThreshold,timestamp});var {onStart,
onMove}=this.handlers;isPanStarted||(onStart&&onStart(this.lastMoveEvent,info),this.startEvent=this.lastMoveEvent);onMove&&onMove(this.lastMoveEvent,info)}}};this.handlePointerMove=(event,info)=>{this.lastMoveEvent=event;this.lastMoveEventInfo=transformPoint(info,this.transformPagePoint);indexLegacy.frame.update(this.updatePoint,!0)};this.handlePointerUp=(event,info)=>{this.end();const {onEnd,onSessionEnd,resumeAnimation}=this.handlers;this.dragSnapToOrigin&&resumeAnimation&&resumeAnimation();this.lastMoveEvent&&
this.lastMoveEventInfo&&(info=getPanInfo("pointercancel"===event.type?this.lastMoveEventInfo:transformPoint(info,this.transformPagePoint),this.history),this.startEvent&&onEnd&&onEnd(event,info),onSessionEnd&&onSessionEnd(event,info))};isPrimaryPointer(event$jscomp$0)&&(this.dragSnapToOrigin=dragSnapToOrigin,this.handlers=handlers,this.transformPagePoint=transformPagePoint,this.contextWindow=contextWindow||window,transformPagePoint=extractEventInfo(event$jscomp$0),transformPagePoint=transformPoint(transformPagePoint,
this.transformPagePoint),{point:contextWindow}=transformPagePoint,{timestamp:dragSnapToOrigin}=indexLegacy.frameData,this.history=[{...contextWindow,timestamp:dragSnapToOrigin}],{onSessionStart:handlers}=handlers,handlers&&handlers(event$jscomp$0,getPanInfo(transformPagePoint,this.history)),this.removeListeners=indexLegacy.pipe(addPointerEvent(this.contextWindow,"pointermove",this.handlePointerMove),addPointerEvent(this.contextWindow,"pointerup",this.handlePointerUp),addPointerEvent(this.contextWindow,
"pointercancel",this.handlePointerUp)))}updateHandlers(handlers){this.handlers=handlers}end(){this.removeListeners&&this.removeListeners();indexLegacy.cancelFrame(this.updatePoint)}}const getContextWindow=({current})=>current?current.ownerDocument.defaultView:null,elementDragControls=new WeakMap;class VisualElementDragControls{constructor(visualElement){this.openGlobalLock=null;this.isDragging=!1;this.currentDirection=null;this.originPoint={x:0,y:0};this.hasMutatedConstraints=this.constraints=!1;
this.elastic=indexLegacy.createBox();this.visualElement=visualElement}start(originEvent,{snapToCursor=!1}={}){var {presenceContext}=this.visualElement;presenceContext&&!1===presenceContext.isPresent||({dragSnapToOrigin:presenceContext}=this.getProps(),this.panSession=new PanSession(originEvent,{onSessionStart:event=>{const {dragSnapToOrigin}=this.getProps();dragSnapToOrigin?this.pauseAnimation():this.stopAnimation();snapToCursor&&this.snapToCursor(extractEventInfo(event,"page").point)},onStart:(event,
info)=>{const {drag,dragPropagation,onDragStart}=this.getProps();if(drag&&!dragPropagation&&(this.openGlobalLock&&this.openGlobalLock(),this.openGlobalLock=getGlobalLock(drag),!this.openGlobalLock))return;this.isDragging=!0;this.currentDirection=null;this.resolveConstraints();this.visualElement.projection&&(this.visualElement.projection.isAnimationBlocked=!0,this.visualElement.projection.target=void 0);eachAxis(axis=>{let current=this.getAxisMotionValue(axis).get()||0;if(indexLegacy.percent.test(current)){var {projection}=
this.visualElement;projection&&projection.layout&&(projection=projection.layout.layoutBox[axis])&&(current=calcLength(projection)*(parseFloat(current)/100))}this.originPoint[axis]=current});onDragStart&&indexLegacy.frame.update(()=>onDragStart(event,info),!1,!0);const {animationState}=this.visualElement;animationState&&animationState.setActive("whileDrag",!0)},onMove:(event,info)=>{const {dragPropagation,dragDirectionLock,onDirectionLock,onDrag}=this.getProps();if(dragPropagation||this.openGlobalLock){var {offset}=
info;dragDirectionLock&&null===this.currentDirection?(this.currentDirection=getCurrentDirection(offset),null!==this.currentDirection&&onDirectionLock&&onDirectionLock(this.currentDirection)):(this.updateAxis("x",info.point,offset),this.updateAxis("y",info.point,offset),this.visualElement.render(),onDrag&&onDrag(event,info))}},onSessionEnd:(event,info)=>this.stop(event,info),resumeAnimation:()=>eachAxis(axis=>{var _a;return"paused"===this.getAnimationState(axis)&&(null===(_a=this.getAxisMotionValue(axis).animation)||
void 0===_a?void 0:_a.play())})},{transformPagePoint:this.visualElement.getTransformPagePoint(),dragSnapToOrigin:presenceContext,contextWindow:getContextWindow(this.visualElement)}))}stop(event,info){var isDragging=this.isDragging;this.cancel();if(isDragging){({velocity:isDragging}=info);this.startAnimation(isDragging);var {onDragEnd}=this.getProps();onDragEnd&&indexLegacy.frame.update(()=>onDragEnd(event,info))}}cancel(){this.isDragging=!1;const {projection,animationState}=this.visualElement;projection&&
(projection.isAnimationBlocked=!1);this.panSession&&this.panSession.end();this.panSession=void 0;const {dragPropagation}=this.getProps();!dragPropagation&&this.openGlobalLock&&(this.openGlobalLock(),this.openGlobalLock=null);animationState&&animationState.setActive("whileDrag",!1)}updateAxis(axis,_point,offset){({drag:_point}=this.getProps());offset&&shouldDrag(axis,_point,this.currentDirection)&&(_point=this.getAxisMotionValue(axis),offset=this.originPoint[axis]+offset[axis],this.constraints&&this.constraints[axis]&&
(offset=applyConstraints(offset,this.constraints[axis],this.elastic[axis])),_point.set(offset))}resolveConstraints(){var _a;const {dragConstraints,dragElastic}=this.getProps(),layout$jscomp$0=this.visualElement.projection&&!this.visualElement.projection.layout?this.visualElement.projection.measure(!1):null===(_a=this.visualElement.projection)||void 0===_a?void 0:_a.layout;_a=this.constraints;dragConstraints&&indexLegacy.isRefObject(dragConstraints)?this.constraints||(this.constraints=this.resolveRefConstraints()):
this.constraints=dragConstraints&&layout$jscomp$0?calcRelativeConstraints(layout$jscomp$0.layoutBox,dragConstraints):!1;this.elastic=resolveDragElastic(dragElastic);_a!==this.constraints&&layout$jscomp$0&&this.constraints&&!this.hasMutatedConstraints&&eachAxis(axis=>{if(this.getAxisMotionValue(axis)){var JSCompiler_temp_const=this.constraints,layout=layout$jscomp$0.layoutBox[axis],constraints=this.constraints[axis];const relativeConstraints={};void 0!==constraints.min&&(relativeConstraints.min=constraints.min-
layout.min);void 0!==constraints.max&&(relativeConstraints.max=constraints.max-layout.min);JSCompiler_temp_const[axis]=relativeConstraints}})}resolveRefConstraints(){const {dragConstraints:constraints,onMeasureDragConstraints}=this.getProps();if(!constraints||!indexLegacy.isRefObject(constraints))return!1;var constraintsElement=constraints.current;indexLegacy.invariant(null!==constraintsElement,"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
var {projection}=this.visualElement;if(!projection||!projection.layout)return!1;constraintsElement=indexLegacy.measurePageBox(constraintsElement,projection.root,this.visualElement.getTransformPagePoint());projection=projection.layout.layoutBox;projection={x:calcViewportAxisConstraints(projection.x,constraintsElement.x),y:calcViewportAxisConstraints(projection.y,constraintsElement.y)};onMeasureDragConstraints&&(constraintsElement=onMeasureDragConstraints(indexLegacy.convertBoxToBoundingBox(projection)),
this.hasMutatedConstraints=!!constraintsElement,constraintsElement&&(projection=indexLegacy.convertBoundingBoxToBox(constraintsElement)));return projection}startAnimation(velocity){const {drag,dragMomentum,dragElastic,dragTransition,dragSnapToOrigin,onDragTransitionEnd}=this.getProps(),constraints=this.constraints||{},momentumAnimations=eachAxis(axis=>{if(shouldDrag(axis,drag,this.currentDirection)){var transition=constraints&&constraints[axis]||{};dragSnapToOrigin&&(transition={min:0,max:0});return this.startAxisValueAnimation(axis,
{type:"inertia",velocity:dragMomentum?velocity[axis]:0,bounceStiffness:dragElastic?200:1E6,bounceDamping:dragElastic?40:1E7,timeConstant:750,restDelta:1,restSpeed:10,...dragTransition,...transition})}});return Promise.all(momentumAnimations).then(onDragTransitionEnd)}startAxisValueAnimation(axis,transition){const axisValue=this.getAxisMotionValue(axis);return axisValue.start(indexLegacy.animateMotionValue(axis,axisValue,0,transition))}stopAnimation(){eachAxis(axis=>this.getAxisMotionValue(axis).stop())}pauseAnimation(){eachAxis(axis=>
{var _a;return null===(_a=this.getAxisMotionValue(axis).animation)||void 0===_a?void 0:_a.pause()})}getAnimationState(axis){var _a;return null===(_a=this.getAxisMotionValue(axis).animation)||void 0===_a?void 0:_a.state}getAxisMotionValue(axis){var dragKey="_drag"+axis.toUpperCase();const props=this.visualElement.getProps();return(dragKey=props[dragKey])?dragKey:this.visualElement.getValue(axis,(props.initial?props.initial[axis]:void 0)||0)}snapToCursor(point){eachAxis(axis=>{var {drag}=this.getProps();
if(shouldDrag(axis,drag,this.currentDirection)){({projection:drag}=this.visualElement);var axisValue=this.getAxisMotionValue(axis);if(drag&&drag.layout){const {min,max}=drag.layout.layoutBox[axis];axisValue.set(point[axis]-indexLegacy.mix(min,max,.5))}}})}scalePositionWithinConstraints(){if(this.visualElement.current){var {drag,dragConstraints}=this.getProps(),{projection}=this.visualElement;if(indexLegacy.isRefObject(dragConstraints)&&projection&&this.constraints){this.stopAnimation();var boxProgress=
{x:0,y:0};eachAxis(axis=>{var axisValue=this.getAxisMotionValue(axis);if(axisValue){axisValue=axisValue.get();axisValue={min:axisValue,max:axisValue};var target=this.constraints[axis];let origin=.5;const sourceLength=calcLength(axisValue),targetLength=calcLength(target);targetLength>sourceLength?origin=indexLegacy.progress(target.min,target.max-sourceLength,axisValue.min):sourceLength>targetLength&&(origin=indexLegacy.progress(axisValue.min,axisValue.max-targetLength,target.min));axisValue=indexLegacy.clamp(0,
1,origin);boxProgress[axis]=axisValue}});var {transformTemplate}=this.visualElement.getProps();this.visualElement.current.style.transform=transformTemplate?transformTemplate({},""):"none";projection.root&&projection.root.updateScroll();projection.updateLayout();this.resolveConstraints();eachAxis(axis=>{if(shouldDrag(axis,drag,null)){var axisValue=this.getAxisMotionValue(axis),{min,max}=this.constraints[axis];axisValue.set(indexLegacy.mix(min,max,boxProgress[axis]))}})}}}addListeners(){if(this.visualElement.current){elementDragControls.set(this.visualElement,
this);var stopPointerListener=addPointerEvent(this.visualElement.current,"pointerdown",event=>{const {drag,dragListener=!0}=this.getProps();drag&&dragListener&&this.start(event)}),measureDragConstraints=()=>{const {dragConstraints}=this.getProps();indexLegacy.isRefObject(dragConstraints)&&(this.constraints=this.resolveRefConstraints())},{projection}=this.visualElement,stopMeasureLayoutListener=projection.addEventListener("measure",measureDragConstraints);projection&&!projection.layout&&(projection.root&&
projection.root.updateScroll(),projection.updateLayout());measureDragConstraints();var stopResizeListener=addDomEvent(window,"resize",()=>this.scalePositionWithinConstraints()),stopLayoutUpdateListener=projection.addEventListener("didUpdate",({delta,hasLayoutChanged})=>{this.isDragging&&hasLayoutChanged&&(eachAxis(axis=>{const motionValue=this.getAxisMotionValue(axis);motionValue&&(this.originPoint[axis]+=delta[axis].translate,motionValue.set(motionValue.get()+delta[axis].translate))}),this.visualElement.render())});
return()=>{stopResizeListener();stopPointerListener();stopMeasureLayoutListener();stopLayoutUpdateListener&&stopLayoutUpdateListener()}}}getProps(){const props=this.visualElement.getProps(),{drag=!1,dragDirectionLock=!1,dragPropagation=!1,dragConstraints=!1,dragElastic=.35,dragMomentum=!0}=props;return{...props,drag,dragDirectionLock,dragPropagation,dragConstraints,dragElastic,dragMomentum}}}class DragGesture extends Feature{constructor(node){super(node);this.removeListeners=this.removeGroupControls=
indexLegacy.noop;this.controls=new VisualElementDragControls(node)}mount(){const {dragControls}=this.node.getProps();dragControls&&(this.removeGroupControls=dragControls.subscribe(this.controls));this.removeListeners=this.controls.addListeners()||indexLegacy.noop}unmount(){this.removeGroupControls();this.removeListeners()}}const asyncHandler=handler=>(event,info)=>{handler&&indexLegacy.frame.update(()=>handler(event,info))};class PanGesture extends Feature{constructor(){super(...arguments);this.removePointerDownListener=
indexLegacy.noop}onPointerDown(pointerDownEvent){this.session=new PanSession(pointerDownEvent,this.createPanHandlers(),{transformPagePoint:this.node.getTransformPagePoint(),contextWindow:getContextWindow(this.node)})}createPanHandlers(){const {onPanSessionStart,onPanStart,onPan,onPanEnd}=this.node.getProps();return{onSessionStart:asyncHandler(onPanSessionStart),onStart:asyncHandler(onPanStart),onMove:onPan,onEnd:(event,info)=>{delete this.session;onPanEnd&&indexLegacy.frame.update(()=>onPanEnd(event,
info))}}}mount(){this.removePointerDownListener=addPointerEvent(this.node.current,"pointerdown",event=>this.onPointerDown(event))}update(){this.session&&this.session.updateHandlers(this.createPanHandlers())}unmount(){this.removePointerDownListener();this.session&&this.session.end()}}const borders=["TopLeft","TopRight","BottomLeft","BottomRight"],numBorders=borders.length,asNumber=value=>"string"===typeof value?parseFloat(value):value,easeCrossfadeIn=compress(0,.5,indexLegacy.circOut),easeCrossfadeOut=
compress(.5,.95,indexLegacy.noop),xKeys=["x","scaleX","originX"],yKeys=["y","scaleY","originY"];class NodeStack{constructor(){this.members=[]}add(node){indexLegacy.addUniqueItem(this.members,node);node.scheduleRender()}remove(node){indexLegacy.removeItem(this.members,node);node===this.prevLead&&(this.prevLead=void 0);node===this.lead&&(node=this.members[this.members.length-1])&&this.promote(node)}relegate(node){var indexOfNode=this.members.findIndex(member=>node===member);if(0===indexOfNode)return!1;
let prevLead;for(;0<=indexOfNode;indexOfNode--){const member=this.members[indexOfNode];if(!1!==member.isPresent){prevLead=member;break}}return prevLead?(this.promote(prevLead),!0):!1}promote(node,preserveFollowOpacity){const prevLead=this.lead;node!==prevLead&&(this.prevLead=prevLead,this.lead=node,node.show(),prevLead&&(prevLead.instance&&prevLead.scheduleRender(),node.scheduleRender(),node.resumeFrom=prevLead,preserveFollowOpacity&&(node.resumeFrom.preserveOpacity=!0),prevLead.snapshot&&(node.snapshot=
prevLead.snapshot,node.snapshot.latestValues=prevLead.animationValues||prevLead.latestValues),node.root&&node.root.isUpdating&&(node.isLayoutDirty=!0),{crossfade:node}=node.options,!1===node&&prevLead.hide()))}exitAnimationComplete(){this.members.forEach(node=>{const {options,resumingFrom}=node;options.onExitComplete&&options.onExitComplete();resumingFrom&&resumingFrom.options.onExitComplete&&resumingFrom.options.onExitComplete()})}scheduleRender(){this.members.forEach(node=>{node.instance&&node.scheduleRender(!1)})}removeLeadSnapshot(){this.lead&&
this.lead.snapshot&&(this.lead.snapshot=void 0)}}const compareByDepth=(a,b)=>a.depth-b.depth;class FlatTree{constructor(){this.children=[];this.isDirty=!1}add(child){indexLegacy.addUniqueItem(this.children,child);this.isDirty=!0}remove(child){indexLegacy.removeItem(this.children,child);this.isDirty=!0}forEach(callback){this.isDirty&&this.children.sort(compareByDepth);this.isDirty=!1;this.children.forEach(callback)}}const globalProjectionState={hasAnimatedSinceResize:!0,hasEverUpdated:!1},transformAxes=
["","X","Y","Z"],hiddenVisibility={visibility:"hidden"};let id$1=0;const projectionFrameData={type:"projectionFrame",totalNodes:0,resolvedTargetDeltas:0,recalculatedProjection:0},defaultLayoutTransition={duration:.45,ease:[.4,0,.1,1]},roundPoint="undefined"===typeof navigator||!navigator.userAgent.toLowerCase().includes("applewebkit/")||"undefined"!==typeof navigator&&navigator.userAgent.toLowerCase().includes("chrome/")?indexLegacy.noop:Math.round,DocumentProjectionNode=createProjectionNode({attachResizeListener:(ref,
notify)=>addDomEvent(ref,"resize",notify),measureScroll:()=>({x:document.documentElement.scrollLeft||document.body.scrollLeft,y:document.documentElement.scrollTop||document.body.scrollTop}),checkIsScrollRoot:()=>!0}),rootProjectionNode={current:void 0},HTMLProjectionNode=createProjectionNode({measureScroll:instance=>({x:instance.scrollLeft,y:instance.scrollTop}),defaultParent:()=>{if(!rootProjectionNode.current){const documentNode=new DocumentProjectionNode({});documentNode.mount(window);documentNode.setOptions({layoutScroll:!0});
rootProjectionNode.current=documentNode}return rootProjectionNode.current},resetTransform:(instance,value)=>{instance.style.transform=void 0!==value?value:"none"},checkIsScrollRoot:instance=>"fixed"===window.getComputedStyle(instance).position}),notify=node=>!node.isLayoutDirty&&node.willUpdate(!1),correctBorderRadius={correct:(latest,node)=>{if(!node.target)return latest;if("string"===typeof latest)if(indexLegacy.px.test(latest))latest=parseFloat(latest);else return latest;const x=pixelsToPercent(latest,
node.target.x);latest=pixelsToPercent(latest,node.target.y);return`${x}% ${latest}%`}};class MeasureLayoutWithContext extends React__default["default"].Component{componentDidMount(){const {visualElement,layoutGroup,switchLayoutGroup,layoutId}=this.props,{projection}=visualElement;indexLegacy.addScaleCorrector(defaultScaleCorrectors);projection&&(layoutGroup.group&&layoutGroup.group.add(projection),switchLayoutGroup&&switchLayoutGroup.register&&layoutId&&switchLayoutGroup.register(projection),projection.root.didUpdate(),
projection.addEventListener("animationComplete",()=>{this.safeToRemove()}),projection.setOptions({...projection.options,onExitComplete:()=>this.safeToRemove()}));globalProjectionState.hasEverUpdated=!0}getSnapshotBeforeUpdate(prevProps){const {layoutDependency,visualElement,drag,isPresent}=this.props,projection=visualElement.projection;if(!projection)return null;projection.isPresent=isPresent;drag||prevProps.layoutDependency!==layoutDependency||void 0===layoutDependency?projection.willUpdate():this.safeToRemove();
prevProps.isPresent!==isPresent&&(isPresent?projection.promote():projection.relegate()||indexLegacy.frame.postRender(()=>{const stack=projection.getStack();stack&&stack.members.length||this.safeToRemove()}));return null}componentDidUpdate(){const {projection}=this.props.visualElement;projection&&(projection.root.didUpdate(),queueMicrotask(()=>{!projection.currentAnimation&&projection.isLead()&&this.safeToRemove()}))}componentWillUnmount(){const {visualElement,layoutGroup,switchLayoutGroup:promoteContext}=
this.props,{projection}=visualElement;projection&&(projection.scheduleCheckAfterUnmount(),layoutGroup&&layoutGroup.group&&layoutGroup.group.remove(projection),promoteContext&&promoteContext.deregister&&promoteContext.deregister(projection))}safeToRemove(){const {safeToRemove}=this.props;safeToRemove&&safeToRemove()}render(){return null}}const defaultScaleCorrectors={borderRadius:{...correctBorderRadius,applyTo:["borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius"]},
borderTopLeftRadius:correctBorderRadius,borderTopRightRadius:correctBorderRadius,borderBottomLeftRadius:correctBorderRadius,borderBottomRightRadius:correctBorderRadius,boxShadow:{correct:(latest,{treeScale,projectionDelta})=>{const shadow=indexLegacy.complex.parse(latest);if(5<shadow.length)return latest;latest=indexLegacy.complex.createTransformer(latest);const offset="number"!==typeof shadow[0]?1:0,xScale=projectionDelta.x.scale*treeScale.x;treeScale=projectionDelta.y.scale*treeScale.y;shadow[0+
offset]/=xScale;shadow[1+offset]/=treeScale;treeScale=indexLegacy.mix(xScale,treeScale,.5);"number"===typeof shadow[2+offset]&&(shadow[2+offset]/=treeScale);"number"===typeof shadow[3+offset]&&(shadow[3+offset]/=treeScale);return latest(shadow)}}},drag$jscomp$0={pan:{Feature:PanGesture},drag:{Feature:DragGesture,ProjectionNode:HTMLProjectionNode,MeasureLayout:MeasureLayout$jscomp$0}},createDomVisualElement=(Component,options)=>isSVGComponent(Component)?new indexLegacy.SVGVisualElement(options,{enableHardwareAcceleration:!1}):
new indexLegacy.HTMLVisualElement(options,{enableHardwareAcceleration:!0}),layout$jscomp$1={layout:{ProjectionNode:HTMLProjectionNode,MeasureLayout:MeasureLayout$jscomp$0}},preloadedFeatures$jscomp$0={...animations$jscomp$0,...gestureAnimations,...drag$jscomp$0,...layout$jscomp$1},motion=createMotionProxy((Component,config)=>createDomMotionConfig(Component,config,preloadedFeatures$jscomp$0,createDomVisualElement)),m=createMotionProxy(createDomMotionConfig);class PopChildMeasure extends React__namespace.Component{getSnapshotBeforeUpdate(prevProps){const element=
this.props.childRef.current;element&&prevProps.isPresent&&!this.props.isPresent&&(prevProps=this.props.sizeRef.current,prevProps.height=element.offsetHeight||0,prevProps.width=element.offsetWidth||0,prevProps.top=element.offsetTop,prevProps.left=element.offsetLeft);return null}componentDidUpdate(){}render(){return this.props.children}}const PresenceChild=({children,initial,isPresent,onExitComplete,custom,presenceAffectsLayout,mode})=>{const presenceChildren=useConstant(newChildrenMap),id=React.useId();
presenceAffectsLayout=React.useMemo(()=>({id,initial,isPresent,custom,onExitComplete:childId=>{presenceChildren.set(childId,!0);for(const isComplete of presenceChildren.values())if(!isComplete)return;onExitComplete&&onExitComplete()},register:childId=>{presenceChildren.set(childId,!1);return()=>presenceChildren.delete(childId)}}),presenceAffectsLayout?void 0:[isPresent]);React.useMemo(()=>{presenceChildren.forEach((_,key)=>presenceChildren.set(key,!1))},[isPresent]);React__namespace.useEffect(()=>
{!isPresent&&!presenceChildren.size&&onExitComplete&&onExitComplete()},[isPresent]);"popLayout"===mode&&(children=React__namespace.createElement(PopChild,{isPresent},children));return React__namespace.createElement(PresenceContext.Provider,{value:presenceAffectsLayout},children)},getChildKey=child=>child.key||"",DeprecatedLayoutGroupContext=React.createContext(null),LayoutGroup=({children,id,inherit=!0})=>{const layoutGroupContext=React.useContext(LayoutGroupContext);var deprecatedLayoutGroupContext=
React.useContext(DeprecatedLayoutGroupContext);const [forceRender,key]=useForceUpdate(),context=React.useRef(null);deprecatedLayoutGroupContext=layoutGroupContext.id||deprecatedLayoutGroupContext;null===context.current&&((!0===inherit===!0||"id"===inherit)&&deprecatedLayoutGroupContext&&(id=id?deprecatedLayoutGroupContext+"-"+id:deprecatedLayoutGroupContext),context.current={id,group:!0===inherit?layoutGroupContext.group||nodeGroup():nodeGroup()});id=React.useMemo(()=>({...context.current,forceRender}),
[key]);return React__namespace.createElement(LayoutGroupContext.Provider,{value:id},children)},ReorderContext=React.createContext(null),Group=React.forwardRef(function({children,as="ul",axis="y",onReorder,values,...props},externalRef){const Component=useConstant(()=>motion(as)),order=[],isReordering=React.useRef(!1);indexLegacy.invariant(!!values,"Reorder.Group must be provided a values prop");const context={axis,registerItem:(value,layout)=>{const idx=order.findIndex(entry=>value===entry.value);
-1!==idx?order[idx].layout=layout[axis]:order.push({value,layout:layout[axis]});order.sort(compareMin)},updateOrder:(item,offset,velocity)=>{isReordering.current||(item=checkReorder(order,item,offset,velocity),order!==item&&(isReordering.current=!0,onReorder(item.map(getValue).filter(value=>-1!==values.indexOf(value)))))}};React.useEffect(()=>{isReordering.current=!1});return React__namespace.createElement(Component,{...props,ref:externalRef,ignoreStrict:!0},React__namespace.createElement(ReorderContext.Provider,
{value:context},children))}),Item=React.forwardRef(function({children,style={},value,as="li",onDrag,layout=!0,...props},externalRef){const Component=useConstant(()=>motion(as)),context=React.useContext(ReorderContext),point={x:useDefaultMotionValue(style.x),y:useDefaultMotionValue(style.y)},zIndex=useTransform([point.x,point.y],([latestX,latestY])=>latestX||latestY?1:"unset");indexLegacy.invariant(!!context,"Reorder.Item must be a child of Reorder.Group");const {axis,registerItem,updateOrder}=context;
return React__namespace.createElement(Component,{drag:axis,...props,dragSnapToOrigin:!0,style:{...style,x:point.x,y:point.y,zIndex},layout,onDrag:(event,gesturePoint)=>{const {velocity}=gesturePoint;velocity[axis]&&updateOrder(value,point[axis].get(),velocity[axis]);onDrag&&onDrag(event,gesturePoint)},onLayoutMeasure:measured=>registerItem(value,measured),ref:externalRef,ignoreStrict:!0},children)}),Reorder={Group,Item},domAnimation={renderer:createDomVisualElement,...animations$jscomp$0,...gestureAnimations},
domMax={...domAnimation,...drag$jscomp$0,...layout$jscomp$1},createScrollMotionValues=()=>({scrollX:indexLegacy.motionValue(0),scrollY:indexLegacy.motionValue(0),scrollXProgress:indexLegacy.motionValue(0),scrollYProgress:indexLegacy.motionValue(0)});class WillChangeMotionValue extends indexLegacy.MotionValue{constructor(){super(...arguments);this.members=[];this.transforms=new Set}add(name){let memberName;indexLegacy.transformProps.has(name)?(this.transforms.add(name),memberName="transform"):name.startsWith("origin")||
indexLegacy.isCSSVariableName(name)||"willChange"===name||(memberName=indexLegacy.camelToDash(name));memberName&&(indexLegacy.addUniqueItem(this.members,memberName),this.update())}remove(name){indexLegacy.transformProps.has(name)?(this.transforms.delete(name),this.transforms.size||indexLegacy.removeItem(this.members,"transform")):indexLegacy.removeItem(this.members,indexLegacy.camelToDash(name));this.update()}update(){this.set(this.members.length?this.members.join(", "):"auto")}}class DragControls{constructor(){this.componentControls=
new Set}subscribe(controls){this.componentControls.add(controls);return()=>this.componentControls.delete(controls)}start(event,options){this.componentControls.forEach(controls=>{controls.start(event.nativeEvent||event,options)})}}const createDragControls=()=>new DragControls,appearAnimationStore=new Map;let handoffFrameTime,startFrameTime,readyAnimation;const createObject=()=>({});class StateVisualElement extends indexLegacy.VisualElement{build(){}measureInstanceViewportBox(){return indexLegacy.createBox()}resetTransform(){}restoreTransform(){}removeValueFromRenderState(){}renderInstance(){}scrapeMotionValuesFromProps(){return{}}getBaseTargetFromProps(){}readValueFromInstance(_state,
key,options){return options.initialState[key]||0}sortInstanceNodePosition(){return 0}makeTargetAnimatableFromInstance({transition,transitionEnd,...target}){const origin=indexLegacy.getOrigin(target,transition||{},this);indexLegacy.checkTargetForNewValues(this,target,origin);return{transition,transitionEnd,...target}}}const useVisualState=makeUseVisualState({scrapeMotionValuesFromProps:createObject,createRenderState:createObject}),invertScale=scale=>.001<scale?1/scale:1E5;let hasWarned=!1,id$jscomp$0=
0;exports.MotionGlobalConfig=indexLegacy.MotionGlobalConfig;exports.MotionValue=indexLegacy.MotionValue;exports.VisualElement=indexLegacy.VisualElement;exports.addScaleCorrector=indexLegacy.addScaleCorrector;exports.animate=indexLegacy.animate;exports.animateValue=indexLegacy.animateValue;exports.anticipate=indexLegacy.anticipate;exports.backIn=indexLegacy.backIn;exports.backInOut=indexLegacy.backInOut;exports.backOut=indexLegacy.backOut;exports.buildTransform=indexLegacy.buildTransform;exports.cancelFrame=
indexLegacy.cancelFrame;exports.cancelSync=indexLegacy.cancelSync;exports.checkTargetForNewValues=indexLegacy.checkTargetForNewValues;exports.circIn=indexLegacy.circIn;exports.circInOut=indexLegacy.circInOut;exports.circOut=indexLegacy.circOut;exports.clamp=indexLegacy.clamp;exports.color=indexLegacy.color;exports.complex=indexLegacy.complex;exports.createBox=indexLegacy.createBox;exports.createScopedAnimate=indexLegacy.createScopedAnimate;exports.cubicBezier=indexLegacy.cubicBezier;exports.delay=
indexLegacy.delay;exports.distance=indexLegacy.distance;exports.distance2D=indexLegacy.distance2D;exports.easeIn=indexLegacy.easeIn;exports.easeInOut=indexLegacy.easeInOut;exports.easeOut=indexLegacy.easeOut;exports.frame=indexLegacy.frame;exports.frameData=indexLegacy.frameData;exports.inView=indexLegacy.inView;exports.interpolate=indexLegacy.interpolate;Object.defineProperty(exports,"invariant",{enumerable:!0,get:function(){return indexLegacy.invariant}});exports.isBrowser=indexLegacy.isBrowser;
exports.isMotionValue=indexLegacy.isMotionValue;exports.mirrorEasing=indexLegacy.mirrorEasing;exports.mix=indexLegacy.mix;exports.motionValue=indexLegacy.motionValue;exports.optimizedAppearDataAttribute=indexLegacy.optimizedAppearDataAttribute;exports.pipe=indexLegacy.pipe;exports.progress=indexLegacy.progress;exports.px=indexLegacy.px;exports.reverseEasing=indexLegacy.reverseEasing;exports.scroll=indexLegacy.scroll;exports.scrollInfo=indexLegacy.scrollInfo;exports.spring=indexLegacy.spring;exports.stagger=
indexLegacy.stagger;exports.steps=indexLegacy.steps;exports.sync=indexLegacy.sync;exports.transform=indexLegacy.transform;exports.visualElementStore=indexLegacy.visualElementStore;Object.defineProperty(exports,"warning",{enumerable:!0,get:function(){return indexLegacy.warning}});exports.wrap=indexLegacy.wrap;exports.AnimatePresence=({children,custom,initial=!0,onExitComplete,exitBeforeEnter,presenceAffectsLayout=!0,mode="sync"})=>{indexLegacy.invariant(!exitBeforeEnter,"Replace exitBeforeEnter with mode\x3d'wait'");
const forceRender=React.useContext(LayoutGroupContext).forceRender||useForceUpdate()[0],isMounted=useIsMounted(),filteredChildren=onlyElements(children);let childrenToRender=filteredChildren;const exitingChildren=React.useRef(new Map).current,presentChildren=React.useRef(childrenToRender),allChildren=React.useRef(new Map).current,isInitialRender=React.useRef(!0);useIsomorphicLayoutEffect(()=>{isInitialRender.current=!1;updateChildLookup(filteredChildren,allChildren);presentChildren.current=childrenToRender});
useUnmountEffect(()=>{isInitialRender.current=!0;allChildren.clear();exitingChildren.clear()});if(isInitialRender.current)return React__namespace.createElement(React__namespace.Fragment,null,childrenToRender.map(child=>React__namespace.createElement(PresenceChild,{key:child.key||"",isPresent:!0,initial:initial?void 0:!1,presenceAffectsLayout,mode},child)));childrenToRender=[...childrenToRender];const presentKeys=presentChildren.current.map(getChildKey),targetKeys=filteredChildren.map(getChildKey);
children=presentKeys.length;for(exitBeforeEnter=0;exitBeforeEnter<children;exitBeforeEnter++){const key=presentKeys[exitBeforeEnter];-1!==targetKeys.indexOf(key)||exitingChildren.has(key)||exitingChildren.set(key,void 0)}"wait"===mode&&exitingChildren.size&&(childrenToRender=[]);exitingChildren.forEach((component,key)=>{if(-1===targetKeys.indexOf(key)){var child=allChildren.get(key);if(child){var insertionIndex=presentKeys.indexOf(key);component||(component=React__namespace.createElement(PresenceChild,
{key:child.key||"",isPresent:!1,onExitComplete:()=>{exitingChildren.delete(key);const leftOverKeys=Array.from(allChildren.keys()).filter(childKey=>!targetKeys.includes(childKey));leftOverKeys.forEach(leftOverKey=>allChildren.delete(leftOverKey));presentChildren.current=filteredChildren.filter(presentChild=>{presentChild=presentChild.key||"";return presentChild===key||leftOverKeys.includes(presentChild)});exitingChildren.size||!1===isMounted.current||(forceRender(),onExitComplete&&onExitComplete())},
custom,presenceAffectsLayout,mode},child),exitingChildren.set(key,component));childrenToRender.splice(insertionIndex,0,component)}}});childrenToRender=childrenToRender.map(child=>exitingChildren.has(child.key)?child:React__namespace.createElement(PresenceChild,{key:child.key||"",isPresent:!0,presenceAffectsLayout,mode},child));"wait"===mode&&1<childrenToRender.length&&console.warn('You\'re attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.');
return React__namespace.createElement(React__namespace.Fragment,null,exitingChildren.size?childrenToRender:childrenToRender.map(child=>React.cloneElement(child)))};exports.AnimateSharedLayout=({children})=>{React__namespace.useEffect(()=>{indexLegacy.invariant(!1,"AnimateSharedLayout is deprecated: https://www.framer.com/docs/guide-upgrade/##shared-layout-animations")},[]);return React__namespace.createElement(LayoutGroup,{id:useConstant(()=>`asl-${id$jscomp$0++}`)},children)};exports.DeprecatedLayoutGroupContext=
DeprecatedLayoutGroupContext;exports.DragControls=DragControls;exports.FlatTree=FlatTree;exports.LayoutGroup=LayoutGroup;exports.LayoutGroupContext=LayoutGroupContext;exports.LazyMotion=function({children,features,strict=!1}){const [,setIsLoaded]=React.useState(!isLazyBundle(features)),loadedRenderer=React.useRef(void 0);if(!isLazyBundle(features)){const {renderer,...loadedFeatures}=features;loadedRenderer.current=renderer;loadFeatures(loadedFeatures)}React.useEffect(()=>{isLazyBundle(features)&&
features().then(({renderer,...loadedFeatures})=>{loadFeatures(loadedFeatures);loadedRenderer.current=renderer;setIsLoaded(!0)})},[]);return React__namespace.createElement(LazyContext.Provider,{value:{renderer:loadedRenderer.current,strict}},children)};exports.MotionConfig=function({children,isValidProp,...config}){isValidProp&&loadExternalIsValidProp(isValidProp);config={...React.useContext(MotionConfigContext),...config};config.isStatic=useConstant(()=>config.isStatic);isValidProp=React.useMemo(()=>
config,[JSON.stringify(config.transition),config.transformPagePoint,config.reducedMotion]);return React__namespace.createElement(MotionConfigContext.Provider,{value:isValidProp},children)};exports.MotionConfigContext=MotionConfigContext;exports.MotionContext=MotionContext;exports.PresenceContext=PresenceContext;exports.Reorder=Reorder;exports.SwitchLayoutGroupContext=SwitchLayoutGroupContext;exports.addPointerEvent=addPointerEvent;exports.addPointerInfo=addPointerInfo;exports.animateVisualElement=
animateVisualElement;exports.animationControls=animationControls;exports.animations=animations$jscomp$0;exports.calcLength=calcLength;exports.createDomMotionComponent=function(key){return createMotionComponent(createDomMotionConfig(key,{forwardMotionProps:!1},preloadedFeatures$jscomp$0,createDomVisualElement))};exports.createMotionComponent=createMotionComponent;exports.disableInstantTransitions=function(){indexLegacy.instantAnimationState.current=!1};exports.domAnimation=domAnimation;exports.domMax=
domMax;exports.filterProps=filterProps;exports.isDragActive=isDragActive;exports.isMotionComponent=isMotionComponent;exports.isValidMotionProp=isValidMotionProp;exports.m=m;exports.makeUseVisualState=makeUseVisualState;exports.motion=motion;exports.resolveMotionValue=resolveMotionValue;exports.startOptimizedAppearAnimation=function(element,name,keyframes,options,onReady){if(window.HandoffComplete)window.HandoffAppearAnimations=void 0;else{var id=element.dataset[indexLegacy.optimizedAppearDataId];
if(id){window.HandoffAppearAnimations=handoffOptimizedAppearAnimation;var storeId=`${id}: ${name}`;readyAnimation||(readyAnimation=indexLegacy.animateStyle(element,name,[keyframes[0],keyframes[0]],{duration:1E4,ease:"linear"}),appearAnimationStore.set(storeId,{animation:readyAnimation,startTime:null}));id=()=>{readyAnimation.cancel();const appearAnimation=indexLegacy.animateStyle(element,name,keyframes,options);void 0===startFrameTime&&(startFrameTime=performance.now());appearAnimation.startTime=
startFrameTime;appearAnimationStore.set(storeId,{animation:appearAnimation,startTime:startFrameTime});onReady&&onReady(appearAnimation)};readyAnimation.ready?readyAnimation.ready.then(id).catch(indexLegacy.noop):id()}}};exports.unwrapMotionComponent=function(component){if(isMotionComponent(component))return component[motionComponentSymbol]};exports.useAnimate=function(){const scope=useConstant(()=>({current:null,animations:[]})),animate=useConstant(()=>indexLegacy.createScopedAnimate(scope));useUnmountEffect(()=>
{scope.animations.forEach(animation=>animation.stop())});return[scope,animate]};exports.useAnimation=useAnimationControls;exports.useAnimationControls=useAnimationControls;exports.useAnimationFrame=useAnimationFrame;exports.useCycle=function(...items){const index=React.useRef(0),[item,setItem]=React.useState(items[index.current]),runCycle=React.useCallback(next=>{index.current="number"!==typeof next?indexLegacy.wrap(0,items.length,index.current+1):next;setItem(items[index.current])},[items.length,
...items]);return[item,runCycle]};exports.useDeprecatedAnimatedState=function(initialState){const [animationState,setAnimationState]=React.useState(initialState),visualState=useVisualState({},!1),element=useConstant(()=>new StateVisualElement({props:{},visualState,presenceContext:null},{initialState}));React.useEffect(()=>{element.mount({});return()=>element.unmount()},[element]);React.useEffect(()=>{element.update({onUpdate:v=>{setAnimationState({...v})}},null)},[setAnimationState,element]);const startAnimation=
useConstant(()=>animationDefinition=>animateVisualElement(element,animationDefinition));return[animationState,startAnimation]};exports.useDeprecatedInvertedScale=function(scale){let parentScaleX=useMotionValue(1);var parentScaleY=useMotionValue(1);const {visualElement}=React.useContext(MotionContext);indexLegacy.invariant(!(!scale&&!visualElement),"If no scale values are provided, useInvertedScale must be used within a child of another motion component.");indexLegacy.warning(hasWarned,"useInvertedScale is deprecated and will be removed in 3.0. Use the layout prop instead.");
hasWarned=!0;scale?(parentScaleX=scale.scaleX||parentScaleX,parentScaleY=scale.scaleY||parentScaleY):visualElement&&(parentScaleX=visualElement.getValue("scaleX",1),parentScaleY=visualElement.getValue("scaleY",1));scale=useTransform(parentScaleX,invertScale);parentScaleY=useTransform(parentScaleY,invertScale);return{scaleX:scale,scaleY:parentScaleY}};exports.useDomEvent=function(ref,eventName,handler,options){React.useEffect(()=>{const element=ref.current;if(handler&&element)return addDomEvent(element,
eventName,handler,options)},[ref,eventName,handler,options])};exports.useDragControls=function(){return useConstant(createDragControls)};exports.useElementScroll=function(ref){indexLegacy.warnOnce(!1,"useElementScroll is deprecated. Convert to useScroll({ container: ref }).");return useScroll({container:ref})};exports.useForceUpdate=useForceUpdate;exports.useInView=function(ref,{root,margin,amount,once=!1}={}){const [isInView,setInView]=React.useState(!1);React.useEffect(()=>{if(!(!ref.current||once&&
isInView))return indexLegacy.inView(ref.current,()=>{setInView(!0);return once?void 0:()=>setInView(!1)},{root:root&&root.current||void 0,margin,amount})},[root,ref,margin,once,amount]);return isInView};exports.useInstantLayoutTransition=function(){return startTransition};exports.useInstantTransition=function(){const [forceUpdate,forcedRenderCount]=useForceUpdate(),unlockOnFrameRef=React.useRef();React.useEffect(()=>{indexLegacy.frame.postRender(()=>indexLegacy.frame.postRender(()=>{forcedRenderCount===
unlockOnFrameRef.current&&(indexLegacy.instantAnimationState.current=!1)}))},[forcedRenderCount]);return callback=>{startTransition(()=>{indexLegacy.instantAnimationState.current=!0;forceUpdate();callback();unlockOnFrameRef.current=forcedRenderCount+1})}};exports.useIsPresent=function(){var context=React.useContext(PresenceContext);return null===context?!0:context.isPresent};exports.useIsomorphicLayoutEffect=useIsomorphicLayoutEffect;exports.useMotionTemplate=function(fragments,...values){const numFragments=
fragments.length;return useCombineMotionValues(values.filter(indexLegacy.isMotionValue),function(){let output="";for(let i=0;i<numFragments;i++){output+=fragments[i];const value=values[i];value&&(output+=indexLegacy.isMotionValue(value)?value.get():value)}return output})};exports.useMotionValue=useMotionValue;exports.useMotionValueEvent=useMotionValueEvent;exports.usePresence=usePresence;exports.useReducedMotion=useReducedMotion;exports.useReducedMotionConfig=function(){const reducedMotionPreference=
useReducedMotion(),{reducedMotion}=React.useContext(MotionConfigContext);return"never"===reducedMotion?!1:"always"===reducedMotion?!0:reducedMotionPreference};exports.useResetProjection=function(){return React__namespace.useCallback(()=>{const root=rootProjectionNode.current;root&&root.resetTree()},[])};exports.useScroll=useScroll;exports.useSpring=function(source,config={}){const {isStatic}=React.useContext(MotionConfigContext),activeSpringAnimation=React.useRef(null),value=useMotionValue(indexLegacy.isMotionValue(source)?
source.get():source),stopAnimation=()=>{activeSpringAnimation.current&&activeSpringAnimation.current.stop()};React.useInsertionEffect(()=>value.attach((v,set)=>{if(isStatic)return set(v);stopAnimation();activeSpringAnimation.current=indexLegacy.animateValue({keyframes:[value.get(),v],velocity:value.getVelocity(),type:"spring",restDelta:.001,restSpeed:.01,...config,onUpdate:set});indexLegacy.frameData.isProcessing||(v=performance.now()-indexLegacy.frameData.timestamp,30>v&&(activeSpringAnimation.current.time=
indexLegacy.millisecondsToSeconds(v)));return value.get()},stopAnimation),[JSON.stringify(config)]);useIsomorphicLayoutEffect(()=>{if(indexLegacy.isMotionValue(source))return source.on("change",v=>value.set(parseFloat(v)))},[value]);return value};exports.useTime=function(){const time=useMotionValue(0);useAnimationFrame(t=>time.set(t));return time};exports.useTransform=useTransform;exports.useUnmountEffect=useUnmountEffect;exports.useVelocity=function(value){const velocity=useMotionValue(value.getVelocity());
useMotionValueEvent(value,"velocityChange",newVelocity=>{velocity.set(newVelocity)});return velocity};exports.useViewportScroll=function(){indexLegacy.warnOnce(!1,"useViewportScroll is deprecated. Convert to useScroll().");return useScroll()};exports.useWillChange=function(){return useConstant(()=>new WillChangeMotionValue("auto"))}}
//# sourceMappingURL=module$node_modules$framer_motion$dist$cjs$index.js.map
