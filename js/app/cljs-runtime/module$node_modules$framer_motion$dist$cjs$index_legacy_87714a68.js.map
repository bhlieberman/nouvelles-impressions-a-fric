{
"version":3,
"file":"module$node_modules$framer_motion$dist$cjs$index_legacy_87714a68.js",
"lineCount":192,
"mappings":"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",
"sources":["node_modules/framer-motion/dist/cjs/index-legacy-87714a68.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$framer_motion$dist$cjs$index_legacy_87714a68\"] = function(global,require,module,exports) {\n'use strict';\n\nconst isBrowser = typeof document !== \"undefined\";\n\n/**\n * Convert camelCase to dash-case properties.\n */\nconst camelToDash = (str) => str.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\n\nconst optimizedAppearDataId = \"framerAppearId\";\nconst optimizedAppearDataAttribute = \"data-\" + camelToDash(optimizedAppearDataId);\n\nfunction isRefObject(ref) {\n    return (ref &&\n        typeof ref === \"object\" &&\n        Object.prototype.hasOwnProperty.call(ref, \"current\"));\n}\n\n/**\n * Decides if the supplied variable is variant label\n */\nfunction isVariantLabel(v) {\n    return typeof v === \"string\" || Array.isArray(v);\n}\n\nfunction isAnimationControls(v) {\n    return (v !== null &&\n        typeof v === \"object\" &&\n        typeof v.start === \"function\");\n}\n\nconst variantPriorityOrder = [\n    \"animate\",\n    \"whileInView\",\n    \"whileFocus\",\n    \"whileHover\",\n    \"whileTap\",\n    \"whileDrag\",\n    \"exit\",\n];\nconst variantProps = [\"initial\", ...variantPriorityOrder];\n\nfunction isControllingVariants(props) {\n    return (isAnimationControls(props.animate) ||\n        variantProps.some((name) => isVariantLabel(props[name])));\n}\nfunction isVariantNode(props) {\n    return Boolean(isControllingVariants(props) || props.variants);\n}\n\nconst featureProps = {\n    animation: [\n        \"animate\",\n        \"variants\",\n        \"whileHover\",\n        \"whileTap\",\n        \"exit\",\n        \"whileInView\",\n        \"whileFocus\",\n        \"whileDrag\",\n    ],\n    exit: [\"exit\"],\n    drag: [\"drag\", \"dragControls\"],\n    focus: [\"whileFocus\"],\n    hover: [\"whileHover\", \"onHoverStart\", \"onHoverEnd\"],\n    tap: [\"whileTap\", \"onTap\", \"onTapStart\", \"onTapCancel\"],\n    pan: [\"onPan\", \"onPanStart\", \"onPanSessionStart\", \"onPanEnd\"],\n    inView: [\"whileInView\", \"onViewportEnter\", \"onViewportLeave\"],\n    layout: [\"layout\", \"layoutId\"],\n};\nconst featureDefinitions = {};\nfor (const key in featureProps) {\n    featureDefinitions[key] = {\n        isEnabled: (props) => featureProps[key].some((name) => !!props[name]),\n    };\n}\n\nconst scaleCorrectors = {};\nfunction addScaleCorrector(correctors) {\n    Object.assign(scaleCorrectors, correctors);\n}\n\n/**\n * Generate a list of every possible transform key.\n */\nconst transformPropOrder = [\n    \"transformPerspective\",\n    \"x\",\n    \"y\",\n    \"z\",\n    \"translateX\",\n    \"translateY\",\n    \"translateZ\",\n    \"scale\",\n    \"scaleX\",\n    \"scaleY\",\n    \"rotate\",\n    \"rotateX\",\n    \"rotateY\",\n    \"rotateZ\",\n    \"skew\",\n    \"skewX\",\n    \"skewY\",\n];\n/**\n * A quick lookup for transform props.\n */\nconst transformProps = new Set(transformPropOrder);\n\nfunction isForcedMotionValue(key, { layout, layoutId }) {\n    return (transformProps.has(key) ||\n        key.startsWith(\"origin\") ||\n        ((layout || layoutId !== undefined) &&\n            (!!scaleCorrectors[key] || key === \"opacity\")));\n}\n\nconst isMotionValue = (value) => Boolean(value && value.getVelocity);\n\nconst translateAlias = {\n    x: \"translateX\",\n    y: \"translateY\",\n    z: \"translateZ\",\n    transformPerspective: \"perspective\",\n};\nconst numTransforms = transformPropOrder.length;\n/**\n * Build a CSS transform style from individual x/y/scale etc properties.\n *\n * This outputs with a default order of transforms/scales/rotations, this can be customised by\n * providing a transformTemplate function.\n */\nfunction buildTransform(transform, { enableHardwareAcceleration = true, allowTransformNone = true, }, transformIsDefault, transformTemplate) {\n    // The transform string we're going to build into.\n    let transformString = \"\";\n    /**\n     * Loop over all possible transforms in order, adding the ones that\n     * are present to the transform string.\n     */\n    for (let i = 0; i < numTransforms; i++) {\n        const key = transformPropOrder[i];\n        if (transform[key] !== undefined) {\n            const transformName = translateAlias[key] || key;\n            transformString += `${transformName}(${transform[key]}) `;\n        }\n    }\n    if (enableHardwareAcceleration && !transform.z) {\n        transformString += \"translateZ(0)\";\n    }\n    transformString = transformString.trim();\n    // If we have a custom `transform` template, pass our transform values and\n    // generated transformString to that before returning\n    if (transformTemplate) {\n        transformString = transformTemplate(transform, transformIsDefault ? \"\" : transformString);\n    }\n    else if (allowTransformNone && transformIsDefault) {\n        transformString = \"none\";\n    }\n    return transformString;\n}\n\nconst checkStringStartsWith = (token) => (key) => typeof key === \"string\" && key.startsWith(token);\nconst isCSSVariableName = checkStringStartsWith(\"--\");\nconst isCSSVariableToken = checkStringStartsWith(\"var(--\");\nconst cssVariableRegex = /var\\s*\\(\\s*--[\\w-]+(\\s*,\\s*(?:(?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)+)?\\s*\\)/g;\n\n/**\n * Provided a value and a ValueType, returns the value as that value type.\n */\nconst getValueAsType = (value, type) => {\n    return type && typeof value === \"number\"\n        ? type.transform(value)\n        : value;\n};\n\nconst clamp = (min, max, v) => Math.min(Math.max(v, min), max);\n\nconst number = {\n    test: (v) => typeof v === \"number\",\n    parse: parseFloat,\n    transform: (v) => v,\n};\nconst alpha = {\n    ...number,\n    transform: (v) => clamp(0, 1, v),\n};\nconst scale = {\n    ...number,\n    default: 1,\n};\n\n/**\n * TODO: When we move from string as a source of truth to data models\n * everything in this folder should probably be referred to as models vs types\n */\n// If this number is a decimal, make it just five decimal places\n// to avoid exponents\nconst sanitize = (v) => Math.round(v * 100000) / 100000;\nconst floatRegex = /(-)?([\\d]*\\.?[\\d])+/g;\nconst colorRegex = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\\((-?[\\d\\.]+%?[,\\s]+){2}(-?[\\d\\.]+%?)\\s*[\\,\\/]?\\s*[\\d\\.]*%?\\))/gi;\nconst singleColorRegex = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\\((-?[\\d\\.]+%?[,\\s]+){2}(-?[\\d\\.]+%?)\\s*[\\,\\/]?\\s*[\\d\\.]*%?\\))$/i;\nfunction isString(v) {\n    return typeof v === \"string\";\n}\n\nconst createUnitType = (unit) => ({\n    test: (v) => isString(v) && v.endsWith(unit) && v.split(\" \").length === 1,\n    parse: parseFloat,\n    transform: (v) => `${v}${unit}`,\n});\nconst degrees = createUnitType(\"deg\");\nconst percent = createUnitType(\"%\");\nconst px = createUnitType(\"px\");\nconst vh = createUnitType(\"vh\");\nconst vw = createUnitType(\"vw\");\nconst progressPercentage = {\n    ...percent,\n    parse: (v) => percent.parse(v) / 100,\n    transform: (v) => percent.transform(v * 100),\n};\n\nconst int = {\n    ...number,\n    transform: Math.round,\n};\n\nconst numberValueTypes = {\n    // Border props\n    borderWidth: px,\n    borderTopWidth: px,\n    borderRightWidth: px,\n    borderBottomWidth: px,\n    borderLeftWidth: px,\n    borderRadius: px,\n    radius: px,\n    borderTopLeftRadius: px,\n    borderTopRightRadius: px,\n    borderBottomRightRadius: px,\n    borderBottomLeftRadius: px,\n    // Positioning props\n    width: px,\n    maxWidth: px,\n    height: px,\n    maxHeight: px,\n    size: px,\n    top: px,\n    right: px,\n    bottom: px,\n    left: px,\n    // Spacing props\n    padding: px,\n    paddingTop: px,\n    paddingRight: px,\n    paddingBottom: px,\n    paddingLeft: px,\n    margin: px,\n    marginTop: px,\n    marginRight: px,\n    marginBottom: px,\n    marginLeft: px,\n    // Transform props\n    rotate: degrees,\n    rotateX: degrees,\n    rotateY: degrees,\n    rotateZ: degrees,\n    scale,\n    scaleX: scale,\n    scaleY: scale,\n    scaleZ: scale,\n    skew: degrees,\n    skewX: degrees,\n    skewY: degrees,\n    distance: px,\n    translateX: px,\n    translateY: px,\n    translateZ: px,\n    x: px,\n    y: px,\n    z: px,\n    perspective: px,\n    transformPerspective: px,\n    opacity: alpha,\n    originX: progressPercentage,\n    originY: progressPercentage,\n    originZ: px,\n    // Misc\n    zIndex: int,\n    // SVG\n    fillOpacity: alpha,\n    strokeOpacity: alpha,\n    numOctaves: int,\n};\n\nfunction buildHTMLStyles(state, latestValues, options, transformTemplate) {\n    const { style, vars, transform, transformOrigin } = state;\n    // Track whether we encounter any transform or transformOrigin values.\n    let hasTransform = false;\n    let hasTransformOrigin = false;\n    // Does the calculated transform essentially equal \"none\"?\n    let transformIsNone = true;\n    /**\n     * Loop over all our latest animated values and decide whether to handle them\n     * as a style or CSS variable.\n     *\n     * Transforms and transform origins are kept seperately for further processing.\n     */\n    for (const key in latestValues) {\n        const value = latestValues[key];\n        /**\n         * If this is a CSS variable we don't do any further processing.\n         */\n        if (isCSSVariableName(key)) {\n            vars[key] = value;\n            continue;\n        }\n        // Convert the value to its default value type, ie 0 -> \"0px\"\n        const valueType = numberValueTypes[key];\n        const valueAsType = getValueAsType(value, valueType);\n        if (transformProps.has(key)) {\n            // If this is a transform, flag to enable further transform processing\n            hasTransform = true;\n            transform[key] = valueAsType;\n            // If we already know we have a non-default transform, early return\n            if (!transformIsNone)\n                continue;\n            // Otherwise check to see if this is a default transform\n            if (value !== (valueType.default || 0))\n                transformIsNone = false;\n        }\n        else if (key.startsWith(\"origin\")) {\n            // If this is a transform origin, flag and enable further transform-origin processing\n            hasTransformOrigin = true;\n            transformOrigin[key] = valueAsType;\n        }\n        else {\n            style[key] = valueAsType;\n        }\n    }\n    if (!latestValues.transform) {\n        if (hasTransform || transformTemplate) {\n            style.transform = buildTransform(state.transform, options, transformIsNone, transformTemplate);\n        }\n        else if (style.transform) {\n            /**\n             * If we have previously created a transform but currently don't have any,\n             * reset transform style to none.\n             */\n            style.transform = \"none\";\n        }\n    }\n    /**\n     * Build a transformOrigin style. Uses the same defaults as the browser for\n     * undefined origins.\n     */\n    if (hasTransformOrigin) {\n        const { originX = \"50%\", originY = \"50%\", originZ = 0, } = transformOrigin;\n        style.transformOrigin = `${originX} ${originY} ${originZ}`;\n    }\n}\n\nfunction calcOrigin(origin, offset, size) {\n    return typeof origin === \"string\"\n        ? origin\n        : px.transform(offset + size * origin);\n}\n/**\n * The SVG transform origin defaults are different to CSS and is less intuitive,\n * so we use the measured dimensions of the SVG to reconcile these.\n */\nfunction calcSVGTransformOrigin(dimensions, originX, originY) {\n    const pxOriginX = calcOrigin(originX, dimensions.x, dimensions.width);\n    const pxOriginY = calcOrigin(originY, dimensions.y, dimensions.height);\n    return `${pxOriginX} ${pxOriginY}`;\n}\n\nconst dashKeys = {\n    offset: \"stroke-dashoffset\",\n    array: \"stroke-dasharray\",\n};\nconst camelKeys = {\n    offset: \"strokeDashoffset\",\n    array: \"strokeDasharray\",\n};\n/**\n * Build SVG path properties. Uses the path's measured length to convert\n * our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset\n * and stroke-dasharray attributes.\n *\n * This function is mutative to reduce per-frame GC.\n */\nfunction buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true) {\n    // Normalise path length by setting SVG attribute pathLength to 1\n    attrs.pathLength = 1;\n    // We use dash case when setting attributes directly to the DOM node and camel case\n    // when defining props on a React component.\n    const keys = useDashCase ? dashKeys : camelKeys;\n    // Build the dash offset\n    attrs[keys.offset] = px.transform(-offset);\n    // Build the dash array\n    const pathLength = px.transform(length);\n    const pathSpacing = px.transform(spacing);\n    attrs[keys.array] = `${pathLength} ${pathSpacing}`;\n}\n\n/**\n * Build SVG visual attrbutes, like cx and style.transform\n */\nfunction buildSVGAttrs(state, { attrX, attrY, attrScale, originX, originY, pathLength, pathSpacing = 1, pathOffset = 0, \n// This is object creation, which we try to avoid per-frame.\n...latest }, options, isSVGTag, transformTemplate) {\n    buildHTMLStyles(state, latest, options, transformTemplate);\n    /**\n     * For svg tags we just want to make sure viewBox is animatable and treat all the styles\n     * as normal HTML tags.\n     */\n    if (isSVGTag) {\n        if (state.style.viewBox) {\n            state.attrs.viewBox = state.style.viewBox;\n        }\n        return;\n    }\n    state.attrs = state.style;\n    state.style = {};\n    const { attrs, style, dimensions } = state;\n    /**\n     * However, we apply transforms as CSS transforms. So if we detect a transform we take it from attrs\n     * and copy it into style.\n     */\n    if (attrs.transform) {\n        if (dimensions)\n            style.transform = attrs.transform;\n        delete attrs.transform;\n    }\n    // Parse transformOrigin\n    if (dimensions &&\n        (originX !== undefined || originY !== undefined || style.transform)) {\n        style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== undefined ? originX : 0.5, originY !== undefined ? originY : 0.5);\n    }\n    // Render attrX/attrY/attrScale as attributes\n    if (attrX !== undefined)\n        attrs.x = attrX;\n    if (attrY !== undefined)\n        attrs.y = attrY;\n    if (attrScale !== undefined)\n        attrs.scale = attrScale;\n    // Build SVG path if one has been defined\n    if (pathLength !== undefined) {\n        buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);\n    }\n}\n\nconst isSVGTag = (tag) => typeof tag === \"string\" && tag.toLowerCase() === \"svg\";\n\nfunction renderHTML(element, { style, vars }, styleProp, projection) {\n    Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));\n    // Loop over any CSS variables and assign those.\n    for (const key in vars) {\n        element.style.setProperty(key, vars[key]);\n    }\n}\n\n/**\n * A set of attribute names that are always read/written as camel case.\n */\nconst camelCaseAttributes = new Set([\n    \"baseFrequency\",\n    \"diffuseConstant\",\n    \"kernelMatrix\",\n    \"kernelUnitLength\",\n    \"keySplines\",\n    \"keyTimes\",\n    \"limitingConeAngle\",\n    \"markerHeight\",\n    \"markerWidth\",\n    \"numOctaves\",\n    \"targetX\",\n    \"targetY\",\n    \"surfaceScale\",\n    \"specularConstant\",\n    \"specularExponent\",\n    \"stdDeviation\",\n    \"tableValues\",\n    \"viewBox\",\n    \"gradientTransform\",\n    \"pathLength\",\n    \"startOffset\",\n    \"textLength\",\n    \"lengthAdjust\",\n]);\n\nfunction renderSVG(element, renderState, _styleProp, projection) {\n    renderHTML(element, renderState, undefined, projection);\n    for (const key in renderState.attrs) {\n        element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);\n    }\n}\n\nfunction scrapeMotionValuesFromProps$1(props, prevProps) {\n    const { style } = props;\n    const newValues = {};\n    for (const key in style) {\n        if (isMotionValue(style[key]) ||\n            (prevProps.style && isMotionValue(prevProps.style[key])) ||\n            isForcedMotionValue(key, props)) {\n            newValues[key] = style[key];\n        }\n    }\n    return newValues;\n}\n\nfunction scrapeMotionValuesFromProps(props, prevProps) {\n    const newValues = scrapeMotionValuesFromProps$1(props, prevProps);\n    for (const key in props) {\n        if (isMotionValue(props[key]) || isMotionValue(prevProps[key])) {\n            const targetKey = transformPropOrder.indexOf(key) !== -1\n                ? \"attr\" + key.charAt(0).toUpperCase() + key.substring(1)\n                : key;\n            newValues[targetKey] = props[key];\n        }\n    }\n    return newValues;\n}\n\nfunction resolveVariantFromProps(props, definition, custom, currentValues = {}, currentVelocity = {}) {\n    /**\n     * If the variant definition is a function, resolve.\n     */\n    if (typeof definition === \"function\") {\n        definition = definition(custom !== undefined ? custom : props.custom, currentValues, currentVelocity);\n    }\n    /**\n     * If the variant definition is a variant label, or\n     * the function returned a variant label, resolve.\n     */\n    if (typeof definition === \"string\") {\n        definition = props.variants && props.variants[definition];\n    }\n    /**\n     * At this point we've resolved both functions and variant labels,\n     * but the resolved variant label might itself have been a function.\n     * If so, resolve. This can only have returned a valid target object.\n     */\n    if (typeof definition === \"function\") {\n        definition = definition(custom !== undefined ? custom : props.custom, currentValues, currentVelocity);\n    }\n    return definition;\n}\n\nconst isKeyframesTarget = (v) => {\n    return Array.isArray(v);\n};\n\nconst isCustomValue = (v) => {\n    return Boolean(v && typeof v === \"object\" && v.mix && v.toValue);\n};\nconst resolveFinalValueInKeyframes = (v) => {\n    // TODO maybe throw if v.length - 1 is placeholder token?\n    return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;\n};\n\nconst noop = (any) => any;\n\nclass Queue {\n    constructor() {\n        this.order = [];\n        this.scheduled = new Set();\n    }\n    add(process) {\n        if (!this.scheduled.has(process)) {\n            this.scheduled.add(process);\n            this.order.push(process);\n            return true;\n        }\n    }\n    remove(process) {\n        const index = this.order.indexOf(process);\n        if (index !== -1) {\n            this.order.splice(index, 1);\n            this.scheduled.delete(process);\n        }\n    }\n    clear() {\n        this.order.length = 0;\n        this.scheduled.clear();\n    }\n}\nfunction createRenderStep(runNextFrame) {\n    /**\n     * We create and reuse two queues, one to queue jobs for the current frame\n     * and one for the next. We reuse to avoid triggering GC after x frames.\n     */\n    let thisFrame = new Queue();\n    let nextFrame = new Queue();\n    let numToRun = 0;\n    /**\n     * Track whether we're currently processing jobs in this step. This way\n     * we can decide whether to schedule new jobs for this frame or next.\n     */\n    let isProcessing = false;\n    let flushNextFrame = false;\n    /**\n     * A set of processes which were marked keepAlive when scheduled.\n     */\n    const toKeepAlive = new WeakSet();\n    const step = {\n        /**\n         * Schedule a process to run on the next frame.\n         */\n        schedule: (callback, keepAlive = false, immediate = false) => {\n            const addToCurrentFrame = immediate && isProcessing;\n            const queue = addToCurrentFrame ? thisFrame : nextFrame;\n            if (keepAlive)\n                toKeepAlive.add(callback);\n            if (queue.add(callback) && addToCurrentFrame && isProcessing) {\n                // If we're adding it to the currently running queue, update its measured size\n                numToRun = thisFrame.order.length;\n            }\n            return callback;\n        },\n        /**\n         * Cancel the provided callback from running on the next frame.\n         */\n        cancel: (callback) => {\n            nextFrame.remove(callback);\n            toKeepAlive.delete(callback);\n        },\n        /**\n         * Execute all schedule callbacks.\n         */\n        process: (frameData) => {\n            /**\n             * If we're already processing we've probably been triggered by a flushSync\n             * inside an existing process. Instead of executing, mark flushNextFrame\n             * as true and ensure we flush the following frame at the end of this one.\n             */\n            if (isProcessing) {\n                flushNextFrame = true;\n                return;\n            }\n            isProcessing = true;\n            [thisFrame, nextFrame] = [nextFrame, thisFrame];\n            // Clear the next frame queue\n            nextFrame.clear();\n            // Execute this frame\n            numToRun = thisFrame.order.length;\n            if (numToRun) {\n                for (let i = 0; i < numToRun; i++) {\n                    const callback = thisFrame.order[i];\n                    callback(frameData);\n                    if (toKeepAlive.has(callback)) {\n                        step.schedule(callback);\n                        runNextFrame();\n                    }\n                }\n            }\n            isProcessing = false;\n            if (flushNextFrame) {\n                flushNextFrame = false;\n                step.process(frameData);\n            }\n        },\n    };\n    return step;\n}\n\nconst stepsOrder = [\n    \"prepare\",\n    \"read\",\n    \"update\",\n    \"preRender\",\n    \"render\",\n    \"postRender\",\n];\nconst maxElapsed$1 = 40;\nfunction createRenderBatcher(scheduleNextBatch, allowKeepAlive) {\n    let runNextFrame = false;\n    let useDefaultElapsed = true;\n    const state = {\n        delta: 0,\n        timestamp: 0,\n        isProcessing: false,\n    };\n    const steps = stepsOrder.reduce((acc, key) => {\n        acc[key] = createRenderStep(() => (runNextFrame = true));\n        return acc;\n    }, {});\n    const processStep = (stepId) => steps[stepId].process(state);\n    const processBatch = () => {\n        const timestamp = performance.now();\n        runNextFrame = false;\n        state.delta = useDefaultElapsed\n            ? 1000 / 60\n            : Math.max(Math.min(timestamp - state.timestamp, maxElapsed$1), 1);\n        state.timestamp = timestamp;\n        state.isProcessing = true;\n        stepsOrder.forEach(processStep);\n        state.isProcessing = false;\n        if (runNextFrame && allowKeepAlive) {\n            useDefaultElapsed = false;\n            scheduleNextBatch(processBatch);\n        }\n    };\n    const wake = () => {\n        runNextFrame = true;\n        useDefaultElapsed = true;\n        if (!state.isProcessing) {\n            scheduleNextBatch(processBatch);\n        }\n    };\n    const schedule = stepsOrder.reduce((acc, key) => {\n        const step = steps[key];\n        acc[key] = (process, keepAlive = false, immediate = false) => {\n            if (!runNextFrame)\n                wake();\n            return step.schedule(process, keepAlive, immediate);\n        };\n        return acc;\n    }, {});\n    const cancel = (process) => stepsOrder.forEach((key) => steps[key].cancel(process));\n    return { schedule, cancel, state, steps };\n}\n\nconst { schedule: frame, cancel: cancelFrame, state: frameData, steps, } = createRenderBatcher(typeof requestAnimationFrame !== \"undefined\" ? requestAnimationFrame : noop, true);\n\n/**\n * Pipe\n * Compose other transformers to run linearily\n * pipe(min(20), max(40))\n * @param  {...functions} transformers\n * @return {function}\n */\nconst combineFunctions = (a, b) => (v) => b(a(v));\nconst pipe = (...transformers) => transformers.reduce(combineFunctions);\n\n/**\n * Creates an object containing the latest state of every MotionValue on a VisualElement\n */\nfunction getCurrent(visualElement) {\n    const current = {};\n    visualElement.values.forEach((value, key) => (current[key] = value.get()));\n    return current;\n}\n/**\n * Creates an object containing the latest velocity of every MotionValue on a VisualElement\n */\nfunction getVelocity(visualElement) {\n    const velocity = {};\n    visualElement.values.forEach((value, key) => (velocity[key] = value.getVelocity()));\n    return velocity;\n}\nfunction resolveVariant(visualElement, definition, custom) {\n    const props = visualElement.getProps();\n    return resolveVariantFromProps(props, definition, custom !== undefined ? custom : props.custom, getCurrent(visualElement), getVelocity(visualElement));\n}\n\nexports.warning = noop;\nexports.invariant = noop;\nif (process.env.NODE_ENV !== \"production\") {\n    exports.warning = (check, message) => {\n        if (!check && typeof console !== \"undefined\") {\n            console.warn(message);\n        }\n    };\n    exports.invariant = (check, message) => {\n        if (!check) {\n            throw new Error(message);\n        }\n    };\n}\n\n/**\n * Converts seconds to milliseconds\n *\n * @param seconds - Time in seconds.\n * @return milliseconds - Converted time in milliseconds.\n */\nconst secondsToMilliseconds = (seconds) => seconds * 1000;\nconst millisecondsToSeconds = (milliseconds) => milliseconds / 1000;\n\nconst instantAnimationState = {\n    current: false,\n};\n\nconst isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === \"number\";\n\nfunction isWaapiSupportedEasing(easing) {\n    return Boolean(!easing ||\n        (typeof easing === \"string\" && supportedWaapiEasing[easing]) ||\n        isBezierDefinition(easing) ||\n        (Array.isArray(easing) && easing.every(isWaapiSupportedEasing)));\n}\nconst cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;\nconst supportedWaapiEasing = {\n    linear: \"linear\",\n    ease: \"ease\",\n    easeIn: \"ease-in\",\n    easeOut: \"ease-out\",\n    easeInOut: \"ease-in-out\",\n    circIn: cubicBezierAsString([0, 0.65, 0.55, 1]),\n    circOut: cubicBezierAsString([0.55, 0, 1, 0.45]),\n    backIn: cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),\n    backOut: cubicBezierAsString([0.33, 1.53, 0.69, 0.99]),\n};\nfunction mapEasingToNativeEasing(easing) {\n    if (!easing)\n        return undefined;\n    return isBezierDefinition(easing)\n        ? cubicBezierAsString(easing)\n        : Array.isArray(easing)\n            ? easing.map(mapEasingToNativeEasing)\n            : supportedWaapiEasing[easing];\n}\n\nfunction animateStyle(element, valueName, keyframes, { delay = 0, duration, repeat = 0, repeatType = \"loop\", ease, times, } = {}) {\n    const keyframeOptions = { [valueName]: keyframes };\n    if (times)\n        keyframeOptions.offset = times;\n    const easing = mapEasingToNativeEasing(ease);\n    /**\n     * If this is an easing array, apply to keyframes, not animation as a whole\n     */\n    if (Array.isArray(easing))\n        keyframeOptions.easing = easing;\n    return element.animate(keyframeOptions, {\n        delay,\n        duration,\n        easing: !Array.isArray(easing) ? easing : \"linear\",\n        fill: \"both\",\n        iterations: repeat + 1,\n        direction: repeatType === \"reverse\" ? \"alternate\" : \"normal\",\n    });\n}\n\nfunction getFinalKeyframe(keyframes, { repeat, repeatType = \"loop\" }) {\n    const index = repeat && repeatType !== \"loop\" && repeat % 2 === 1\n        ? 0\n        : keyframes.length - 1;\n    return keyframes[index];\n}\n\n/*\n  Bezier function generator\n  This has been modified from Ga\u00ebtan Renaudeau's BezierEasing\n  https://github.com/gre/bezier-easing/blob/master/src/index.js\n  https://github.com/gre/bezier-easing/blob/master/LICENSE\n  \n  I've removed the newtonRaphsonIterate algo because in benchmarking it\n  wasn't noticiably faster than binarySubdivision, indeed removing it\n  usually improved times, depending on the curve.\n  I also removed the lookup table, as for the added bundle size and loop we're\n  only cutting ~4 or so subdivision iterations. I bumped the max iterations up\n  to 12 to compensate and this still tended to be faster for no perceivable\n  loss in accuracy.\n  Usage\n    const easeOut = cubicBezier(.17,.67,.83,.67);\n    const x = easeOut(0.5); // returns 0.627...\n*/\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nconst calcBezier = (t, a1, a2) => (((1.0 - 3.0 * a2 + 3.0 * a1) * t + (3.0 * a2 - 6.0 * a1)) * t + 3.0 * a1) *\n    t;\nconst subdivisionPrecision = 0.0000001;\nconst subdivisionMaxIterations = 12;\nfunction binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {\n    let currentX;\n    let currentT;\n    let i = 0;\n    do {\n        currentT = lowerBound + (upperBound - lowerBound) / 2.0;\n        currentX = calcBezier(currentT, mX1, mX2) - x;\n        if (currentX > 0.0) {\n            upperBound = currentT;\n        }\n        else {\n            lowerBound = currentT;\n        }\n    } while (Math.abs(currentX) > subdivisionPrecision &&\n        ++i < subdivisionMaxIterations);\n    return currentT;\n}\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n    // If this is a linear gradient, return linear easing\n    if (mX1 === mY1 && mX2 === mY2)\n        return noop;\n    const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);\n    // If animation is at start/end, return t without easing\n    return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n}\n\nconst easeIn = cubicBezier(0.42, 0, 1, 1);\nconst easeOut = cubicBezier(0, 0, 0.58, 1);\nconst easeInOut = cubicBezier(0.42, 0, 0.58, 1);\n\nconst isEasingArray = (ease) => {\n    return Array.isArray(ease) && typeof ease[0] !== \"number\";\n};\n\n// Accepts an easing function and returns a new one that outputs mirrored values for\n// the second half of the animation. Turns easeIn into easeInOut.\nconst mirrorEasing = (easing) => (p) => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;\n\n// Accepts an easing function and returns a new one that outputs reversed values.\n// Turns easeIn into easeOut.\nconst reverseEasing = (easing) => (p) => 1 - easing(1 - p);\n\nconst circIn = (p) => 1 - Math.sin(Math.acos(p));\nconst circOut = reverseEasing(circIn);\nconst circInOut = mirrorEasing(circIn);\n\nconst backOut = cubicBezier(0.33, 1.53, 0.69, 0.99);\nconst backIn = reverseEasing(backOut);\nconst backInOut = mirrorEasing(backIn);\n\nconst anticipate = (p) => (p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));\n\nconst easingLookup = {\n    linear: noop,\n    easeIn,\n    easeInOut,\n    easeOut,\n    circIn,\n    circInOut,\n    circOut,\n    backIn,\n    backInOut,\n    backOut,\n    anticipate,\n};\nconst easingDefinitionToFunction = (definition) => {\n    if (Array.isArray(definition)) {\n        // If cubic bezier definition, create bezier curve\n        exports.invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);\n        const [x1, y1, x2, y2] = definition;\n        return cubicBezier(x1, y1, x2, y2);\n    }\n    else if (typeof definition === \"string\") {\n        // Else lookup from table\n        exports.invariant(easingLookup[definition] !== undefined, `Invalid easing type '${definition}'`);\n        return easingLookup[definition];\n    }\n    return definition;\n};\n\n/**\n * Returns true if the provided string is a color, ie rgba(0,0,0,0) or #000,\n * but false if a number or multiple colors\n */\nconst isColorString = (type, testProp) => (v) => {\n    return Boolean((isString(v) && singleColorRegex.test(v) && v.startsWith(type)) ||\n        (testProp && Object.prototype.hasOwnProperty.call(v, testProp)));\n};\nconst splitColor = (aName, bName, cName) => (v) => {\n    if (!isString(v))\n        return v;\n    const [a, b, c, alpha] = v.match(floatRegex);\n    return {\n        [aName]: parseFloat(a),\n        [bName]: parseFloat(b),\n        [cName]: parseFloat(c),\n        alpha: alpha !== undefined ? parseFloat(alpha) : 1,\n    };\n};\n\nconst clampRgbUnit = (v) => clamp(0, 255, v);\nconst rgbUnit = {\n    ...number,\n    transform: (v) => Math.round(clampRgbUnit(v)),\n};\nconst rgba = {\n    test: isColorString(\"rgb\", \"red\"),\n    parse: splitColor(\"red\", \"green\", \"blue\"),\n    transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => \"rgba(\" +\n        rgbUnit.transform(red) +\n        \", \" +\n        rgbUnit.transform(green) +\n        \", \" +\n        rgbUnit.transform(blue) +\n        \", \" +\n        sanitize(alpha.transform(alpha$1)) +\n        \")\",\n};\n\nfunction parseHex(v) {\n    let r = \"\";\n    let g = \"\";\n    let b = \"\";\n    let a = \"\";\n    // If we have 6 characters, ie #FF0000\n    if (v.length > 5) {\n        r = v.substring(1, 3);\n        g = v.substring(3, 5);\n        b = v.substring(5, 7);\n        a = v.substring(7, 9);\n        // Or we have 3 characters, ie #F00\n    }\n    else {\n        r = v.substring(1, 2);\n        g = v.substring(2, 3);\n        b = v.substring(3, 4);\n        a = v.substring(4, 5);\n        r += r;\n        g += g;\n        b += b;\n        a += a;\n    }\n    return {\n        red: parseInt(r, 16),\n        green: parseInt(g, 16),\n        blue: parseInt(b, 16),\n        alpha: a ? parseInt(a, 16) / 255 : 1,\n    };\n}\nconst hex = {\n    test: isColorString(\"#\"),\n    parse: parseHex,\n    transform: rgba.transform,\n};\n\nconst hsla = {\n    test: isColorString(\"hsl\", \"hue\"),\n    parse: splitColor(\"hue\", \"saturation\", \"lightness\"),\n    transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {\n        return (\"hsla(\" +\n            Math.round(hue) +\n            \", \" +\n            percent.transform(sanitize(saturation)) +\n            \", \" +\n            percent.transform(sanitize(lightness)) +\n            \", \" +\n            sanitize(alpha.transform(alpha$1)) +\n            \")\");\n    },\n};\n\nconst color = {\n    test: (v) => rgba.test(v) || hex.test(v) || hsla.test(v),\n    parse: (v) => {\n        if (rgba.test(v)) {\n            return rgba.parse(v);\n        }\n        else if (hsla.test(v)) {\n            return hsla.parse(v);\n        }\n        else {\n            return hex.parse(v);\n        }\n    },\n    transform: (v) => {\n        return isString(v)\n            ? v\n            : v.hasOwnProperty(\"red\")\n                ? rgba.transform(v)\n                : hsla.transform(v);\n    },\n};\n\n/*\n  Value in range from progress\n\n  Given a lower limit and an upper limit, we return the value within\n  that range as expressed by progress (usually a number from 0 to 1)\n\n  So progress = 0.5 would change\n\n  from -------- to\n\n  to\n\n  from ---- to\n\n  E.g. from = 10, to = 20, progress = 0.5 => 15\n\n  @param [number]: Lower limit of range\n  @param [number]: Upper limit of range\n  @param [number]: The progress between lower and upper limits expressed 0-1\n  @return [number]: Value as calculated from progress within range (not limited within range)\n*/\nconst mix = (from, to, progress) => -progress * from + progress * to + from;\n\n// Adapted from https://gist.github.com/mjackson/5311256\nfunction hueToRgb(p, q, t) {\n    if (t < 0)\n        t += 1;\n    if (t > 1)\n        t -= 1;\n    if (t < 1 / 6)\n        return p + (q - p) * 6 * t;\n    if (t < 1 / 2)\n        return q;\n    if (t < 2 / 3)\n        return p + (q - p) * (2 / 3 - t) * 6;\n    return p;\n}\nfunction hslaToRgba({ hue, saturation, lightness, alpha }) {\n    hue /= 360;\n    saturation /= 100;\n    lightness /= 100;\n    let red = 0;\n    let green = 0;\n    let blue = 0;\n    if (!saturation) {\n        red = green = blue = lightness;\n    }\n    else {\n        const q = lightness < 0.5\n            ? lightness * (1 + saturation)\n            : lightness + saturation - lightness * saturation;\n        const p = 2 * lightness - q;\n        red = hueToRgb(p, q, hue + 1 / 3);\n        green = hueToRgb(p, q, hue);\n        blue = hueToRgb(p, q, hue - 1 / 3);\n    }\n    return {\n        red: Math.round(red * 255),\n        green: Math.round(green * 255),\n        blue: Math.round(blue * 255),\n        alpha,\n    };\n}\n\n// Linear color space blending\n// Explained https://www.youtube.com/watch?v=LKnqECcg6Gw\n// Demonstrated http://codepen.io/osublake/pen/xGVVaN\nconst mixLinearColor = (from, to, v) => {\n    const fromExpo = from * from;\n    return Math.sqrt(Math.max(0, v * (to * to - fromExpo) + fromExpo));\n};\nconst colorTypes = [hex, rgba, hsla];\nconst getColorType = (v) => colorTypes.find((type) => type.test(v));\nfunction asRGBA(color) {\n    const type = getColorType(color);\n    exports.invariant(Boolean(type), `'${color}' is not an animatable color. Use the equivalent color code instead.`);\n    let model = type.parse(color);\n    if (type === hsla) {\n        // TODO Remove this cast - needed since Framer Motion's stricter typing\n        model = hslaToRgba(model);\n    }\n    return model;\n}\nconst mixColor = (from, to) => {\n    const fromRGBA = asRGBA(from);\n    const toRGBA = asRGBA(to);\n    const blended = { ...fromRGBA };\n    return (v) => {\n        blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);\n        blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);\n        blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);\n        blended.alpha = mix(fromRGBA.alpha, toRGBA.alpha, v);\n        return rgba.transform(blended);\n    };\n};\n\nfunction test(v) {\n    var _a, _b;\n    return (isNaN(v) &&\n        isString(v) &&\n        (((_a = v.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) || 0) +\n            (((_b = v.match(colorRegex)) === null || _b === void 0 ? void 0 : _b.length) || 0) >\n            0);\n}\nconst cssVarTokeniser = {\n    regex: cssVariableRegex,\n    countKey: \"Vars\",\n    token: \"${v}\",\n    parse: noop,\n};\nconst colorTokeniser = {\n    regex: colorRegex,\n    countKey: \"Colors\",\n    token: \"${c}\",\n    parse: color.parse,\n};\nconst numberTokeniser = {\n    regex: floatRegex,\n    countKey: \"Numbers\",\n    token: \"${n}\",\n    parse: number.parse,\n};\nfunction tokenise(info, { regex, countKey, token, parse }) {\n    const matches = info.tokenised.match(regex);\n    if (!matches)\n        return;\n    info[\"num\" + countKey] = matches.length;\n    info.tokenised = info.tokenised.replace(regex, token);\n    info.values.push(...matches.map(parse));\n}\nfunction analyseComplexValue(value) {\n    const originalValue = value.toString();\n    const info = {\n        value: originalValue,\n        tokenised: originalValue,\n        values: [],\n        numVars: 0,\n        numColors: 0,\n        numNumbers: 0,\n    };\n    if (info.value.includes(\"var(--\"))\n        tokenise(info, cssVarTokeniser);\n    tokenise(info, colorTokeniser);\n    tokenise(info, numberTokeniser);\n    return info;\n}\nfunction parseComplexValue(v) {\n    return analyseComplexValue(v).values;\n}\nfunction createTransformer(source) {\n    const { values, numColors, numVars, tokenised } = analyseComplexValue(source);\n    const numValues = values.length;\n    return (v) => {\n        let output = tokenised;\n        for (let i = 0; i < numValues; i++) {\n            if (i < numVars) {\n                output = output.replace(cssVarTokeniser.token, v[i]);\n            }\n            else if (i < numVars + numColors) {\n                output = output.replace(colorTokeniser.token, color.transform(v[i]));\n            }\n            else {\n                output = output.replace(numberTokeniser.token, sanitize(v[i]));\n            }\n        }\n        return output;\n    };\n}\nconst convertNumbersToZero = (v) => typeof v === \"number\" ? 0 : v;\nfunction getAnimatableNone$1(v) {\n    const parsed = parseComplexValue(v);\n    const transformer = createTransformer(v);\n    return transformer(parsed.map(convertNumbersToZero));\n}\nconst complex = {\n    test,\n    parse: parseComplexValue,\n    createTransformer,\n    getAnimatableNone: getAnimatableNone$1,\n};\n\nconst mixImmediate = (origin, target) => (p) => `${p > 0 ? target : origin}`;\nfunction getMixer$1(origin, target) {\n    if (typeof origin === \"number\") {\n        return (v) => mix(origin, target, v);\n    }\n    else if (color.test(origin)) {\n        return mixColor(origin, target);\n    }\n    else {\n        return origin.startsWith(\"var(\")\n            ? mixImmediate(origin, target)\n            : mixComplex(origin, target);\n    }\n}\nconst mixArray = (from, to) => {\n    const output = [...from];\n    const numValues = output.length;\n    const blendValue = from.map((fromThis, i) => getMixer$1(fromThis, to[i]));\n    return (v) => {\n        for (let i = 0; i < numValues; i++) {\n            output[i] = blendValue[i](v);\n        }\n        return output;\n    };\n};\nconst mixObject = (origin, target) => {\n    const output = { ...origin, ...target };\n    const blendValue = {};\n    for (const key in output) {\n        if (origin[key] !== undefined && target[key] !== undefined) {\n            blendValue[key] = getMixer$1(origin[key], target[key]);\n        }\n    }\n    return (v) => {\n        for (const key in blendValue) {\n            output[key] = blendValue[key](v);\n        }\n        return output;\n    };\n};\nconst mixComplex = (origin, target) => {\n    const template = complex.createTransformer(target);\n    const originStats = analyseComplexValue(origin);\n    const targetStats = analyseComplexValue(target);\n    const canInterpolate = originStats.numVars === targetStats.numVars &&\n        originStats.numColors === targetStats.numColors &&\n        originStats.numNumbers >= targetStats.numNumbers;\n    if (canInterpolate) {\n        return pipe(mixArray(originStats.values, targetStats.values), template);\n    }\n    else {\n        exports.warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);\n        return mixImmediate(origin, target);\n    }\n};\n\n/*\n  Progress within given range\n\n  Given a lower limit and an upper limit, we return the progress\n  (expressed as a number 0-1) represented by the given value, and\n  limit that progress to within 0-1.\n\n  @param [number]: Lower limit\n  @param [number]: Upper limit\n  @param [number]: Value to find progress within given range\n  @return [number]: Progress of value within range as expressed 0-1\n*/\nconst progress = (from, to, value) => {\n    const toFromDifference = to - from;\n    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;\n};\n\nconst mixNumber = (from, to) => (p) => mix(from, to, p);\nfunction detectMixerFactory(v) {\n    if (typeof v === \"number\") {\n        return mixNumber;\n    }\n    else if (typeof v === \"string\") {\n        return color.test(v) ? mixColor : mixComplex;\n    }\n    else if (Array.isArray(v)) {\n        return mixArray;\n    }\n    else if (typeof v === \"object\") {\n        return mixObject;\n    }\n    return mixNumber;\n}\nfunction createMixers(output, ease, customMixer) {\n    const mixers = [];\n    const mixerFactory = customMixer || detectMixerFactory(output[0]);\n    const numMixers = output.length - 1;\n    for (let i = 0; i < numMixers; i++) {\n        let mixer = mixerFactory(output[i], output[i + 1]);\n        if (ease) {\n            const easingFunction = Array.isArray(ease) ? ease[i] || noop : ease;\n            mixer = pipe(easingFunction, mixer);\n        }\n        mixers.push(mixer);\n    }\n    return mixers;\n}\n/**\n * Create a function that maps from a numerical input array to a generic output array.\n *\n * Accepts:\n *   - Numbers\n *   - Colors (hex, hsl, hsla, rgb, rgba)\n *   - Complex (combinations of one or more numbers or strings)\n *\n * ```jsx\n * const mixColor = interpolate([0, 1], ['#fff', '#000'])\n *\n * mixColor(0.5) // 'rgba(128, 128, 128, 1)'\n * ```\n *\n * TODO Revist this approach once we've moved to data models for values,\n * probably not needed to pregenerate mixer functions.\n *\n * @public\n */\nfunction interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {\n    const inputLength = input.length;\n    exports.invariant(inputLength === output.length, \"Both input and output ranges must be the same length\");\n    /**\n     * If we're only provided a single input, we can just make a function\n     * that returns the output.\n     */\n    if (inputLength === 1)\n        return () => output[0];\n    // If input runs highest -> lowest, reverse both arrays\n    if (input[0] > input[inputLength - 1]) {\n        input = [...input].reverse();\n        output = [...output].reverse();\n    }\n    const mixers = createMixers(output, ease, mixer);\n    const numMixers = mixers.length;\n    const interpolator = (v) => {\n        let i = 0;\n        if (numMixers > 1) {\n            for (; i < input.length - 2; i++) {\n                if (v < input[i + 1])\n                    break;\n            }\n        }\n        const progressInRange = progress(input[i], input[i + 1], v);\n        return mixers[i](progressInRange);\n    };\n    return isClamp\n        ? (v) => interpolator(clamp(input[0], input[inputLength - 1], v))\n        : interpolator;\n}\n\nfunction fillOffset(offset, remaining) {\n    const min = offset[offset.length - 1];\n    for (let i = 1; i <= remaining; i++) {\n        const offsetProgress = progress(0, remaining, i);\n        offset.push(mix(min, 1, offsetProgress));\n    }\n}\n\nfunction defaultOffset$1(arr) {\n    const offset = [0];\n    fillOffset(offset, arr.length - 1);\n    return offset;\n}\n\nfunction convertOffsetToTimes(offset, duration) {\n    return offset.map((o) => o * duration);\n}\n\nfunction defaultEasing(values, easing) {\n    return values.map(() => easing || easeInOut).splice(0, values.length - 1);\n}\nfunction keyframes({ duration = 300, keyframes: keyframeValues, times, ease = \"easeInOut\", }) {\n    /**\n     * Easing functions can be externally defined as strings. Here we convert them\n     * into actual functions.\n     */\n    const easingFunctions = isEasingArray(ease)\n        ? ease.map(easingDefinitionToFunction)\n        : easingDefinitionToFunction(ease);\n    /**\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n     * to reduce GC during animation.\n     */\n    const state = {\n        done: false,\n        value: keyframeValues[0],\n    };\n    /**\n     * Create a times array based on the provided 0-1 offsets\n     */\n    const absoluteTimes = convertOffsetToTimes(\n    // Only use the provided offsets if they're the correct length\n    // TODO Maybe we should warn here if there's a length mismatch\n    times && times.length === keyframeValues.length\n        ? times\n        : defaultOffset$1(keyframeValues), duration);\n    const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {\n        ease: Array.isArray(easingFunctions)\n            ? easingFunctions\n            : defaultEasing(keyframeValues, easingFunctions),\n    });\n    return {\n        calculatedDuration: duration,\n        next: (t) => {\n            state.value = mapTimeToKeyframe(t);\n            state.done = t >= duration;\n            return state;\n        },\n    };\n}\n\n/*\n  Convert velocity into velocity per second\n\n  @param [number]: Unit per frame\n  @param [number]: Frame duration in ms\n*/\nfunction velocityPerSecond(velocity, frameDuration) {\n    return frameDuration ? velocity * (1000 / frameDuration) : 0;\n}\n\nconst velocitySampleDuration = 5; // ms\nfunction calcGeneratorVelocity(resolveValue, t, current) {\n    const prevT = Math.max(t - velocitySampleDuration, 0);\n    return velocityPerSecond(current - resolveValue(prevT), t - prevT);\n}\n\nconst safeMin = 0.001;\nconst minDuration = 0.01;\nconst maxDuration$1 = 10.0;\nconst minDamping = 0.05;\nconst maxDamping = 1;\nfunction findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1, }) {\n    let envelope;\n    let derivative;\n    exports.warning(duration <= secondsToMilliseconds(maxDuration$1), \"Spring duration must be 10 seconds or less\");\n    let dampingRatio = 1 - bounce;\n    /**\n     * Restrict dampingRatio and duration to within acceptable ranges.\n     */\n    dampingRatio = clamp(minDamping, maxDamping, dampingRatio);\n    duration = clamp(minDuration, maxDuration$1, millisecondsToSeconds(duration));\n    if (dampingRatio < 1) {\n        /**\n         * Underdamped spring\n         */\n        envelope = (undampedFreq) => {\n            const exponentialDecay = undampedFreq * dampingRatio;\n            const delta = exponentialDecay * duration;\n            const a = exponentialDecay - velocity;\n            const b = calcAngularFreq(undampedFreq, dampingRatio);\n            const c = Math.exp(-delta);\n            return safeMin - (a / b) * c;\n        };\n        derivative = (undampedFreq) => {\n            const exponentialDecay = undampedFreq * dampingRatio;\n            const delta = exponentialDecay * duration;\n            const d = delta * velocity + velocity;\n            const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;\n            const f = Math.exp(-delta);\n            const g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio);\n            const factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1;\n            return (factor * ((d - e) * f)) / g;\n        };\n    }\n    else {\n        /**\n         * Critically-damped spring\n         */\n        envelope = (undampedFreq) => {\n            const a = Math.exp(-undampedFreq * duration);\n            const b = (undampedFreq - velocity) * duration + 1;\n            return -safeMin + a * b;\n        };\n        derivative = (undampedFreq) => {\n            const a = Math.exp(-undampedFreq * duration);\n            const b = (velocity - undampedFreq) * (duration * duration);\n            return a * b;\n        };\n    }\n    const initialGuess = 5 / duration;\n    const undampedFreq = approximateRoot(envelope, derivative, initialGuess);\n    duration = secondsToMilliseconds(duration);\n    if (isNaN(undampedFreq)) {\n        return {\n            stiffness: 100,\n            damping: 10,\n            duration,\n        };\n    }\n    else {\n        const stiffness = Math.pow(undampedFreq, 2) * mass;\n        return {\n            stiffness,\n            damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),\n            duration,\n        };\n    }\n}\nconst rootIterations = 12;\nfunction approximateRoot(envelope, derivative, initialGuess) {\n    let result = initialGuess;\n    for (let i = 1; i < rootIterations; i++) {\n        result = result - envelope(result) / derivative(result);\n    }\n    return result;\n}\nfunction calcAngularFreq(undampedFreq, dampingRatio) {\n    return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\n}\n\nconst durationKeys = [\"duration\", \"bounce\"];\nconst physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\nfunction isSpringType(options, keys) {\n    return keys.some((key) => options[key] !== undefined);\n}\nfunction getSpringOptions(options) {\n    let springOptions = {\n        velocity: 0.0,\n        stiffness: 100,\n        damping: 10,\n        mass: 1.0,\n        isResolvedFromDuration: false,\n        ...options,\n    };\n    // stiffness/damping/mass overrides duration/bounce\n    if (!isSpringType(options, physicsKeys) &&\n        isSpringType(options, durationKeys)) {\n        const derived = findSpring(options);\n        springOptions = {\n            ...springOptions,\n            ...derived,\n            mass: 1.0,\n        };\n        springOptions.isResolvedFromDuration = true;\n    }\n    return springOptions;\n}\nfunction spring({ keyframes, restDelta, restSpeed, ...options }) {\n    const origin = keyframes[0];\n    const target = keyframes[keyframes.length - 1];\n    /**\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n     * to reduce GC during animation.\n     */\n    const state = { done: false, value: origin };\n    const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration, } = getSpringOptions({\n        ...options,\n        velocity: -millisecondsToSeconds(options.velocity || 0),\n    });\n    const initialVelocity = velocity || 0.0;\n    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n    const initialDelta = target - origin;\n    const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));\n    /**\n     * If we're working on a granular scale, use smaller defaults for determining\n     * when the spring is finished.\n     *\n     * These defaults have been selected emprically based on what strikes a good\n     * ratio between feeling good and finishing as soon as changes are imperceptible.\n     */\n    const isGranularScale = Math.abs(initialDelta) < 5;\n    restSpeed || (restSpeed = isGranularScale ? 0.01 : 2);\n    restDelta || (restDelta = isGranularScale ? 0.005 : 0.5);\n    let resolveSpring;\n    if (dampingRatio < 1) {\n        const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n        // Underdamped spring\n        resolveSpring = (t) => {\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n            return (target -\n                envelope *\n                    (((initialVelocity +\n                        dampingRatio * undampedAngularFreq * initialDelta) /\n                        angularFreq) *\n                        Math.sin(angularFreq * t) +\n                        initialDelta * Math.cos(angularFreq * t)));\n        };\n    }\n    else if (dampingRatio === 1) {\n        // Critically damped spring\n        resolveSpring = (t) => target -\n            Math.exp(-undampedAngularFreq * t) *\n                (initialDelta +\n                    (initialVelocity + undampedAngularFreq * initialDelta) * t);\n    }\n    else {\n        // Overdamped spring\n        const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n        resolveSpring = (t) => {\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n            // When performing sinh or cosh values can hit Infinity so we cap them here\n            const freqForT = Math.min(dampedAngularFreq * t, 300);\n            return (target -\n                (envelope *\n                    ((initialVelocity +\n                        dampingRatio * undampedAngularFreq * initialDelta) *\n                        Math.sinh(freqForT) +\n                        dampedAngularFreq *\n                            initialDelta *\n                            Math.cosh(freqForT))) /\n                    dampedAngularFreq);\n        };\n    }\n    return {\n        calculatedDuration: isResolvedFromDuration ? duration || null : null,\n        next: (t) => {\n            const current = resolveSpring(t);\n            if (!isResolvedFromDuration) {\n                let currentVelocity = initialVelocity;\n                if (t !== 0) {\n                    /**\n                     * We only need to calculate velocity for under-damped springs\n                     * as over- and critically-damped springs can't overshoot, so\n                     * checking only for displacement is enough.\n                     */\n                    if (dampingRatio < 1) {\n                        currentVelocity = calcGeneratorVelocity(resolveSpring, t, current);\n                    }\n                    else {\n                        currentVelocity = 0;\n                    }\n                }\n                const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n                const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;\n                state.done =\n                    isBelowVelocityThreshold && isBelowDisplacementThreshold;\n            }\n            else {\n                state.done = t >= duration;\n            }\n            state.value = state.done ? target : current;\n            return state;\n        },\n    };\n}\n\nfunction inertia({ keyframes, velocity = 0.0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed, }) {\n    const origin = keyframes[0];\n    const state = {\n        done: false,\n        value: origin,\n    };\n    const isOutOfBounds = (v) => (min !== undefined && v < min) || (max !== undefined && v > max);\n    const nearestBoundary = (v) => {\n        if (min === undefined)\n            return max;\n        if (max === undefined)\n            return min;\n        return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n    };\n    let amplitude = power * velocity;\n    const ideal = origin + amplitude;\n    const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);\n    /**\n     * If the target has changed we need to re-calculate the amplitude, otherwise\n     * the animation will start from the wrong position.\n     */\n    if (target !== ideal)\n        amplitude = target - origin;\n    const calcDelta = (t) => -amplitude * Math.exp(-t / timeConstant);\n    const calcLatest = (t) => target + calcDelta(t);\n    const applyFriction = (t) => {\n        const delta = calcDelta(t);\n        const latest = calcLatest(t);\n        state.done = Math.abs(delta) <= restDelta;\n        state.value = state.done ? target : latest;\n    };\n    /**\n     * Ideally this would resolve for t in a stateless way, we could\n     * do that by always precalculating the animation but as we know\n     * this will be done anyway we can assume that spring will\n     * be discovered during that.\n     */\n    let timeReachedBoundary;\n    let spring$1;\n    const checkCatchBoundary = (t) => {\n        if (!isOutOfBounds(state.value))\n            return;\n        timeReachedBoundary = t;\n        spring$1 = spring({\n            keyframes: [state.value, nearestBoundary(state.value)],\n            velocity: calcGeneratorVelocity(calcLatest, t, state.value),\n            damping: bounceDamping,\n            stiffness: bounceStiffness,\n            restDelta,\n            restSpeed,\n        });\n    };\n    checkCatchBoundary(0);\n    return {\n        calculatedDuration: null,\n        next: (t) => {\n            /**\n             * We need to resolve the friction to figure out if we need a\n             * spring but we don't want to do this twice per frame. So here\n             * we flag if we updated for this frame and later if we did\n             * we can skip doing it again.\n             */\n            let hasUpdatedFrame = false;\n            if (!spring$1 && timeReachedBoundary === undefined) {\n                hasUpdatedFrame = true;\n                applyFriction(t);\n                checkCatchBoundary(t);\n            }\n            /**\n             * If we have a spring and the provided t is beyond the moment the friction\n             * animation crossed the min/max boundary, use the spring.\n             */\n            if (timeReachedBoundary !== undefined && t > timeReachedBoundary) {\n                return spring$1.next(t - timeReachedBoundary);\n            }\n            else {\n                !hasUpdatedFrame && applyFriction(t);\n                return state;\n            }\n        },\n    };\n}\n\nconst frameloopDriver = (update) => {\n    const passTimestamp = ({ timestamp }) => update(timestamp);\n    return {\n        start: () => frame.update(passTimestamp, true),\n        stop: () => cancelFrame(passTimestamp),\n        /**\n         * If we're processing this frame we can use the\n         * framelocked timestamp to keep things in sync.\n         */\n        now: () => frameData.isProcessing ? frameData.timestamp : performance.now(),\n    };\n};\n\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\nconst maxGeneratorDuration = 20000;\nfunction calcGeneratorDuration(generator) {\n    let duration = 0;\n    const timeStep = 50;\n    let state = generator.next(duration);\n    while (!state.done && duration < maxGeneratorDuration) {\n        duration += timeStep;\n        state = generator.next(duration);\n    }\n    return duration >= maxGeneratorDuration ? Infinity : duration;\n}\n\nconst types = {\n    decay: inertia,\n    inertia,\n    tween: keyframes,\n    keyframes: keyframes,\n    spring,\n};\n/**\n * Animate a single value on the main thread.\n *\n * This function is written, where functionality overlaps,\n * to be largely spec-compliant with WAAPI to allow fungibility\n * between the two.\n */\nfunction animateValue({ autoplay = true, delay = 0, driver = frameloopDriver, keyframes: keyframes$1, type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType = \"loop\", onPlay, onStop, onComplete, onUpdate, ...options }) {\n    let speed = 1;\n    let hasStopped = false;\n    let resolveFinishedPromise;\n    let currentFinishedPromise;\n    /**\n     * Resolve the current Promise every time we enter the\n     * finished state. This is WAAPI-compatible behaviour.\n     */\n    const updateFinishedPromise = () => {\n        currentFinishedPromise = new Promise((resolve) => {\n            resolveFinishedPromise = resolve;\n        });\n    };\n    // Create the first finished promise\n    updateFinishedPromise();\n    let animationDriver;\n    const generatorFactory = types[type] || keyframes;\n    /**\n     * If this isn't the keyframes generator and we've been provided\n     * strings as keyframes, we need to interpolate these.\n     */\n    let mapNumbersToKeyframes;\n    if (generatorFactory !== keyframes &&\n        typeof keyframes$1[0] !== \"number\") {\n        if (process.env.NODE_ENV !== \"production\") {\n            exports.invariant(keyframes$1.length === 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`);\n        }\n        mapNumbersToKeyframes = interpolate([0, 100], keyframes$1, {\n            clamp: false,\n        });\n        keyframes$1 = [0, 100];\n    }\n    const generator = generatorFactory({ ...options, keyframes: keyframes$1 });\n    let mirroredGenerator;\n    if (repeatType === \"mirror\") {\n        mirroredGenerator = generatorFactory({\n            ...options,\n            keyframes: [...keyframes$1].reverse(),\n            velocity: -(options.velocity || 0),\n        });\n    }\n    let playState = \"idle\";\n    let holdTime = null;\n    let startTime = null;\n    let cancelTime = null;\n    /**\n     * If duration is undefined and we have repeat options,\n     * we need to calculate a duration from the generator.\n     *\n     * We set it to the generator itself to cache the duration.\n     * Any timeline resolver will need to have already precalculated\n     * the duration by this step.\n     */\n    if (generator.calculatedDuration === null && repeat) {\n        generator.calculatedDuration = calcGeneratorDuration(generator);\n    }\n    const { calculatedDuration } = generator;\n    let resolvedDuration = Infinity;\n    let totalDuration = Infinity;\n    if (calculatedDuration !== null) {\n        resolvedDuration = calculatedDuration + repeatDelay;\n        totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;\n    }\n    let currentTime = 0;\n    const tick = (timestamp) => {\n        if (startTime === null)\n            return;\n        /**\n         * requestAnimationFrame timestamps can come through as lower than\n         * the startTime as set by performance.now(). Here we prevent this,\n         * though in the future it could be possible to make setting startTime\n         * a pending operation that gets resolved here.\n         */\n        if (speed > 0)\n            startTime = Math.min(startTime, timestamp);\n        if (speed < 0)\n            startTime = Math.min(timestamp - totalDuration / speed, startTime);\n        if (holdTime !== null) {\n            currentTime = holdTime;\n        }\n        else {\n            // Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =\n            // 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for\n            // example.\n            currentTime = Math.round(timestamp - startTime) * speed;\n        }\n        // Rebase on delay\n        const timeWithoutDelay = currentTime - delay * (speed >= 0 ? 1 : -1);\n        const isInDelayPhase = speed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;\n        currentTime = Math.max(timeWithoutDelay, 0);\n        /**\n         * If this animation has finished, set the current time\n         * to the total duration.\n         */\n        if (playState === \"finished\" && holdTime === null) {\n            currentTime = totalDuration;\n        }\n        let elapsed = currentTime;\n        let frameGenerator = generator;\n        if (repeat) {\n            /**\n             * Get the current progress (0-1) of the animation. If t is >\n             * than duration we'll get values like 2.5 (midway through the\n             * third iteration)\n             */\n            const progress = Math.min(currentTime, totalDuration) / resolvedDuration;\n            /**\n             * Get the current iteration (0 indexed). For instance the floor of\n             * 2.5 is 2.\n             */\n            let currentIteration = Math.floor(progress);\n            /**\n             * Get the current progress of the iteration by taking the remainder\n             * so 2.5 is 0.5 through iteration 2\n             */\n            let iterationProgress = progress % 1.0;\n            /**\n             * If iteration progress is 1 we count that as the end\n             * of the previous iteration.\n             */\n            if (!iterationProgress && progress >= 1) {\n                iterationProgress = 1;\n            }\n            iterationProgress === 1 && currentIteration--;\n            currentIteration = Math.min(currentIteration, repeat + 1);\n            /**\n             * Reverse progress if we're not running in \"normal\" direction\n             */\n            const isOddIteration = Boolean(currentIteration % 2);\n            if (isOddIteration) {\n                if (repeatType === \"reverse\") {\n                    iterationProgress = 1 - iterationProgress;\n                    if (repeatDelay) {\n                        iterationProgress -= repeatDelay / resolvedDuration;\n                    }\n                }\n                else if (repeatType === \"mirror\") {\n                    frameGenerator = mirroredGenerator;\n                }\n            }\n            elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;\n        }\n        /**\n         * If we're in negative time, set state as the initial keyframe.\n         * This prevents delay: x, duration: 0 animations from finishing\n         * instantly.\n         */\n        const state = isInDelayPhase\n            ? { done: false, value: keyframes$1[0] }\n            : frameGenerator.next(elapsed);\n        if (mapNumbersToKeyframes) {\n            state.value = mapNumbersToKeyframes(state.value);\n        }\n        let { done } = state;\n        if (!isInDelayPhase && calculatedDuration !== null) {\n            done = speed >= 0 ? currentTime >= totalDuration : currentTime <= 0;\n        }\n        const isAnimationFinished = holdTime === null &&\n            (playState === \"finished\" || (playState === \"running\" && done));\n        if (onUpdate) {\n            onUpdate(state.value);\n        }\n        if (isAnimationFinished) {\n            finish();\n        }\n        return state;\n    };\n    const stopAnimationDriver = () => {\n        animationDriver && animationDriver.stop();\n        animationDriver = undefined;\n    };\n    const cancel = () => {\n        playState = \"idle\";\n        stopAnimationDriver();\n        resolveFinishedPromise();\n        updateFinishedPromise();\n        startTime = cancelTime = null;\n    };\n    const finish = () => {\n        playState = \"finished\";\n        onComplete && onComplete();\n        stopAnimationDriver();\n        resolveFinishedPromise();\n    };\n    const play = () => {\n        if (hasStopped)\n            return;\n        if (!animationDriver)\n            animationDriver = driver(tick);\n        const now = animationDriver.now();\n        onPlay && onPlay();\n        if (holdTime !== null) {\n            startTime = now - holdTime;\n        }\n        else if (!startTime || playState === \"finished\") {\n            startTime = now;\n        }\n        if (playState === \"finished\") {\n            updateFinishedPromise();\n        }\n        cancelTime = startTime;\n        holdTime = null;\n        /**\n         * Set playState to running only after we've used it in\n         * the previous logic.\n         */\n        playState = \"running\";\n        animationDriver.start();\n    };\n    if (autoplay) {\n        play();\n    }\n    const controls = {\n        then(resolve, reject) {\n            return currentFinishedPromise.then(resolve, reject);\n        },\n        get time() {\n            return millisecondsToSeconds(currentTime);\n        },\n        set time(newTime) {\n            newTime = secondsToMilliseconds(newTime);\n            currentTime = newTime;\n            if (holdTime !== null || !animationDriver || speed === 0) {\n                holdTime = newTime;\n            }\n            else {\n                startTime = animationDriver.now() - newTime / speed;\n            }\n        },\n        get duration() {\n            const duration = generator.calculatedDuration === null\n                ? calcGeneratorDuration(generator)\n                : generator.calculatedDuration;\n            return millisecondsToSeconds(duration);\n        },\n        get speed() {\n            return speed;\n        },\n        set speed(newSpeed) {\n            if (newSpeed === speed || !animationDriver)\n                return;\n            speed = newSpeed;\n            controls.time = millisecondsToSeconds(currentTime);\n        },\n        get state() {\n            return playState;\n        },\n        play,\n        pause: () => {\n            playState = \"paused\";\n            holdTime = currentTime;\n        },\n        stop: () => {\n            hasStopped = true;\n            if (playState === \"idle\")\n                return;\n            playState = \"idle\";\n            onStop && onStop();\n            cancel();\n        },\n        cancel: () => {\n            if (cancelTime !== null)\n                tick(cancelTime);\n            cancel();\n        },\n        complete: () => {\n            playState = \"finished\";\n        },\n        sample: (elapsed) => {\n            startTime = 0;\n            return tick(elapsed);\n        },\n    };\n    return controls;\n}\n\nfunction memo(callback) {\n    let result;\n    return () => {\n        if (result === undefined)\n            result = callback();\n        return result;\n    };\n}\n\nconst supportsWaapi = memo(() => Object.hasOwnProperty.call(Element.prototype, \"animate\"));\n/**\n * A list of values that can be hardware-accelerated.\n */\nconst acceleratedValues = new Set([\n    \"opacity\",\n    \"clipPath\",\n    \"filter\",\n    \"transform\",\n    \"backgroundColor\",\n]);\n/**\n * 10ms is chosen here as it strikes a balance between smooth\n * results (more than one keyframe per frame at 60fps) and\n * keyframe quantity.\n */\nconst sampleDelta = 10; //ms\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\nconst maxDuration = 20000;\nconst requiresPregeneratedKeyframes = (valueName, options) => options.type === \"spring\" ||\n    valueName === \"backgroundColor\" ||\n    !isWaapiSupportedEasing(options.ease);\nfunction createAcceleratedAnimation(value, valueName, { onUpdate, onComplete, ...options }) {\n    const canAccelerateAnimation = supportsWaapi() &&\n        acceleratedValues.has(valueName) &&\n        !options.repeatDelay &&\n        options.repeatType !== \"mirror\" &&\n        options.damping !== 0 &&\n        options.type !== \"inertia\";\n    if (!canAccelerateAnimation)\n        return false;\n    /**\n     * TODO: Unify with js/index\n     */\n    let hasStopped = false;\n    let resolveFinishedPromise;\n    let currentFinishedPromise;\n    /**\n     * Cancelling an animation will write to the DOM. For safety we want to defer\n     * this until the next `update` frame lifecycle. This flag tracks whether we\n     * have a pending cancel, if so we shouldn't allow animations to finish.\n     */\n    let pendingCancel = false;\n    /**\n     * Resolve the current Promise every time we enter the\n     * finished state. This is WAAPI-compatible behaviour.\n     */\n    const updateFinishedPromise = () => {\n        currentFinishedPromise = new Promise((resolve) => {\n            resolveFinishedPromise = resolve;\n        });\n    };\n    // Create the first finished promise\n    updateFinishedPromise();\n    let { keyframes, duration = 300, ease, times } = options;\n    /**\n     * If this animation needs pre-generated keyframes then generate.\n     */\n    if (requiresPregeneratedKeyframes(valueName, options)) {\n        const sampleAnimation = animateValue({\n            ...options,\n            repeat: 0,\n            delay: 0,\n        });\n        let state = { done: false, value: keyframes[0] };\n        const pregeneratedKeyframes = [];\n        /**\n         * Bail after 20 seconds of pre-generated keyframes as it's likely\n         * we're heading for an infinite loop.\n         */\n        let t = 0;\n        while (!state.done && t < maxDuration) {\n            state = sampleAnimation.sample(t);\n            pregeneratedKeyframes.push(state.value);\n            t += sampleDelta;\n        }\n        times = undefined;\n        keyframes = pregeneratedKeyframes;\n        duration = t - sampleDelta;\n        ease = \"linear\";\n    }\n    const animation = animateStyle(value.owner.current, valueName, keyframes, {\n        ...options,\n        duration,\n        /**\n         * This function is currently not called if ease is provided\n         * as a function so the cast is safe.\n         *\n         * However it would be possible for a future refinement to port\n         * in easing pregeneration from Motion One for browsers that\n         * support the upcoming `linear()` easing function.\n         */\n        ease: ease,\n        times,\n    });\n    const cancelAnimation = () => {\n        pendingCancel = false;\n        animation.cancel();\n    };\n    const safeCancel = () => {\n        pendingCancel = true;\n        frame.update(cancelAnimation);\n        resolveFinishedPromise();\n        updateFinishedPromise();\n    };\n    /**\n     * Prefer the `onfinish` prop as it's more widely supported than\n     * the `finished` promise.\n     *\n     * Here, we synchronously set the provided MotionValue to the end\n     * keyframe. If we didn't, when the WAAPI animation is finished it would\n     * be removed from the element which would then revert to its old styles.\n     */\n    animation.onfinish = () => {\n        if (pendingCancel)\n            return;\n        value.set(getFinalKeyframe(keyframes, options));\n        onComplete && onComplete();\n        safeCancel();\n    };\n    /**\n     * Animation interrupt callback.\n     */\n    const controls = {\n        then(resolve, reject) {\n            return currentFinishedPromise.then(resolve, reject);\n        },\n        attachTimeline(timeline) {\n            animation.timeline = timeline;\n            animation.onfinish = null;\n            return noop;\n        },\n        get time() {\n            return millisecondsToSeconds(animation.currentTime || 0);\n        },\n        set time(newTime) {\n            animation.currentTime = secondsToMilliseconds(newTime);\n        },\n        get speed() {\n            return animation.playbackRate;\n        },\n        set speed(newSpeed) {\n            animation.playbackRate = newSpeed;\n        },\n        get duration() {\n            return millisecondsToSeconds(duration);\n        },\n        play: () => {\n            if (hasStopped)\n                return;\n            animation.play();\n            /**\n             * Cancel any pending cancel tasks\n             */\n            cancelFrame(cancelAnimation);\n        },\n        pause: () => animation.pause(),\n        stop: () => {\n            hasStopped = true;\n            if (animation.playState === \"idle\")\n                return;\n            /**\n             * WAAPI doesn't natively have any interruption capabilities.\n             *\n             * Rather than read commited styles back out of the DOM, we can\n             * create a renderless JS animation and sample it twice to calculate\n             * its current value, \"previous\" value, and therefore allow\n             * Motion to calculate velocity for any subsequent animation.\n             */\n            const { currentTime } = animation;\n            if (currentTime) {\n                const sampleAnimation = animateValue({\n                    ...options,\n                    autoplay: false,\n                });\n                value.setWithVelocity(sampleAnimation.sample(currentTime - sampleDelta).value, sampleAnimation.sample(currentTime).value, sampleDelta);\n            }\n            safeCancel();\n        },\n        complete: () => {\n            if (pendingCancel)\n                return;\n            animation.finish();\n        },\n        cancel: safeCancel,\n    };\n    return controls;\n}\n\nfunction createInstantAnimation({ keyframes, delay, onUpdate, onComplete, }) {\n    const setValue = () => {\n        onUpdate && onUpdate(keyframes[keyframes.length - 1]);\n        onComplete && onComplete();\n        /**\n         * TODO: As this API grows it could make sense to always return\n         * animateValue. This will be a bigger project as animateValue\n         * is frame-locked whereas this function resolves instantly.\n         * This is a behavioural change and also has ramifications regarding\n         * assumptions within tests.\n         */\n        return {\n            time: 0,\n            speed: 1,\n            duration: 0,\n            play: (noop),\n            pause: (noop),\n            stop: (noop),\n            then: (resolve) => {\n                resolve();\n                return Promise.resolve();\n            },\n            cancel: (noop),\n            complete: (noop),\n        };\n    };\n    return delay\n        ? animateValue({\n            keyframes: [0, 1],\n            duration: 0,\n            delay,\n            onComplete: setValue,\n        })\n        : setValue();\n}\n\nconst underDampedSpring = {\n    type: \"spring\",\n    stiffness: 500,\n    damping: 25,\n    restSpeed: 10,\n};\nconst criticallyDampedSpring = (target) => ({\n    type: \"spring\",\n    stiffness: 550,\n    damping: target === 0 ? 2 * Math.sqrt(550) : 30,\n    restSpeed: 10,\n});\nconst keyframesTransition = {\n    type: \"keyframes\",\n    duration: 0.8,\n};\n/**\n * Default easing curve is a slightly shallower version of\n * the default browser easing curve.\n */\nconst ease = {\n    type: \"keyframes\",\n    ease: [0.25, 0.1, 0.35, 1],\n    duration: 0.3,\n};\nconst getDefaultTransition = (valueKey, { keyframes }) => {\n    if (keyframes.length > 2) {\n        return keyframesTransition;\n    }\n    else if (transformProps.has(valueKey)) {\n        return valueKey.startsWith(\"scale\")\n            ? criticallyDampedSpring(keyframes[1])\n            : underDampedSpring;\n    }\n    return ease;\n};\n\n/**\n * Check if a value is animatable. Examples:\n *\n * \u2705: 100, \"100px\", \"#fff\"\n * \u274c: \"block\", \"url(2.jpg)\"\n * @param value\n *\n * @internal\n */\nconst isAnimatable = (key, value) => {\n    // If the list of keys tat might be non-animatable grows, replace with Set\n    if (key === \"zIndex\")\n        return false;\n    // If it's a number or a keyframes array, we can animate it. We might at some point\n    // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,\n    // but for now lets leave it like this for performance reasons\n    if (typeof value === \"number\" || Array.isArray(value))\n        return true;\n    if (typeof value === \"string\" && // It's animatable if we have a string\n        (complex.test(value) || value === \"0\") && // And it contains numbers and/or colors\n        !value.startsWith(\"url(\") // Unless it starts with \"url(\"\n    ) {\n        return true;\n    }\n    return false;\n};\n\n/**\n * Properties that should default to 1 or 100%\n */\nconst maxDefaults = new Set([\"brightness\", \"contrast\", \"saturate\", \"opacity\"]);\nfunction applyDefaultFilter(v) {\n    const [name, value] = v.slice(0, -1).split(\"(\");\n    if (name === \"drop-shadow\")\n        return v;\n    const [number] = value.match(floatRegex) || [];\n    if (!number)\n        return v;\n    const unit = value.replace(number, \"\");\n    let defaultValue = maxDefaults.has(name) ? 1 : 0;\n    if (number !== value)\n        defaultValue *= 100;\n    return name + \"(\" + defaultValue + unit + \")\";\n}\nconst functionRegex = /([a-z-]*)\\(.*?\\)/g;\nconst filter = {\n    ...complex,\n    getAnimatableNone: (v) => {\n        const functions = v.match(functionRegex);\n        return functions ? functions.map(applyDefaultFilter).join(\" \") : v;\n    },\n};\n\n/**\n * A map of default value types for common values\n */\nconst defaultValueTypes = {\n    ...numberValueTypes,\n    // Color props\n    color,\n    backgroundColor: color,\n    outlineColor: color,\n    fill: color,\n    stroke: color,\n    // Border props\n    borderColor: color,\n    borderTopColor: color,\n    borderRightColor: color,\n    borderBottomColor: color,\n    borderLeftColor: color,\n    filter,\n    WebkitFilter: filter,\n};\n/**\n * Gets the default ValueType for the provided value key\n */\nconst getDefaultValueType = (key) => defaultValueTypes[key];\n\nfunction getAnimatableNone(key, value) {\n    let defaultValueType = getDefaultValueType(key);\n    if (defaultValueType !== filter)\n        defaultValueType = complex;\n    // If value is not recognised as animatable, ie \"none\", create an animatable version origin based on the target\n    return defaultValueType.getAnimatableNone\n        ? defaultValueType.getAnimatableNone(value)\n        : undefined;\n}\n\n/**\n * Check if the value is a zero value string like \"0px\" or \"0%\"\n */\nconst isZeroValueString = (v) => /^0[^.\\s]+$/.test(v);\n\nfunction isNone(value) {\n    if (typeof value === \"number\") {\n        return value === 0;\n    }\n    else if (value !== null) {\n        return value === \"none\" || value === \"0\" || isZeroValueString(value);\n    }\n}\n\nfunction getKeyframes(value, valueName, target, transition) {\n    const isTargetAnimatable = isAnimatable(valueName, target);\n    let keyframes;\n    if (Array.isArray(target)) {\n        keyframes = [...target];\n    }\n    else {\n        keyframes = [null, target];\n    }\n    const defaultOrigin = transition.from !== undefined ? transition.from : value.get();\n    let animatableTemplateValue = undefined;\n    const noneKeyframeIndexes = [];\n    for (let i = 0; i < keyframes.length; i++) {\n        /**\n         * Fill null/wildcard keyframes\n         */\n        if (keyframes[i] === null) {\n            keyframes[i] = i === 0 ? defaultOrigin : keyframes[i - 1];\n        }\n        if (isNone(keyframes[i])) {\n            noneKeyframeIndexes.push(i);\n        }\n        // TODO: Clean this conditional, it works for now\n        if (typeof keyframes[i] === \"string\" &&\n            keyframes[i] !== \"none\" &&\n            keyframes[i] !== \"0\") {\n            animatableTemplateValue = keyframes[i];\n        }\n    }\n    if (isTargetAnimatable &&\n        noneKeyframeIndexes.length &&\n        animatableTemplateValue) {\n        for (let i = 0; i < noneKeyframeIndexes.length; i++) {\n            const index = noneKeyframeIndexes[i];\n            keyframes[index] = getAnimatableNone(valueName, animatableTemplateValue);\n        }\n    }\n    return keyframes;\n}\n\n/**\n * Decide whether a transition is defined on a given Transition.\n * This filters out orchestration options and returns true\n * if any options are left.\n */\nfunction isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition }) {\n    return !!Object.keys(transition).length;\n}\nfunction getValueTransition$1(transition, key) {\n    return transition[key] || transition[\"default\"] || transition;\n}\n\nconst MotionGlobalConfig = {\n    skipAnimations: false,\n};\n\nconst animateMotionValue = (valueName, value, target, transition = {}) => {\n    return (onComplete) => {\n        const valueTransition = getValueTransition$1(transition, valueName) || {};\n        /**\n         * Most transition values are currently completely overwritten by value-specific\n         * transitions. In the future it'd be nicer to blend these transitions. But for now\n         * delay actually does inherit from the root transition if not value-specific.\n         */\n        const delay = valueTransition.delay || transition.delay || 0;\n        /**\n         * Elapsed isn't a public transition option but can be passed through from\n         * optimized appear effects in milliseconds.\n         */\n        let { elapsed = 0 } = transition;\n        elapsed = elapsed - secondsToMilliseconds(delay);\n        const keyframes = getKeyframes(value, valueName, target, valueTransition);\n        /**\n         * Check if we're able to animate between the start and end keyframes,\n         * and throw a warning if we're attempting to animate between one that's\n         * animatable and another that isn't.\n         */\n        const originKeyframe = keyframes[0];\n        const targetKeyframe = keyframes[keyframes.length - 1];\n        const isOriginAnimatable = isAnimatable(valueName, originKeyframe);\n        const isTargetAnimatable = isAnimatable(valueName, targetKeyframe);\n        exports.warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${valueName} from \"${originKeyframe}\" to \"${targetKeyframe}\". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \\`style\\` property.`);\n        let options = {\n            keyframes,\n            velocity: value.getVelocity(),\n            ease: \"easeOut\",\n            ...valueTransition,\n            delay: -elapsed,\n            onUpdate: (v) => {\n                value.set(v);\n                valueTransition.onUpdate && valueTransition.onUpdate(v);\n            },\n            onComplete: () => {\n                onComplete();\n                valueTransition.onComplete && valueTransition.onComplete();\n            },\n        };\n        /**\n         * If there's no transition defined for this value, we can generate\n         * unqiue transition settings for this value.\n         */\n        if (!isTransitionDefined(valueTransition)) {\n            options = {\n                ...options,\n                ...getDefaultTransition(valueName, options),\n            };\n        }\n        /**\n         * Both WAAPI and our internal animation functions use durations\n         * as defined by milliseconds, while our external API defines them\n         * as seconds.\n         */\n        if (options.duration) {\n            options.duration = secondsToMilliseconds(options.duration);\n        }\n        if (options.repeatDelay) {\n            options.repeatDelay = secondsToMilliseconds(options.repeatDelay);\n        }\n        if (!isOriginAnimatable ||\n            !isTargetAnimatable ||\n            instantAnimationState.current ||\n            valueTransition.type === false ||\n            MotionGlobalConfig.skipAnimations) {\n            /**\n             * If we can't animate this value, or the global instant animation flag is set,\n             * or this is simply defined as an instant transition, return an instant transition.\n             */\n            return createInstantAnimation(instantAnimationState.current\n                ? { ...options, delay: 0 }\n                : options);\n        }\n        /**\n         * Animate via WAAPI if possible.\n         */\n        if (\n        /**\n         * If this is a handoff animation, the optimised animation will be running via\n         * WAAPI. Therefore, this animation must be JS to ensure it runs \"under\" the\n         * optimised animation.\n         */\n        !transition.isHandoff &&\n            value.owner &&\n            value.owner.current instanceof HTMLElement &&\n            /**\n             * If we're outputting values to onUpdate then we can't use WAAPI as there's\n             * no way to read the value from WAAPI every frame.\n             */\n            !value.owner.getProps().onUpdate) {\n            const acceleratedAnimation = createAcceleratedAnimation(value, valueName, options);\n            if (acceleratedAnimation)\n                return acceleratedAnimation;\n        }\n        /**\n         * If we didn't create an accelerated animation, create a JS animation\n         */\n        return animateValue(options);\n    };\n};\n\nfunction isWillChangeMotionValue(value) {\n    return Boolean(isMotionValue(value) && value.add);\n}\n\n/**\n * Check if value is a numerical string, ie a string that is purely a number eg \"100\" or \"-100.1\"\n */\nconst isNumericalString = (v) => /^\\-?\\d*\\.?\\d+$/.test(v);\n\nfunction addUniqueItem(arr, item) {\n    if (arr.indexOf(item) === -1)\n        arr.push(item);\n}\nfunction removeItem(arr, item) {\n    const index = arr.indexOf(item);\n    if (index > -1)\n        arr.splice(index, 1);\n}\n// Adapted from array-move\nfunction moveItem([...arr], fromIndex, toIndex) {\n    const startIndex = fromIndex < 0 ? arr.length + fromIndex : fromIndex;\n    if (startIndex >= 0 && startIndex < arr.length) {\n        const endIndex = toIndex < 0 ? arr.length + toIndex : toIndex;\n        const [item] = arr.splice(fromIndex, 1);\n        arr.splice(endIndex, 0, item);\n    }\n    return arr;\n}\n\nclass SubscriptionManager {\n    constructor() {\n        this.subscriptions = [];\n    }\n    add(handler) {\n        addUniqueItem(this.subscriptions, handler);\n        return () => removeItem(this.subscriptions, handler);\n    }\n    notify(a, b, c) {\n        const numSubscriptions = this.subscriptions.length;\n        if (!numSubscriptions)\n            return;\n        if (numSubscriptions === 1) {\n            /**\n             * If there's only a single handler we can just call it without invoking a loop.\n             */\n            this.subscriptions[0](a, b, c);\n        }\n        else {\n            for (let i = 0; i < numSubscriptions; i++) {\n                /**\n                 * Check whether the handler exists before firing as it's possible\n                 * the subscriptions were modified during this loop running.\n                 */\n                const handler = this.subscriptions[i];\n                handler && handler(a, b, c);\n            }\n        }\n    }\n    getSize() {\n        return this.subscriptions.length;\n    }\n    clear() {\n        this.subscriptions.length = 0;\n    }\n}\n\nconst warned = new Set();\nfunction warnOnce(condition, message, element) {\n    if (condition || warned.has(message))\n        return;\n    console.warn(message);\n    if (element)\n        console.warn(element);\n    warned.add(message);\n}\n\nconst isFloat = (value) => {\n    return !isNaN(parseFloat(value));\n};\nconst collectMotionValues = {\n    current: undefined,\n};\n/**\n * `MotionValue` is used to track the state and velocity of motion values.\n *\n * @public\n */\nclass MotionValue {\n    /**\n     * @param init - The initiating value\n     * @param config - Optional configuration options\n     *\n     * -  `transformer`: A function to transform incoming values with.\n     *\n     * @internal\n     */\n    constructor(init, options = {}) {\n        /**\n         * This will be replaced by the build step with the latest version number.\n         * When MotionValues are provided to motion components, warn if versions are mixed.\n         */\n        this.version = \"10.18.0\";\n        /**\n         * Duration, in milliseconds, since last updating frame.\n         *\n         * @internal\n         */\n        this.timeDelta = 0;\n        /**\n         * Timestamp of the last time this `MotionValue` was updated.\n         *\n         * @internal\n         */\n        this.lastUpdated = 0;\n        /**\n         * Tracks whether this value can output a velocity. Currently this is only true\n         * if the value is numerical, but we might be able to widen the scope here and support\n         * other value types.\n         *\n         * @internal\n         */\n        this.canTrackVelocity = false;\n        /**\n         * An object containing a SubscriptionManager for each active event.\n         */\n        this.events = {};\n        this.updateAndNotify = (v, render = true) => {\n            this.prev = this.current;\n            this.current = v;\n            // Update timestamp\n            const { delta, timestamp } = frameData;\n            if (this.lastUpdated !== timestamp) {\n                this.timeDelta = delta;\n                this.lastUpdated = timestamp;\n                frame.postRender(this.scheduleVelocityCheck);\n            }\n            // Update update subscribers\n            if (this.prev !== this.current && this.events.change) {\n                this.events.change.notify(this.current);\n            }\n            // Update velocity subscribers\n            if (this.events.velocityChange) {\n                this.events.velocityChange.notify(this.getVelocity());\n            }\n            // Update render subscribers\n            if (render && this.events.renderRequest) {\n                this.events.renderRequest.notify(this.current);\n            }\n        };\n        /**\n         * Schedule a velocity check for the next frame.\n         *\n         * This is an instanced and bound function to prevent generating a new\n         * function once per frame.\n         *\n         * @internal\n         */\n        this.scheduleVelocityCheck = () => frame.postRender(this.velocityCheck);\n        /**\n         * Updates `prev` with `current` if the value hasn't been updated this frame.\n         * This ensures velocity calculations return `0`.\n         *\n         * This is an instanced and bound function to prevent generating a new\n         * function once per frame.\n         *\n         * @internal\n         */\n        this.velocityCheck = ({ timestamp }) => {\n            if (timestamp !== this.lastUpdated) {\n                this.prev = this.current;\n                if (this.events.velocityChange) {\n                    this.events.velocityChange.notify(this.getVelocity());\n                }\n            }\n        };\n        this.hasAnimated = false;\n        this.prev = this.current = init;\n        this.canTrackVelocity = isFloat(this.current);\n        this.owner = options.owner;\n    }\n    /**\n     * Adds a function that will be notified when the `MotionValue` is updated.\n     *\n     * It returns a function that, when called, will cancel the subscription.\n     *\n     * When calling `onChange` inside a React component, it should be wrapped with the\n     * `useEffect` hook. As it returns an unsubscribe function, this should be returned\n     * from the `useEffect` function to ensure you don't add duplicate subscribers..\n     *\n     * ```jsx\n     * export const MyComponent = () => {\n     *   const x = useMotionValue(0)\n     *   const y = useMotionValue(0)\n     *   const opacity = useMotionValue(1)\n     *\n     *   useEffect(() => {\n     *     function updateOpacity() {\n     *       const maxXY = Math.max(x.get(), y.get())\n     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n     *       opacity.set(newOpacity)\n     *     }\n     *\n     *     const unsubscribeX = x.on(\"change\", updateOpacity)\n     *     const unsubscribeY = y.on(\"change\", updateOpacity)\n     *\n     *     return () => {\n     *       unsubscribeX()\n     *       unsubscribeY()\n     *     }\n     *   }, [])\n     *\n     *   return <motion.div style={{ x }} />\n     * }\n     * ```\n     *\n     * @param subscriber - A function that receives the latest value.\n     * @returns A function that, when called, will cancel this subscription.\n     *\n     * @deprecated\n     */\n    onChange(subscription) {\n        if (process.env.NODE_ENV !== \"production\") {\n            warnOnce(false, `value.onChange(callback) is deprecated. Switch to value.on(\"change\", callback).`);\n        }\n        return this.on(\"change\", subscription);\n    }\n    on(eventName, callback) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = new SubscriptionManager();\n        }\n        const unsubscribe = this.events[eventName].add(callback);\n        if (eventName === \"change\") {\n            return () => {\n                unsubscribe();\n                /**\n                 * If we have no more change listeners by the start\n                 * of the next frame, stop active animations.\n                 */\n                frame.read(() => {\n                    if (!this.events.change.getSize()) {\n                        this.stop();\n                    }\n                });\n            };\n        }\n        return unsubscribe;\n    }\n    clearListeners() {\n        for (const eventManagers in this.events) {\n            this.events[eventManagers].clear();\n        }\n    }\n    /**\n     * Attaches a passive effect to the `MotionValue`.\n     *\n     * @internal\n     */\n    attach(passiveEffect, stopPassiveEffect) {\n        this.passiveEffect = passiveEffect;\n        this.stopPassiveEffect = stopPassiveEffect;\n    }\n    /**\n     * Sets the state of the `MotionValue`.\n     *\n     * @remarks\n     *\n     * ```jsx\n     * const x = useMotionValue(0)\n     * x.set(10)\n     * ```\n     *\n     * @param latest - Latest value to set.\n     * @param render - Whether to notify render subscribers. Defaults to `true`\n     *\n     * @public\n     */\n    set(v, render = true) {\n        if (!render || !this.passiveEffect) {\n            this.updateAndNotify(v, render);\n        }\n        else {\n            this.passiveEffect(v, this.updateAndNotify);\n        }\n    }\n    setWithVelocity(prev, current, delta) {\n        this.set(current);\n        this.prev = prev;\n        this.timeDelta = delta;\n    }\n    /**\n     * Set the state of the `MotionValue`, stopping any active animations,\n     * effects, and resets velocity to `0`.\n     */\n    jump(v) {\n        this.updateAndNotify(v);\n        this.prev = v;\n        this.stop();\n        if (this.stopPassiveEffect)\n            this.stopPassiveEffect();\n    }\n    /**\n     * Returns the latest state of `MotionValue`\n     *\n     * @returns - The latest state of `MotionValue`\n     *\n     * @public\n     */\n    get() {\n        if (collectMotionValues.current) {\n            collectMotionValues.current.push(this);\n        }\n        return this.current;\n    }\n    /**\n     * @public\n     */\n    getPrevious() {\n        return this.prev;\n    }\n    /**\n     * Returns the latest velocity of `MotionValue`\n     *\n     * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\n     *\n     * @public\n     */\n    getVelocity() {\n        // This could be isFloat(this.prev) && isFloat(this.current), but that would be wasteful\n        return this.canTrackVelocity\n            ? // These casts could be avoided if parseFloat would be typed better\n                velocityPerSecond(parseFloat(this.current) -\n                    parseFloat(this.prev), this.timeDelta)\n            : 0;\n    }\n    /**\n     * Registers a new animation to control this `MotionValue`. Only one\n     * animation can drive a `MotionValue` at one time.\n     *\n     * ```jsx\n     * value.start()\n     * ```\n     *\n     * @param animation - A function that starts the provided animation\n     *\n     * @internal\n     */\n    start(startAnimation) {\n        this.stop();\n        return new Promise((resolve) => {\n            this.hasAnimated = true;\n            this.animation = startAnimation(resolve);\n            if (this.events.animationStart) {\n                this.events.animationStart.notify();\n            }\n        }).then(() => {\n            if (this.events.animationComplete) {\n                this.events.animationComplete.notify();\n            }\n            this.clearAnimation();\n        });\n    }\n    /**\n     * Stop the currently active animation.\n     *\n     * @public\n     */\n    stop() {\n        if (this.animation) {\n            this.animation.stop();\n            if (this.events.animationCancel) {\n                this.events.animationCancel.notify();\n            }\n        }\n        this.clearAnimation();\n    }\n    /**\n     * Returns `true` if this value is currently animating.\n     *\n     * @public\n     */\n    isAnimating() {\n        return !!this.animation;\n    }\n    clearAnimation() {\n        delete this.animation;\n    }\n    /**\n     * Destroy and clean up subscribers to this `MotionValue`.\n     *\n     * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\n     * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually\n     * created a `MotionValue` via the `motionValue` function.\n     *\n     * @public\n     */\n    destroy() {\n        this.clearListeners();\n        this.stop();\n        if (this.stopPassiveEffect) {\n            this.stopPassiveEffect();\n        }\n    }\n}\nfunction motionValue(init, options) {\n    return new MotionValue(init, options);\n}\n\n/**\n * Tests a provided value against a ValueType\n */\nconst testValueType = (v) => (type) => type.test(v);\n\n/**\n * ValueType for \"auto\"\n */\nconst auto = {\n    test: (v) => v === \"auto\",\n    parse: (v) => v,\n};\n\n/**\n * A list of value types commonly used for dimensions\n */\nconst dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];\n/**\n * Tests a dimensional value against the list of dimension ValueTypes\n */\nconst findDimensionValueType = (v) => dimensionValueTypes.find(testValueType(v));\n\n/**\n * A list of all ValueTypes\n */\nconst valueTypes = [...dimensionValueTypes, color, complex];\n/**\n * Tests a value against the list of ValueTypes\n */\nconst findValueType = (v) => valueTypes.find(testValueType(v));\n\n/**\n * Set VisualElement's MotionValue, creating a new MotionValue for it if\n * it doesn't exist.\n */\nfunction setMotionValue(visualElement, key, value) {\n    if (visualElement.hasValue(key)) {\n        visualElement.getValue(key).set(value);\n    }\n    else {\n        visualElement.addValue(key, motionValue(value));\n    }\n}\nfunction setTarget(visualElement, definition) {\n    const resolved = resolveVariant(visualElement, definition);\n    let { transitionEnd = {}, transition = {}, ...target } = resolved ? visualElement.makeTargetAnimatable(resolved, false) : {};\n    target = { ...target, ...transitionEnd };\n    for (const key in target) {\n        const value = resolveFinalValueInKeyframes(target[key]);\n        setMotionValue(visualElement, key, value);\n    }\n}\nfunction setVariants(visualElement, variantLabels) {\n    const reversedLabels = [...variantLabels].reverse();\n    reversedLabels.forEach((key) => {\n        const variant = visualElement.getVariant(key);\n        variant && setTarget(visualElement, variant);\n        if (visualElement.variantChildren) {\n            visualElement.variantChildren.forEach((child) => {\n                setVariants(child, variantLabels);\n            });\n        }\n    });\n}\nfunction setValues(visualElement, definition) {\n    if (Array.isArray(definition)) {\n        return setVariants(visualElement, definition);\n    }\n    else if (typeof definition === \"string\") {\n        return setVariants(visualElement, [definition]);\n    }\n    else {\n        setTarget(visualElement, definition);\n    }\n}\nfunction checkTargetForNewValues(visualElement, target, origin) {\n    var _a, _b;\n    const newValueKeys = Object.keys(target).filter((key) => !visualElement.hasValue(key));\n    const numNewValues = newValueKeys.length;\n    if (!numNewValues)\n        return;\n    for (let i = 0; i < numNewValues; i++) {\n        const key = newValueKeys[i];\n        const targetValue = target[key];\n        let value = null;\n        /**\n         * If the target is a series of keyframes, we can use the first value\n         * in the array. If this first value is null, we'll still need to read from the DOM.\n         */\n        if (Array.isArray(targetValue)) {\n            value = targetValue[0];\n        }\n        /**\n         * If the target isn't keyframes, or the first keyframe was null, we need to\n         * first check if an origin value was explicitly defined in the transition as \"from\",\n         * if not read the value from the DOM. As an absolute fallback, take the defined target value.\n         */\n        if (value === null) {\n            value = (_b = (_a = origin[key]) !== null && _a !== void 0 ? _a : visualElement.readValue(key)) !== null && _b !== void 0 ? _b : target[key];\n        }\n        /**\n         * If value is still undefined or null, ignore it. Preferably this would throw,\n         * but this was causing issues in Framer.\n         */\n        if (value === undefined || value === null)\n            continue;\n        if (typeof value === \"string\" &&\n            (isNumericalString(value) || isZeroValueString(value))) {\n            // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n            value = parseFloat(value);\n        }\n        else if (!findValueType(value) && complex.test(targetValue)) {\n            value = getAnimatableNone(key, targetValue);\n        }\n        visualElement.addValue(key, motionValue(value, { owner: visualElement }));\n        if (origin[key] === undefined) {\n            origin[key] = value;\n        }\n        if (value !== null)\n            visualElement.setBaseTarget(key, value);\n    }\n}\nfunction getOriginFromTransition(key, transition) {\n    if (!transition)\n        return;\n    const valueTransition = transition[key] || transition[\"default\"] || transition;\n    return valueTransition.from;\n}\nfunction getOrigin(target, transition, visualElement) {\n    const origin = {};\n    for (const key in target) {\n        const transitionOrigin = getOriginFromTransition(key, transition);\n        if (transitionOrigin !== undefined) {\n            origin[key] = transitionOrigin;\n        }\n        else {\n            const value = visualElement.getValue(key);\n            if (value) {\n                origin[key] = value.get();\n            }\n        }\n    }\n    return origin;\n}\n\n/**\n * Decide whether we should block this animation. Previously, we achieved this\n * just by checking whether the key was listed in protectedKeys, but this\n * posed problems if an animation was triggered by afterChildren and protectedKeys\n * had been set to true in the meantime.\n */\nfunction shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {\n    const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\n    needsAnimating[key] = false;\n    return shouldBlock;\n}\nfunction hasKeyframesChanged(value, target) {\n    const current = value.get();\n    if (Array.isArray(target)) {\n        for (let i = 0; i < target.length; i++) {\n            if (target[i] !== current)\n                return true;\n        }\n    }\n    else {\n        return current !== target;\n    }\n}\nfunction animateTarget(visualElement, definition, { delay = 0, transitionOverride, type } = {}) {\n    let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = visualElement.makeTargetAnimatable(definition);\n    const willChange = visualElement.getValue(\"willChange\");\n    if (transitionOverride)\n        transition = transitionOverride;\n    const animations = [];\n    const animationTypeState = type &&\n        visualElement.animationState &&\n        visualElement.animationState.getState()[type];\n    for (const key in target) {\n        const value = visualElement.getValue(key);\n        const valueTarget = target[key];\n        if (!value ||\n            valueTarget === undefined ||\n            (animationTypeState &&\n                shouldBlockAnimation(animationTypeState, key))) {\n            continue;\n        }\n        const valueTransition = {\n            delay,\n            elapsed: 0,\n            ...getValueTransition$1(transition || {}, key),\n        };\n        /**\n         * If this is the first time a value is being animated, check\n         * to see if we're handling off from an existing animation.\n         */\n        if (window.HandoffAppearAnimations) {\n            const appearId = visualElement.getProps()[optimizedAppearDataAttribute];\n            if (appearId) {\n                const elapsed = window.HandoffAppearAnimations(appearId, key, value, frame);\n                if (elapsed !== null) {\n                    valueTransition.elapsed = elapsed;\n                    valueTransition.isHandoff = true;\n                }\n            }\n        }\n        let canSkip = !valueTransition.isHandoff &&\n            !hasKeyframesChanged(value, valueTarget);\n        if (valueTransition.type === \"spring\" &&\n            (value.getVelocity() || valueTransition.velocity)) {\n            canSkip = false;\n        }\n        /**\n         * Temporarily disable skipping animations if there's an animation in\n         * progress. Better would be to track the current target of a value\n         * and compare that against valueTarget.\n         */\n        if (value.animation) {\n            canSkip = false;\n        }\n        if (canSkip)\n            continue;\n        value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && transformProps.has(key)\n            ? { type: false }\n            : valueTransition));\n        const animation = value.animation;\n        if (isWillChangeMotionValue(willChange)) {\n            willChange.add(key);\n            animation.then(() => willChange.remove(key));\n        }\n        animations.push(animation);\n    }\n    if (transitionEnd) {\n        Promise.all(animations).then(() => {\n            transitionEnd && setTarget(visualElement, transitionEnd);\n        });\n    }\n    return animations;\n}\n\nconst distance = (a, b) => Math.abs(a - b);\nfunction distance2D(a, b) {\n    // Multi-dimensional\n    const xDelta = distance(a.x, b.x);\n    const yDelta = distance(a.y, b.y);\n    return Math.sqrt(xDelta ** 2 + yDelta ** 2);\n}\n\nconst createAxisDelta = () => ({\n    translate: 0,\n    scale: 1,\n    origin: 0,\n    originPoint: 0,\n});\nconst createDelta = () => ({\n    x: createAxisDelta(),\n    y: createAxisDelta(),\n});\nconst createAxis = () => ({ min: 0, max: 0 });\nconst createBox = () => ({\n    x: createAxis(),\n    y: createAxis(),\n});\n\n/**\n * Bounding boxes tend to be defined as top, left, right, bottom. For various operations\n * it's easier to consider each axis individually. This function returns a bounding box\n * as a map of single-axis min/max values.\n */\nfunction convertBoundingBoxToBox({ top, left, right, bottom, }) {\n    return {\n        x: { min: left, max: right },\n        y: { min: top, max: bottom },\n    };\n}\nfunction convertBoxToBoundingBox({ x, y }) {\n    return { top: y.min, right: x.max, bottom: y.max, left: x.min };\n}\n/**\n * Applies a TransformPoint function to a bounding box. TransformPoint is usually a function\n * provided by Framer to allow measured points to be corrected for device scaling. This is used\n * when measuring DOM elements and DOM event points.\n */\nfunction transformBoxPoints(point, transformPoint) {\n    if (!transformPoint)\n        return point;\n    const topLeft = transformPoint({ x: point.left, y: point.top });\n    const bottomRight = transformPoint({ x: point.right, y: point.bottom });\n    return {\n        top: topLeft.y,\n        left: topLeft.x,\n        bottom: bottomRight.y,\n        right: bottomRight.x,\n    };\n}\n\nfunction isIdentityScale(scale) {\n    return scale === undefined || scale === 1;\n}\nfunction hasScale({ scale, scaleX, scaleY }) {\n    return (!isIdentityScale(scale) ||\n        !isIdentityScale(scaleX) ||\n        !isIdentityScale(scaleY));\n}\nfunction hasTransform(values) {\n    return (hasScale(values) ||\n        has2DTranslate(values) ||\n        values.z ||\n        values.rotate ||\n        values.rotateX ||\n        values.rotateY);\n}\nfunction has2DTranslate(values) {\n    return is2DTranslate(values.x) || is2DTranslate(values.y);\n}\nfunction is2DTranslate(value) {\n    return value && value !== \"0%\";\n}\n\n/**\n * Scales a point based on a factor and an originPoint\n */\nfunction scalePoint(point, scale, originPoint) {\n    const distanceFromOrigin = point - originPoint;\n    const scaled = scale * distanceFromOrigin;\n    return originPoint + scaled;\n}\n/**\n * Applies a translate/scale delta to a point\n */\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\n    if (boxScale !== undefined) {\n        point = scalePoint(point, boxScale, originPoint);\n    }\n    return scalePoint(point, scale, originPoint) + translate;\n}\n/**\n * Applies a translate/scale delta to an axis\n */\nfunction applyAxisDelta(axis, translate = 0, scale = 1, originPoint, boxScale) {\n    axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n    axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Applies a translate/scale delta to a box\n */\nfunction applyBoxDelta(box, { x, y }) {\n    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\n/**\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\n *\n * This is the final nested loop within updateLayoutDelta for future refactoring\n */\nfunction applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {\n    const treeLength = treePath.length;\n    if (!treeLength)\n        return;\n    // Reset the treeScale\n    treeScale.x = treeScale.y = 1;\n    let node;\n    let delta;\n    for (let i = 0; i < treeLength; i++) {\n        node = treePath[i];\n        delta = node.projectionDelta;\n        /**\n         * TODO: Prefer to remove this, but currently we have motion components with\n         * display: contents in Framer.\n         */\n        const instance = node.instance;\n        if (instance &&\n            instance.style &&\n            instance.style.display === \"contents\") {\n            continue;\n        }\n        if (isSharedTransition &&\n            node.options.layoutScroll &&\n            node.scroll &&\n            node !== node.root) {\n            transformBox(box, {\n                x: -node.scroll.offset.x,\n                y: -node.scroll.offset.y,\n            });\n        }\n        if (delta) {\n            // Incoporate each ancestor's scale into a culmulative treeScale for this component\n            treeScale.x *= delta.x.scale;\n            treeScale.y *= delta.y.scale;\n            // Apply each ancestor's calculated delta into this component's recorded layout box\n            applyBoxDelta(box, delta);\n        }\n        if (isSharedTransition && hasTransform(node.latestValues)) {\n            transformBox(box, node.latestValues);\n        }\n    }\n    /**\n     * Snap tree scale back to 1 if it's within a non-perceivable threshold.\n     * This will help reduce useless scales getting rendered.\n     */\n    treeScale.x = snapToDefault(treeScale.x);\n    treeScale.y = snapToDefault(treeScale.y);\n}\nfunction snapToDefault(scale) {\n    if (Number.isInteger(scale))\n        return scale;\n    return scale > 1.0000000000001 || scale < 0.999999999999 ? scale : 1;\n}\nfunction translateAxis(axis, distance) {\n    axis.min = axis.min + distance;\n    axis.max = axis.max + distance;\n}\n/**\n * Apply a transform to an axis from the latest resolved motion values.\n * This function basically acts as a bridge between a flat motion value map\n * and applyAxisDelta\n */\nfunction transformAxis(axis, transforms, [key, scaleKey, originKey]) {\n    const axisOrigin = transforms[originKey] !== undefined ? transforms[originKey] : 0.5;\n    const originPoint = mix(axis.min, axis.max, axisOrigin);\n    // Apply the axis delta to the final axis\n    applyAxisDelta(axis, transforms[key], transforms[scaleKey], originPoint, transforms.scale);\n}\n/**\n * The names of the motion values we want to apply as translation, scale and origin.\n */\nconst xKeys = [\"x\", \"scaleX\", \"originX\"];\nconst yKeys = [\"y\", \"scaleY\", \"originY\"];\n/**\n * Apply a transform to a box from the latest resolved motion values.\n */\nfunction transformBox(box, transform) {\n    transformAxis(box.x, transform, xKeys);\n    transformAxis(box.y, transform, yKeys);\n}\n\nfunction measureViewportBox(instance, transformPoint) {\n    return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint));\n}\nfunction measurePageBox(element, rootProjectionNode, transformPagePoint) {\n    const viewportBox = measureViewportBox(element, transformPagePoint);\n    const { scroll } = rootProjectionNode;\n    if (scroll) {\n        translateAxis(viewportBox.x, scroll.offset.x);\n        translateAxis(viewportBox.y, scroll.offset.y);\n    }\n    return viewportBox;\n}\n\n/**\n * Timeout defined in ms\n */\nfunction delay(callback, timeout) {\n    const start = performance.now();\n    const checkElapsed = ({ timestamp }) => {\n        const elapsed = timestamp - start;\n        if (elapsed >= timeout) {\n            cancelFrame(checkElapsed);\n            callback(elapsed - timeout);\n        }\n    };\n    frame.read(checkElapsed, true);\n    return () => cancelFrame(checkElapsed);\n}\n\nfunction resolveElements(elements, scope, selectorCache) {\n    var _a;\n    if (typeof elements === \"string\") {\n        let root = document;\n        if (scope) {\n            exports.invariant(Boolean(scope.current), \"Scope provided, but no element detected.\");\n            root = scope.current;\n        }\n        if (selectorCache) {\n            (_a = selectorCache[elements]) !== null && _a !== void 0 ? _a : (selectorCache[elements] = root.querySelectorAll(elements));\n            elements = selectorCache[elements];\n        }\n        else {\n            elements = root.querySelectorAll(elements);\n        }\n    }\n    else if (elements instanceof Element) {\n        elements = [elements];\n    }\n    /**\n     * Return an empty array\n     */\n    return Array.from(elements || []);\n}\n\nconst visualElementStore = new WeakMap();\n\nfunction observeTimeline(update, timeline) {\n    let prevProgress;\n    const onFrame = () => {\n        const { currentTime } = timeline;\n        const percentage = currentTime === null ? 0 : currentTime.value;\n        const progress = percentage / 100;\n        if (prevProgress !== progress) {\n            update(progress);\n        }\n        prevProgress = progress;\n    };\n    frame.update(onFrame, true);\n    return () => cancelFrame(onFrame);\n}\n\nconst supportsScrollTimeline = memo(() => window.ScrollTimeline !== undefined);\n\nclass GroupPlaybackControls {\n    constructor(animations) {\n        this.animations = animations.filter(Boolean);\n    }\n    then(onResolve, onReject) {\n        return Promise.all(this.animations).then(onResolve).catch(onReject);\n    }\n    /**\n     * TODO: Filter out cancelled or stopped animations before returning\n     */\n    getAll(propName) {\n        return this.animations[0][propName];\n    }\n    setAll(propName, newValue) {\n        for (let i = 0; i < this.animations.length; i++) {\n            this.animations[i][propName] = newValue;\n        }\n    }\n    attachTimeline(timeline) {\n        const cancelAll = this.animations.map((animation) => {\n            if (supportsScrollTimeline() && animation.attachTimeline) {\n                animation.attachTimeline(timeline);\n            }\n            else {\n                animation.pause();\n                return observeTimeline((progress) => {\n                    animation.time = animation.duration * progress;\n                }, timeline);\n            }\n        });\n        return () => {\n            cancelAll.forEach((cancelTimeline, i) => {\n                if (cancelTimeline)\n                    cancelTimeline();\n                this.animations[i].stop();\n            });\n        };\n    }\n    get time() {\n        return this.getAll(\"time\");\n    }\n    set time(time) {\n        this.setAll(\"time\", time);\n    }\n    get speed() {\n        return this.getAll(\"speed\");\n    }\n    set speed(speed) {\n        this.setAll(\"speed\", speed);\n    }\n    get duration() {\n        let max = 0;\n        for (let i = 0; i < this.animations.length; i++) {\n            max = Math.max(max, this.animations[i].duration);\n        }\n        return max;\n    }\n    runAll(methodName) {\n        this.animations.forEach((controls) => controls[methodName]());\n    }\n    play() {\n        this.runAll(\"play\");\n    }\n    pause() {\n        this.runAll(\"pause\");\n    }\n    stop() {\n        this.runAll(\"stop\");\n    }\n    cancel() {\n        this.runAll(\"cancel\");\n    }\n    complete() {\n        this.runAll(\"complete\");\n    }\n}\n\nfunction isDOMKeyframes(keyframes) {\n    return typeof keyframes === \"object\" && !Array.isArray(keyframes);\n}\n\nfunction isSVGElement(element) {\n    return element instanceof SVGElement && element.tagName !== \"svg\";\n}\n\n/**\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\n *\n * ```\n * `var(--foo, #fff)` => [`--foo`, '#fff']\n * ```\n *\n * @param current\n */\nconst splitCSSVariableRegex = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\nfunction parseCSSVariable(current) {\n    const match = splitCSSVariableRegex.exec(current);\n    if (!match)\n        return [,];\n    const [, token, fallback] = match;\n    return [token, fallback];\n}\nconst maxDepth = 4;\nfunction getVariableValue(current, element, depth = 1) {\n    exports.invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property \"${current}\". This may indicate a circular fallback dependency.`);\n    const [token, fallback] = parseCSSVariable(current);\n    // No CSS variable detected\n    if (!token)\n        return;\n    // Attempt to read this CSS variable off the element\n    const resolved = window.getComputedStyle(element).getPropertyValue(token);\n    if (resolved) {\n        const trimmed = resolved.trim();\n        return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;\n    }\n    else if (isCSSVariableToken(fallback)) {\n        // The fallback might itself be a CSS variable, in which case we attempt to resolve it too.\n        return getVariableValue(fallback, element, depth + 1);\n    }\n    else {\n        return fallback;\n    }\n}\n/**\n * Resolve CSS variables from\n *\n * @internal\n */\nfunction resolveCSSVariables(visualElement, { ...target }, transitionEnd) {\n    const element = visualElement.current;\n    if (!(element instanceof Element))\n        return { target, transitionEnd };\n    // If `transitionEnd` isn't `undefined`, clone it. We could clone `target` and `transitionEnd`\n    // only if they change but I think this reads clearer and this isn't a performance-critical path.\n    if (transitionEnd) {\n        transitionEnd = { ...transitionEnd };\n    }\n    // Go through existing `MotionValue`s and ensure any existing CSS variables are resolved\n    visualElement.values.forEach((value) => {\n        const current = value.get();\n        if (!isCSSVariableToken(current))\n            return;\n        const resolved = getVariableValue(current, element);\n        if (resolved)\n            value.set(resolved);\n    });\n    // Cycle through every target property and resolve CSS variables. Currently\n    // we only read single-var properties like `var(--foo)`, not `calc(var(--foo) + 20px)`\n    for (const key in target) {\n        const current = target[key];\n        if (!isCSSVariableToken(current))\n            continue;\n        const resolved = getVariableValue(current, element);\n        if (!resolved)\n            continue;\n        // Clone target if it hasn't already been\n        target[key] = resolved;\n        if (!transitionEnd)\n            transitionEnd = {};\n        // If the user hasn't already set this key on `transitionEnd`, set it to the unresolved\n        // CSS variable. This will ensure that after the animation the component will reflect\n        // changes in the value of the CSS variable.\n        if (transitionEnd[key] === undefined) {\n            transitionEnd[key] = current;\n        }\n    }\n    return { target, transitionEnd };\n}\n\nconst positionalKeys = new Set([\n    \"width\",\n    \"height\",\n    \"top\",\n    \"left\",\n    \"right\",\n    \"bottom\",\n    \"x\",\n    \"y\",\n    \"translateX\",\n    \"translateY\",\n]);\nconst isPositionalKey = (key) => positionalKeys.has(key);\nconst hasPositionalKey = (target) => {\n    return Object.keys(target).some(isPositionalKey);\n};\nconst isNumOrPxType = (v) => v === number || v === px;\nconst getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(\", \")[pos]);\nconst getTranslateFromMatrix = (pos2, pos3) => (_bbox, { transform }) => {\n    if (transform === \"none\" || !transform)\n        return 0;\n    const matrix3d = transform.match(/^matrix3d\\((.+)\\)$/);\n    if (matrix3d) {\n        return getPosFromMatrix(matrix3d[1], pos3);\n    }\n    else {\n        const matrix = transform.match(/^matrix\\((.+)\\)$/);\n        if (matrix) {\n            return getPosFromMatrix(matrix[1], pos2);\n        }\n        else {\n            return 0;\n        }\n    }\n};\nconst transformKeys = new Set([\"x\", \"y\", \"z\"]);\nconst nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));\nfunction removeNonTranslationalTransform(visualElement) {\n    const removedTransforms = [];\n    nonTranslationalTransformKeys.forEach((key) => {\n        const value = visualElement.getValue(key);\n        if (value !== undefined) {\n            removedTransforms.push([key, value.get()]);\n            value.set(key.startsWith(\"scale\") ? 1 : 0);\n        }\n    });\n    // Apply changes to element before measurement\n    if (removedTransforms.length)\n        visualElement.render();\n    return removedTransforms;\n}\nconst positionalValues = {\n    // Dimensions\n    width: ({ x }, { paddingLeft = \"0\", paddingRight = \"0\" }) => x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),\n    height: ({ y }, { paddingTop = \"0\", paddingBottom = \"0\" }) => y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),\n    top: (_bbox, { top }) => parseFloat(top),\n    left: (_bbox, { left }) => parseFloat(left),\n    bottom: ({ y }, { top }) => parseFloat(top) + (y.max - y.min),\n    right: ({ x }, { left }) => parseFloat(left) + (x.max - x.min),\n    // Transform\n    x: getTranslateFromMatrix(4, 13),\n    y: getTranslateFromMatrix(5, 14),\n};\n// Alias translate longform names\npositionalValues.translateX = positionalValues.x;\npositionalValues.translateY = positionalValues.y;\nconst convertChangedValueTypes = (target, visualElement, changedKeys) => {\n    const originBbox = visualElement.measureViewportBox();\n    const element = visualElement.current;\n    const elementComputedStyle = getComputedStyle(element);\n    const { display } = elementComputedStyle;\n    const origin = {};\n    // If the element is currently set to display: \"none\", make it visible before\n    // measuring the target bounding box\n    if (display === \"none\") {\n        visualElement.setStaticValue(\"display\", target.display || \"block\");\n    }\n    /**\n     * Record origins before we render and update styles\n     */\n    changedKeys.forEach((key) => {\n        origin[key] = positionalValues[key](originBbox, elementComputedStyle);\n    });\n    // Apply the latest values (as set in checkAndConvertChangedValueTypes)\n    visualElement.render();\n    const targetBbox = visualElement.measureViewportBox();\n    changedKeys.forEach((key) => {\n        // Restore styles to their **calculated computed style**, not their actual\n        // originally set style. This allows us to animate between equivalent pixel units.\n        const value = visualElement.getValue(key);\n        value && value.jump(origin[key]);\n        target[key] = positionalValues[key](targetBbox, elementComputedStyle);\n    });\n    return target;\n};\nconst checkAndConvertChangedValueTypes = (visualElement, target, origin = {}, transitionEnd = {}) => {\n    target = { ...target };\n    transitionEnd = { ...transitionEnd };\n    const targetPositionalKeys = Object.keys(target).filter(isPositionalKey);\n    // We want to remove any transform values that could affect the element's bounding box before\n    // it's measured. We'll reapply these later.\n    let removedTransformValues = [];\n    let hasAttemptedToRemoveTransformValues = false;\n    const changedValueTypeKeys = [];\n    targetPositionalKeys.forEach((key) => {\n        const value = visualElement.getValue(key);\n        if (!visualElement.hasValue(key))\n            return;\n        let from = origin[key];\n        let fromType = findDimensionValueType(from);\n        const to = target[key];\n        let toType;\n        // TODO: The current implementation of this basically throws an error\n        // if you try and do value conversion via keyframes. There's probably\n        // a way of doing this but the performance implications would need greater scrutiny,\n        // as it'd be doing multiple resize-remeasure operations.\n        if (isKeyframesTarget(to)) {\n            const numKeyframes = to.length;\n            const fromIndex = to[0] === null ? 1 : 0;\n            from = to[fromIndex];\n            fromType = findDimensionValueType(from);\n            for (let i = fromIndex; i < numKeyframes; i++) {\n                /**\n                 * Don't allow wildcard keyframes to be used to detect\n                 * a difference in value types.\n                 */\n                if (to[i] === null)\n                    break;\n                if (!toType) {\n                    toType = findDimensionValueType(to[i]);\n                    exports.invariant(toType === fromType ||\n                        (isNumOrPxType(fromType) && isNumOrPxType(toType)), \"Keyframes must be of the same dimension as the current value\");\n                }\n                else {\n                    exports.invariant(findDimensionValueType(to[i]) === toType, \"All keyframes must be of the same type\");\n                }\n            }\n        }\n        else {\n            toType = findDimensionValueType(to);\n        }\n        if (fromType !== toType) {\n            // If they're both just number or px, convert them both to numbers rather than\n            // relying on resize/remeasure to convert (which is wasteful in this situation)\n            if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\n                const current = value.get();\n                if (typeof current === \"string\") {\n                    value.set(parseFloat(current));\n                }\n                if (typeof to === \"string\") {\n                    target[key] = parseFloat(to);\n                }\n                else if (Array.isArray(to) && toType === px) {\n                    target[key] = to.map(parseFloat);\n                }\n            }\n            else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) &&\n                (toType === null || toType === void 0 ? void 0 : toType.transform) &&\n                (from === 0 || to === 0)) {\n                // If one or the other value is 0, it's safe to coerce it to the\n                // type of the other without measurement\n                if (from === 0) {\n                    value.set(toType.transform(from));\n                }\n                else {\n                    target[key] = fromType.transform(to);\n                }\n            }\n            else {\n                // If we're going to do value conversion via DOM measurements, we first\n                // need to remove non-positional transform values that could affect the bbox measurements.\n                if (!hasAttemptedToRemoveTransformValues) {\n                    removedTransformValues =\n                        removeNonTranslationalTransform(visualElement);\n                    hasAttemptedToRemoveTransformValues = true;\n                }\n                changedValueTypeKeys.push(key);\n                transitionEnd[key] =\n                    transitionEnd[key] !== undefined\n                        ? transitionEnd[key]\n                        : target[key];\n                value.jump(to);\n            }\n        }\n    });\n    if (changedValueTypeKeys.length) {\n        const scrollY = changedValueTypeKeys.indexOf(\"height\") >= 0\n            ? window.pageYOffset\n            : null;\n        const convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);\n        // If we removed transform values, reapply them before the next render\n        if (removedTransformValues.length) {\n            removedTransformValues.forEach(([key, value]) => {\n                visualElement.getValue(key).set(value);\n            });\n        }\n        // Reapply original values\n        visualElement.render();\n        // Restore scroll position\n        if (isBrowser && scrollY !== null) {\n            window.scrollTo({ top: scrollY });\n        }\n        return { target: convertedTarget, transitionEnd };\n    }\n    else {\n        return { target, transitionEnd };\n    }\n};\n/**\n * Convert value types for x/y/width/height/top/left/bottom/right\n *\n * Allows animation between `'auto'` -> `'100%'` or `0` -> `'calc(50% - 10vw)'`\n *\n * @internal\n */\nfunction unitConversion(visualElement, target, origin, transitionEnd) {\n    return hasPositionalKey(target)\n        ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd)\n        : { target, transitionEnd };\n}\n\n/**\n * Parse a DOM variant to make it animatable. This involves resolving CSS variables\n * and ensuring animations like \"20%\" => \"calc(50vw)\" are performed in pixels.\n */\nconst parseDomVariant = (visualElement, target, origin, transitionEnd) => {\n    const resolved = resolveCSSVariables(visualElement, target, transitionEnd);\n    target = resolved.target;\n    transitionEnd = resolved.transitionEnd;\n    return unitConversion(visualElement, target, origin, transitionEnd);\n};\n\n// Does this device prefer reduced motion? Returns `null` server-side.\nconst prefersReducedMotion = { current: null };\nconst hasReducedMotionListener = { current: false };\n\nfunction initPrefersReducedMotion() {\n    hasReducedMotionListener.current = true;\n    if (!isBrowser)\n        return;\n    if (window.matchMedia) {\n        const motionMediaQuery = window.matchMedia(\"(prefers-reduced-motion)\");\n        const setReducedMotionPreferences = () => (prefersReducedMotion.current = motionMediaQuery.matches);\n        motionMediaQuery.addListener(setReducedMotionPreferences);\n        setReducedMotionPreferences();\n    }\n    else {\n        prefersReducedMotion.current = false;\n    }\n}\n\nfunction updateMotionValuesFromProps(element, next, prev) {\n    const { willChange } = next;\n    for (const key in next) {\n        const nextValue = next[key];\n        const prevValue = prev[key];\n        if (isMotionValue(nextValue)) {\n            /**\n             * If this is a motion value found in props or style, we want to add it\n             * to our visual element's motion value map.\n             */\n            element.addValue(key, nextValue);\n            if (isWillChangeMotionValue(willChange)) {\n                willChange.add(key);\n            }\n            /**\n             * Check the version of the incoming motion value with this version\n             * and warn against mismatches.\n             */\n            if (process.env.NODE_ENV === \"development\") {\n                warnOnce(nextValue.version === \"10.18.0\", `Attempting to mix Framer Motion versions ${nextValue.version} with 10.18.0 may not work as expected.`);\n            }\n        }\n        else if (isMotionValue(prevValue)) {\n            /**\n             * If we're swapping from a motion value to a static value,\n             * create a new motion value from that\n             */\n            element.addValue(key, motionValue(nextValue, { owner: element }));\n            if (isWillChangeMotionValue(willChange)) {\n                willChange.remove(key);\n            }\n        }\n        else if (prevValue !== nextValue) {\n            /**\n             * If this is a flat value that has changed, update the motion value\n             * or create one if it doesn't exist. We only want to do this if we're\n             * not handling the value with our animation state.\n             */\n            if (element.hasValue(key)) {\n                const existingValue = element.getValue(key);\n                // TODO: Only update values that aren't being animated or even looked at\n                !existingValue.hasAnimated && existingValue.set(nextValue);\n            }\n            else {\n                const latestValue = element.getStaticValue(key);\n                element.addValue(key, motionValue(latestValue !== undefined ? latestValue : nextValue, { owner: element }));\n            }\n        }\n    }\n    // Handle removed values\n    for (const key in prev) {\n        if (next[key] === undefined)\n            element.removeValue(key);\n    }\n    return next;\n}\n\nconst featureNames = Object.keys(featureDefinitions);\nconst numFeatures = featureNames.length;\nconst propEventHandlers = [\n    \"AnimationStart\",\n    \"AnimationComplete\",\n    \"Update\",\n    \"BeforeLayoutMeasure\",\n    \"LayoutMeasure\",\n    \"LayoutAnimationStart\",\n    \"LayoutAnimationComplete\",\n];\nconst numVariantProps = variantProps.length;\n/**\n * A VisualElement is an imperative abstraction around UI elements such as\n * HTMLElement, SVGElement, Three.Object3D etc.\n */\nclass VisualElement {\n    constructor({ parent, props, presenceContext, reducedMotionConfig, visualState, }, options = {}) {\n        /**\n         * A reference to the current underlying Instance, e.g. a HTMLElement\n         * or Three.Mesh etc.\n         */\n        this.current = null;\n        /**\n         * A set containing references to this VisualElement's children.\n         */\n        this.children = new Set();\n        /**\n         * Determine what role this visual element should take in the variant tree.\n         */\n        this.isVariantNode = false;\n        this.isControllingVariants = false;\n        /**\n         * Decides whether this VisualElement should animate in reduced motion\n         * mode.\n         *\n         * TODO: This is currently set on every individual VisualElement but feels\n         * like it could be set globally.\n         */\n        this.shouldReduceMotion = null;\n        /**\n         * A map of all motion values attached to this visual element. Motion\n         * values are source of truth for any given animated value. A motion\n         * value might be provided externally by the component via props.\n         */\n        this.values = new Map();\n        /**\n         * Cleanup functions for active features (hover/tap/exit etc)\n         */\n        this.features = {};\n        /**\n         * A map of every subscription that binds the provided or generated\n         * motion values onChange listeners to this visual element.\n         */\n        this.valueSubscriptions = new Map();\n        /**\n         * A reference to the previously-provided motion values as returned\n         * from scrapeMotionValuesFromProps. We use the keys in here to determine\n         * if any motion values need to be removed after props are updated.\n         */\n        this.prevMotionValues = {};\n        /**\n         * An object containing a SubscriptionManager for each active event.\n         */\n        this.events = {};\n        /**\n         * An object containing an unsubscribe function for each prop event subscription.\n         * For example, every \"Update\" event can have multiple subscribers via\n         * VisualElement.on(), but only one of those can be defined via the onUpdate prop.\n         */\n        this.propEventSubscriptions = {};\n        this.notifyUpdate = () => this.notify(\"Update\", this.latestValues);\n        this.render = () => {\n            if (!this.current)\n                return;\n            this.triggerBuild();\n            this.renderInstance(this.current, this.renderState, this.props.style, this.projection);\n        };\n        this.scheduleRender = () => frame.render(this.render, false, true);\n        const { latestValues, renderState } = visualState;\n        this.latestValues = latestValues;\n        this.baseTarget = { ...latestValues };\n        this.initialValues = props.initial ? { ...latestValues } : {};\n        this.renderState = renderState;\n        this.parent = parent;\n        this.props = props;\n        this.presenceContext = presenceContext;\n        this.depth = parent ? parent.depth + 1 : 0;\n        this.reducedMotionConfig = reducedMotionConfig;\n        this.options = options;\n        this.isControllingVariants = isControllingVariants(props);\n        this.isVariantNode = isVariantNode(props);\n        if (this.isVariantNode) {\n            this.variantChildren = new Set();\n        }\n        this.manuallyAnimateOnMount = Boolean(parent && parent.current);\n        /**\n         * Any motion values that are provided to the element when created\n         * aren't yet bound to the element, as this would technically be impure.\n         * However, we iterate through the motion values and set them to the\n         * initial values for this component.\n         *\n         * TODO: This is impure and we should look at changing this to run on mount.\n         * Doing so will break some tests but this isn't neccessarily a breaking change,\n         * more a reflection of the test.\n         */\n        const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {});\n        for (const key in initialMotionValues) {\n            const value = initialMotionValues[key];\n            if (latestValues[key] !== undefined && isMotionValue(value)) {\n                value.set(latestValues[key], false);\n                if (isWillChangeMotionValue(willChange)) {\n                    willChange.add(key);\n                }\n            }\n        }\n    }\n    /**\n     * This method takes React props and returns found MotionValues. For example, HTML\n     * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.\n     *\n     * This isn't an abstract method as it needs calling in the constructor, but it is\n     * intended to be one.\n     */\n    scrapeMotionValuesFromProps(_props, _prevProps) {\n        return {};\n    }\n    mount(instance) {\n        this.current = instance;\n        visualElementStore.set(instance, this);\n        if (this.projection && !this.projection.instance) {\n            this.projection.mount(instance);\n        }\n        if (this.parent && this.isVariantNode && !this.isControllingVariants) {\n            this.removeFromVariantTree = this.parent.addVariantChild(this);\n        }\n        this.values.forEach((value, key) => this.bindToMotionValue(key, value));\n        if (!hasReducedMotionListener.current) {\n            initPrefersReducedMotion();\n        }\n        this.shouldReduceMotion =\n            this.reducedMotionConfig === \"never\"\n                ? false\n                : this.reducedMotionConfig === \"always\"\n                    ? true\n                    : prefersReducedMotion.current;\n        if (process.env.NODE_ENV !== \"production\") {\n            warnOnce(this.shouldReduceMotion !== true, \"You have Reduced Motion enabled on your device. Animations may not appear as expected.\");\n        }\n        if (this.parent)\n            this.parent.children.add(this);\n        this.update(this.props, this.presenceContext);\n    }\n    unmount() {\n        visualElementStore.delete(this.current);\n        this.projection && this.projection.unmount();\n        cancelFrame(this.notifyUpdate);\n        cancelFrame(this.render);\n        this.valueSubscriptions.forEach((remove) => remove());\n        this.removeFromVariantTree && this.removeFromVariantTree();\n        this.parent && this.parent.children.delete(this);\n        for (const key in this.events) {\n            this.events[key].clear();\n        }\n        for (const key in this.features) {\n            this.features[key].unmount();\n        }\n        this.current = null;\n    }\n    bindToMotionValue(key, value) {\n        const valueIsTransform = transformProps.has(key);\n        const removeOnChange = value.on(\"change\", (latestValue) => {\n            this.latestValues[key] = latestValue;\n            this.props.onUpdate &&\n                frame.update(this.notifyUpdate, false, true);\n            if (valueIsTransform && this.projection) {\n                this.projection.isTransformDirty = true;\n            }\n        });\n        const removeOnRenderRequest = value.on(\"renderRequest\", this.scheduleRender);\n        this.valueSubscriptions.set(key, () => {\n            removeOnChange();\n            removeOnRenderRequest();\n        });\n    }\n    sortNodePosition(other) {\n        /**\n         * If these nodes aren't even of the same type we can't compare their depth.\n         */\n        if (!this.current ||\n            !this.sortInstanceNodePosition ||\n            this.type !== other.type) {\n            return 0;\n        }\n        return this.sortInstanceNodePosition(this.current, other.current);\n    }\n    loadFeatures({ children, ...renderedProps }, isStrict, preloadedFeatures, initialLayoutGroupConfig) {\n        let ProjectionNodeConstructor;\n        let MeasureLayout;\n        /**\n         * If we're in development mode, check to make sure we're not rendering a motion component\n         * as a child of LazyMotion, as this will break the file-size benefits of using it.\n         */\n        if (process.env.NODE_ENV !== \"production\" &&\n            preloadedFeatures &&\n            isStrict) {\n            const strictMessage = \"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.\";\n            renderedProps.ignoreStrict\n                ? exports.warning(false, strictMessage)\n                : exports.invariant(false, strictMessage);\n        }\n        for (let i = 0; i < numFeatures; i++) {\n            const name = featureNames[i];\n            const { isEnabled, Feature: FeatureConstructor, ProjectionNode, MeasureLayout: MeasureLayoutComponent, } = featureDefinitions[name];\n            if (ProjectionNode)\n                ProjectionNodeConstructor = ProjectionNode;\n            if (isEnabled(renderedProps)) {\n                if (!this.features[name] && FeatureConstructor) {\n                    this.features[name] = new FeatureConstructor(this);\n                }\n                if (MeasureLayoutComponent) {\n                    MeasureLayout = MeasureLayoutComponent;\n                }\n            }\n        }\n        if ((this.type === \"html\" || this.type === \"svg\") &&\n            !this.projection &&\n            ProjectionNodeConstructor) {\n            this.projection = new ProjectionNodeConstructor(this.latestValues, this.parent && this.parent.projection);\n            const { layoutId, layout, drag, dragConstraints, layoutScroll, layoutRoot, } = renderedProps;\n            this.projection.setOptions({\n                layoutId,\n                layout,\n                alwaysMeasureLayout: Boolean(drag) ||\n                    (dragConstraints && isRefObject(dragConstraints)),\n                visualElement: this,\n                scheduleRender: () => this.scheduleRender(),\n                /**\n                 * TODO: Update options in an effect. This could be tricky as it'll be too late\n                 * to update by the time layout animations run.\n                 * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,\n                 * ensuring it gets called if there's no potential layout animations.\n                 *\n                 */\n                animationType: typeof layout === \"string\" ? layout : \"both\",\n                initialPromotionConfig: initialLayoutGroupConfig,\n                layoutScroll,\n                layoutRoot,\n            });\n        }\n        return MeasureLayout;\n    }\n    updateFeatures() {\n        for (const key in this.features) {\n            const feature = this.features[key];\n            if (feature.isMounted) {\n                feature.update();\n            }\n            else {\n                feature.mount();\n                feature.isMounted = true;\n            }\n        }\n    }\n    triggerBuild() {\n        this.build(this.renderState, this.latestValues, this.options, this.props);\n    }\n    /**\n     * Measure the current viewport box with or without transforms.\n     * Only measures axis-aligned boxes, rotate and skew must be manually\n     * removed with a re-render to work.\n     */\n    measureViewportBox() {\n        return this.current\n            ? this.measureInstanceViewportBox(this.current, this.props)\n            : createBox();\n    }\n    getStaticValue(key) {\n        return this.latestValues[key];\n    }\n    setStaticValue(key, value) {\n        this.latestValues[key] = value;\n    }\n    /**\n     * Make a target animatable by Popmotion. For instance, if we're\n     * trying to animate width from 100px to 100vw we need to measure 100vw\n     * in pixels to determine what we really need to animate to. This is also\n     * pluggable to support Framer's custom value types like Color,\n     * and CSS variables.\n     */\n    makeTargetAnimatable(target, canMutate = true) {\n        return this.makeTargetAnimatableFromInstance(target, this.props, canMutate);\n    }\n    /**\n     * Update the provided props. Ensure any newly-added motion values are\n     * added to our map, old ones removed, and listeners updated.\n     */\n    update(props, presenceContext) {\n        if (props.transformTemplate || this.props.transformTemplate) {\n            this.scheduleRender();\n        }\n        this.prevProps = this.props;\n        this.props = props;\n        this.prevPresenceContext = this.presenceContext;\n        this.presenceContext = presenceContext;\n        /**\n         * Update prop event handlers ie onAnimationStart, onAnimationComplete\n         */\n        for (let i = 0; i < propEventHandlers.length; i++) {\n            const key = propEventHandlers[i];\n            if (this.propEventSubscriptions[key]) {\n                this.propEventSubscriptions[key]();\n                delete this.propEventSubscriptions[key];\n            }\n            const listener = props[\"on\" + key];\n            if (listener) {\n                this.propEventSubscriptions[key] = this.on(key, listener);\n            }\n        }\n        this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps), this.prevMotionValues);\n        if (this.handleChildMotionValue) {\n            this.handleChildMotionValue();\n        }\n    }\n    getProps() {\n        return this.props;\n    }\n    /**\n     * Returns the variant definition with a given name.\n     */\n    getVariant(name) {\n        return this.props.variants ? this.props.variants[name] : undefined;\n    }\n    /**\n     * Returns the defined default transition on this component.\n     */\n    getDefaultTransition() {\n        return this.props.transition;\n    }\n    getTransformPagePoint() {\n        return this.props.transformPagePoint;\n    }\n    getClosestVariantNode() {\n        return this.isVariantNode\n            ? this\n            : this.parent\n                ? this.parent.getClosestVariantNode()\n                : undefined;\n    }\n    getVariantContext(startAtParent = false) {\n        if (startAtParent) {\n            return this.parent ? this.parent.getVariantContext() : undefined;\n        }\n        if (!this.isControllingVariants) {\n            const context = this.parent\n                ? this.parent.getVariantContext() || {}\n                : {};\n            if (this.props.initial !== undefined) {\n                context.initial = this.props.initial;\n            }\n            return context;\n        }\n        const context = {};\n        for (let i = 0; i < numVariantProps; i++) {\n            const name = variantProps[i];\n            const prop = this.props[name];\n            if (isVariantLabel(prop) || prop === false) {\n                context[name] = prop;\n            }\n        }\n        return context;\n    }\n    /**\n     * Add a child visual element to our set of children.\n     */\n    addVariantChild(child) {\n        const closestVariantNode = this.getClosestVariantNode();\n        if (closestVariantNode) {\n            closestVariantNode.variantChildren &&\n                closestVariantNode.variantChildren.add(child);\n            return () => closestVariantNode.variantChildren.delete(child);\n        }\n    }\n    /**\n     * Add a motion value and bind it to this visual element.\n     */\n    addValue(key, value) {\n        // Remove existing value if it exists\n        if (value !== this.values.get(key)) {\n            this.removeValue(key);\n            this.bindToMotionValue(key, value);\n        }\n        this.values.set(key, value);\n        this.latestValues[key] = value.get();\n    }\n    /**\n     * Remove a motion value and unbind any active subscriptions.\n     */\n    removeValue(key) {\n        this.values.delete(key);\n        const unsubscribe = this.valueSubscriptions.get(key);\n        if (unsubscribe) {\n            unsubscribe();\n            this.valueSubscriptions.delete(key);\n        }\n        delete this.latestValues[key];\n        this.removeValueFromRenderState(key, this.renderState);\n    }\n    /**\n     * Check whether we have a motion value for this key\n     */\n    hasValue(key) {\n        return this.values.has(key);\n    }\n    getValue(key, defaultValue) {\n        if (this.props.values && this.props.values[key]) {\n            return this.props.values[key];\n        }\n        let value = this.values.get(key);\n        if (value === undefined && defaultValue !== undefined) {\n            value = motionValue(defaultValue, { owner: this });\n            this.addValue(key, value);\n        }\n        return value;\n    }\n    /**\n     * If we're trying to animate to a previously unencountered value,\n     * we need to check for it in our state and as a last resort read it\n     * directly from the instance (which might have performance implications).\n     */\n    readValue(key) {\n        var _a;\n        return this.latestValues[key] !== undefined || !this.current\n            ? this.latestValues[key]\n            : (_a = this.getBaseTargetFromProps(this.props, key)) !== null && _a !== void 0 ? _a : this.readValueFromInstance(this.current, key, this.options);\n    }\n    /**\n     * Set the base target to later animate back to. This is currently\n     * only hydrated on creation and when we first read a value.\n     */\n    setBaseTarget(key, value) {\n        this.baseTarget[key] = value;\n    }\n    /**\n     * Find the base target for a value thats been removed from all animation\n     * props.\n     */\n    getBaseTarget(key) {\n        var _a;\n        const { initial } = this.props;\n        const valueFromInitial = typeof initial === \"string\" || typeof initial === \"object\"\n            ? (_a = resolveVariantFromProps(this.props, initial)) === null || _a === void 0 ? void 0 : _a[key]\n            : undefined;\n        /**\n         * If this value still exists in the current initial variant, read that.\n         */\n        if (initial && valueFromInitial !== undefined) {\n            return valueFromInitial;\n        }\n        /**\n         * Alternatively, if this VisualElement config has defined a getBaseTarget\n         * so we can read the value from an alternative source, try that.\n         */\n        const target = this.getBaseTargetFromProps(this.props, key);\n        if (target !== undefined && !isMotionValue(target))\n            return target;\n        /**\n         * If the value was initially defined on initial, but it doesn't any more,\n         * return undefined. Otherwise return the value as initially read from the DOM.\n         */\n        return this.initialValues[key] !== undefined &&\n            valueFromInitial === undefined\n            ? undefined\n            : this.baseTarget[key];\n    }\n    on(eventName, callback) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = new SubscriptionManager();\n        }\n        return this.events[eventName].add(callback);\n    }\n    notify(eventName, ...args) {\n        if (this.events[eventName]) {\n            this.events[eventName].notify(...args);\n        }\n    }\n}\n\nclass DOMVisualElement extends VisualElement {\n    sortInstanceNodePosition(a, b) {\n        /**\n         * compareDocumentPosition returns a bitmask, by using the bitwise &\n         * we're returning true if 2 in that bitmask is set to true. 2 is set\n         * to true if b preceeds a.\n         */\n        return a.compareDocumentPosition(b) & 2 ? 1 : -1;\n    }\n    getBaseTargetFromProps(props, key) {\n        return props.style ? props.style[key] : undefined;\n    }\n    removeValueFromRenderState(key, { vars, style }) {\n        delete vars[key];\n        delete style[key];\n    }\n    makeTargetAnimatableFromInstance({ transition, transitionEnd, ...target }, { transformValues }, isMounted) {\n        let origin = getOrigin(target, transition || {}, this);\n        /**\n         * If Framer has provided a function to convert `Color` etc value types, convert them\n         */\n        if (transformValues) {\n            if (transitionEnd)\n                transitionEnd = transformValues(transitionEnd);\n            if (target)\n                target = transformValues(target);\n            if (origin)\n                origin = transformValues(origin);\n        }\n        if (isMounted) {\n            checkTargetForNewValues(this, target, origin);\n            const parsed = parseDomVariant(this, target, origin, transitionEnd);\n            transitionEnd = parsed.transitionEnd;\n            target = parsed.target;\n        }\n        return {\n            transition,\n            transitionEnd,\n            ...target,\n        };\n    }\n}\n\nclass SVGVisualElement extends DOMVisualElement {\n    constructor() {\n        super(...arguments);\n        this.type = \"svg\";\n        this.isSVGTag = false;\n    }\n    getBaseTargetFromProps(props, key) {\n        return props[key];\n    }\n    readValueFromInstance(instance, key) {\n        if (transformProps.has(key)) {\n            const defaultType = getDefaultValueType(key);\n            return defaultType ? defaultType.default || 0 : 0;\n        }\n        key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;\n        return instance.getAttribute(key);\n    }\n    measureInstanceViewportBox() {\n        return createBox();\n    }\n    scrapeMotionValuesFromProps(props, prevProps) {\n        return scrapeMotionValuesFromProps(props, prevProps);\n    }\n    build(renderState, latestValues, options, props) {\n        buildSVGAttrs(renderState, latestValues, options, this.isSVGTag, props.transformTemplate);\n    }\n    renderInstance(instance, renderState, styleProp, projection) {\n        renderSVG(instance, renderState, styleProp, projection);\n    }\n    mount(instance) {\n        this.isSVGTag = isSVGTag(instance.tagName);\n        super.mount(instance);\n    }\n}\n\nfunction getComputedStyle$1(element) {\n    return window.getComputedStyle(element);\n}\nclass HTMLVisualElement extends DOMVisualElement {\n    constructor() {\n        super(...arguments);\n        this.type = \"html\";\n    }\n    readValueFromInstance(instance, key) {\n        if (transformProps.has(key)) {\n            const defaultType = getDefaultValueType(key);\n            return defaultType ? defaultType.default || 0 : 0;\n        }\n        else {\n            const computedStyle = getComputedStyle$1(instance);\n            const value = (isCSSVariableName(key)\n                ? computedStyle.getPropertyValue(key)\n                : computedStyle[key]) || 0;\n            return typeof value === \"string\" ? value.trim() : value;\n        }\n    }\n    measureInstanceViewportBox(instance, { transformPagePoint }) {\n        return measureViewportBox(instance, transformPagePoint);\n    }\n    build(renderState, latestValues, options, props) {\n        buildHTMLStyles(renderState, latestValues, options, props.transformTemplate);\n    }\n    scrapeMotionValuesFromProps(props, prevProps) {\n        return scrapeMotionValuesFromProps$1(props, prevProps);\n    }\n    handleChildMotionValue() {\n        if (this.childSubscription) {\n            this.childSubscription();\n            delete this.childSubscription;\n        }\n        const { children } = this.props;\n        if (isMotionValue(children)) {\n            this.childSubscription = children.on(\"change\", (latest) => {\n                if (this.current)\n                    this.current.textContent = `${latest}`;\n            });\n        }\n    }\n    renderInstance(instance, renderState, styleProp, projection) {\n        renderHTML(instance, renderState, styleProp, projection);\n    }\n}\n\nfunction createVisualElement(element) {\n    const options = {\n        presenceContext: null,\n        props: {},\n        visualState: {\n            renderState: {\n                transform: {},\n                transformOrigin: {},\n                style: {},\n                vars: {},\n                attrs: {},\n            },\n            latestValues: {},\n        },\n    };\n    const node = isSVGElement(element)\n        ? new SVGVisualElement(options, {\n            enableHardwareAcceleration: false,\n        })\n        : new HTMLVisualElement(options, {\n            enableHardwareAcceleration: true,\n        });\n    node.mount(element);\n    visualElementStore.set(element, node);\n}\n\nfunction animateSingleValue(value, keyframes, options) {\n    const motionValue$1 = isMotionValue(value) ? value : motionValue(value);\n    motionValue$1.start(animateMotionValue(\"\", motionValue$1, keyframes, options));\n    return motionValue$1.animation;\n}\n\n/**\n * Create a progress => progress easing function from a generator.\n */\nfunction createGeneratorEasing(options, scale = 100) {\n    const generator = spring({ keyframes: [0, scale], ...options });\n    const duration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);\n    return {\n        type: \"keyframes\",\n        ease: (progress) => generator.next(duration * progress).value / scale,\n        duration: millisecondsToSeconds(duration),\n    };\n}\n\n/**\n * Given a absolute or relative time definition and current/prev time state of the sequence,\n * calculate an absolute time for the next keyframes.\n */\nfunction calcNextTime(current, next, prev, labels) {\n    var _a;\n    if (typeof next === \"number\") {\n        return next;\n    }\n    else if (next.startsWith(\"-\") || next.startsWith(\"+\")) {\n        return Math.max(0, current + parseFloat(next));\n    }\n    else if (next === \"<\") {\n        return prev;\n    }\n    else {\n        return (_a = labels.get(next)) !== null && _a !== void 0 ? _a : current;\n    }\n}\n\nconst wrap = (min, max, v) => {\n    const rangeSize = max - min;\n    return ((((v - min) % rangeSize) + rangeSize) % rangeSize) + min;\n};\n\nfunction getEasingForSegment(easing, i) {\n    return isEasingArray(easing) ? easing[wrap(0, easing.length, i)] : easing;\n}\n\nfunction eraseKeyframes(sequence, startTime, endTime) {\n    for (let i = 0; i < sequence.length; i++) {\n        const keyframe = sequence[i];\n        if (keyframe.at > startTime && keyframe.at < endTime) {\n            removeItem(sequence, keyframe);\n            // If we remove this item we have to push the pointer back one\n            i--;\n        }\n    }\n}\nfunction addKeyframes(sequence, keyframes, easing, offset, startTime, endTime) {\n    /**\n     * Erase every existing value between currentTime and targetTime,\n     * this will essentially splice this timeline into any currently\n     * defined ones.\n     */\n    eraseKeyframes(sequence, startTime, endTime);\n    for (let i = 0; i < keyframes.length; i++) {\n        sequence.push({\n            value: keyframes[i],\n            at: mix(startTime, endTime, offset[i]),\n            easing: getEasingForSegment(easing, i),\n        });\n    }\n}\n\nfunction compareByTime(a, b) {\n    if (a.at === b.at) {\n        if (a.value === null)\n            return 1;\n        if (b.value === null)\n            return -1;\n        return 0;\n    }\n    else {\n        return a.at - b.at;\n    }\n}\n\nconst defaultSegmentEasing = \"easeInOut\";\nfunction createAnimationsFromSequence(sequence, { defaultTransition = {}, ...sequenceTransition } = {}, scope) {\n    const defaultDuration = defaultTransition.duration || 0.3;\n    const animationDefinitions = new Map();\n    const sequences = new Map();\n    const elementCache = {};\n    const timeLabels = new Map();\n    let prevTime = 0;\n    let currentTime = 0;\n    let totalDuration = 0;\n    /**\n     * Build the timeline by mapping over the sequence array and converting\n     * the definitions into keyframes and offsets with absolute time values.\n     * These will later get converted into relative offsets in a second pass.\n     */\n    for (let i = 0; i < sequence.length; i++) {\n        const segment = sequence[i];\n        /**\n         * If this is a timeline label, mark it and skip the rest of this iteration.\n         */\n        if (typeof segment === \"string\") {\n            timeLabels.set(segment, currentTime);\n            continue;\n        }\n        else if (!Array.isArray(segment)) {\n            timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));\n            continue;\n        }\n        let [subject, keyframes, transition = {}] = segment;\n        /**\n         * If a relative or absolute time value has been specified we need to resolve\n         * it in relation to the currentTime.\n         */\n        if (transition.at !== undefined) {\n            currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels);\n        }\n        /**\n         * Keep track of the maximum duration in this definition. This will be\n         * applied to currentTime once the definition has been parsed.\n         */\n        let maxDuration = 0;\n        const resolveValueSequence = (valueKeyframes, valueTransition, valueSequence, elementIndex = 0, numElements = 0) => {\n            const valueKeyframesAsList = keyframesAsList(valueKeyframes);\n            const { delay = 0, times = defaultOffset$1(valueKeyframesAsList), type = \"keyframes\", ...remainingTransition } = valueTransition;\n            let { ease = defaultTransition.ease || \"easeOut\", duration } = valueTransition;\n            /**\n             * Resolve stagger() if defined.\n             */\n            const calculatedDelay = typeof delay === \"function\"\n                ? delay(elementIndex, numElements)\n                : delay;\n            /**\n             * If this animation should and can use a spring, generate a spring easing function.\n             */\n            const numKeyframes = valueKeyframesAsList.length;\n            if (numKeyframes <= 2 && type === \"spring\") {\n                /**\n                 * As we're creating an easing function from a spring,\n                 * ideally we want to generate it using the real distance\n                 * between the two keyframes. However this isn't always\n                 * possible - in these situations we use 0-100.\n                 */\n                let absoluteDelta = 100;\n                if (numKeyframes === 2 &&\n                    isNumberKeyframesArray(valueKeyframesAsList)) {\n                    const delta = valueKeyframesAsList[1] - valueKeyframesAsList[0];\n                    absoluteDelta = Math.abs(delta);\n                }\n                const springTransition = { ...remainingTransition };\n                if (duration !== undefined) {\n                    springTransition.duration = secondsToMilliseconds(duration);\n                }\n                const springEasing = createGeneratorEasing(springTransition, absoluteDelta);\n                ease = springEasing.ease;\n                duration = springEasing.duration;\n            }\n            duration !== null && duration !== void 0 ? duration : (duration = defaultDuration);\n            const startTime = currentTime + calculatedDelay;\n            const targetTime = startTime + duration;\n            /**\n             * If there's only one time offset of 0, fill in a second with length 1\n             */\n            if (times.length === 1 && times[0] === 0) {\n                times[1] = 1;\n            }\n            /**\n             * Fill out if offset if fewer offsets than keyframes\n             */\n            const remainder = times.length - valueKeyframesAsList.length;\n            remainder > 0 && fillOffset(times, remainder);\n            /**\n             * If only one value has been set, ie [1], push a null to the start of\n             * the keyframe array. This will let us mark a keyframe at this point\n             * that will later be hydrated with the previous value.\n             */\n            valueKeyframesAsList.length === 1 &&\n                valueKeyframesAsList.unshift(null);\n            /**\n             * Add keyframes, mapping offsets to absolute time.\n             */\n            addKeyframes(valueSequence, valueKeyframesAsList, ease, times, startTime, targetTime);\n            maxDuration = Math.max(calculatedDelay + duration, maxDuration);\n            totalDuration = Math.max(targetTime, totalDuration);\n        };\n        if (isMotionValue(subject)) {\n            const subjectSequence = getSubjectSequence(subject, sequences);\n            resolveValueSequence(keyframes, transition, getValueSequence(\"default\", subjectSequence));\n        }\n        else {\n            /**\n             * Find all the elements specified in the definition and parse value\n             * keyframes from their timeline definitions.\n             */\n            const elements = resolveElements(subject, scope, elementCache);\n            const numElements = elements.length;\n            /**\n             * For every element in this segment, process the defined values.\n             */\n            for (let elementIndex = 0; elementIndex < numElements; elementIndex++) {\n                /**\n                 * Cast necessary, but we know these are of this type\n                 */\n                keyframes = keyframes;\n                transition = transition;\n                const element = elements[elementIndex];\n                const subjectSequence = getSubjectSequence(element, sequences);\n                for (const key in keyframes) {\n                    resolveValueSequence(keyframes[key], getValueTransition(transition, key), getValueSequence(key, subjectSequence), elementIndex, numElements);\n                }\n            }\n        }\n        prevTime = currentTime;\n        currentTime += maxDuration;\n    }\n    /**\n     * For every element and value combination create a new animation.\n     */\n    sequences.forEach((valueSequences, element) => {\n        for (const key in valueSequences) {\n            const valueSequence = valueSequences[key];\n            /**\n             * Arrange all the keyframes in ascending time order.\n             */\n            valueSequence.sort(compareByTime);\n            const keyframes = [];\n            const valueOffset = [];\n            const valueEasing = [];\n            /**\n             * For each keyframe, translate absolute times into\n             * relative offsets based on the total duration of the timeline.\n             */\n            for (let i = 0; i < valueSequence.length; i++) {\n                const { at, value, easing } = valueSequence[i];\n                keyframes.push(value);\n                valueOffset.push(progress(0, totalDuration, at));\n                valueEasing.push(easing || \"easeOut\");\n            }\n            /**\n             * If the first keyframe doesn't land on offset: 0\n             * provide one by duplicating the initial keyframe. This ensures\n             * it snaps to the first keyframe when the animation starts.\n             */\n            if (valueOffset[0] !== 0) {\n                valueOffset.unshift(0);\n                keyframes.unshift(keyframes[0]);\n                valueEasing.unshift(defaultSegmentEasing);\n            }\n            /**\n             * If the last keyframe doesn't land on offset: 1\n             * provide one with a null wildcard value. This will ensure it\n             * stays static until the end of the animation.\n             */\n            if (valueOffset[valueOffset.length - 1] !== 1) {\n                valueOffset.push(1);\n                keyframes.push(null);\n            }\n            if (!animationDefinitions.has(element)) {\n                animationDefinitions.set(element, {\n                    keyframes: {},\n                    transition: {},\n                });\n            }\n            const definition = animationDefinitions.get(element);\n            definition.keyframes[key] = keyframes;\n            definition.transition[key] = {\n                ...defaultTransition,\n                duration: totalDuration,\n                ease: valueEasing,\n                times: valueOffset,\n                ...sequenceTransition,\n            };\n        }\n    });\n    return animationDefinitions;\n}\nfunction getSubjectSequence(subject, sequences) {\n    !sequences.has(subject) && sequences.set(subject, {});\n    return sequences.get(subject);\n}\nfunction getValueSequence(name, sequences) {\n    if (!sequences[name])\n        sequences[name] = [];\n    return sequences[name];\n}\nfunction keyframesAsList(keyframes) {\n    return Array.isArray(keyframes) ? keyframes : [keyframes];\n}\nfunction getValueTransition(transition, key) {\n    return transition[key]\n        ? { ...transition, ...transition[key] }\n        : { ...transition };\n}\nconst isNumber = (keyframe) => typeof keyframe === \"number\";\nconst isNumberKeyframesArray = (keyframes) => keyframes.every(isNumber);\n\nfunction animateElements(elementOrSelector, keyframes, options, scope) {\n    const elements = resolveElements(elementOrSelector, scope);\n    const numElements = elements.length;\n    exports.invariant(Boolean(numElements), \"No valid element provided.\");\n    const animations = [];\n    for (let i = 0; i < numElements; i++) {\n        const element = elements[i];\n        /**\n         * Check each element for an associated VisualElement. If none exists,\n         * we need to create one.\n         */\n        if (!visualElementStore.has(element)) {\n            /**\n             * TODO: We only need render-specific parts of the VisualElement.\n             * With some additional work the size of the animate() function\n             * could be reduced significantly.\n             */\n            createVisualElement(element);\n        }\n        const visualElement = visualElementStore.get(element);\n        const transition = { ...options };\n        /**\n         * Resolve stagger function if provided.\n         */\n        if (typeof transition.delay === \"function\") {\n            transition.delay = transition.delay(i, numElements);\n        }\n        animations.push(...animateTarget(visualElement, { ...keyframes, transition }, {}));\n    }\n    return new GroupPlaybackControls(animations);\n}\nconst isSequence = (value) => Array.isArray(value) && Array.isArray(value[0]);\nfunction animateSequence(sequence, options, scope) {\n    const animations = [];\n    const animationDefinitions = createAnimationsFromSequence(sequence, options, scope);\n    animationDefinitions.forEach(({ keyframes, transition }, subject) => {\n        let animation;\n        if (isMotionValue(subject)) {\n            animation = animateSingleValue(subject, keyframes.default, transition.default);\n        }\n        else {\n            animation = animateElements(subject, keyframes, transition);\n        }\n        animations.push(animation);\n    });\n    return new GroupPlaybackControls(animations);\n}\nconst createScopedAnimate = (scope) => {\n    /**\n     * Implementation\n     */\n    function scopedAnimate(valueOrElementOrSequence, keyframes, options) {\n        let animation;\n        if (isSequence(valueOrElementOrSequence)) {\n            animation = animateSequence(valueOrElementOrSequence, keyframes, scope);\n        }\n        else if (isDOMKeyframes(keyframes)) {\n            animation = animateElements(valueOrElementOrSequence, keyframes, options, scope);\n        }\n        else {\n            animation = animateSingleValue(valueOrElementOrSequence, keyframes, options);\n        }\n        if (scope) {\n            scope.animations.push(animation);\n        }\n        return animation;\n    }\n    return scopedAnimate;\n};\nconst animate = createScopedAnimate();\n\nconst resizeHandlers = new WeakMap();\nlet observer;\nfunction getElementSize(target, borderBoxSize) {\n    if (borderBoxSize) {\n        const { inlineSize, blockSize } = borderBoxSize[0];\n        return { width: inlineSize, height: blockSize };\n    }\n    else if (target instanceof SVGElement && \"getBBox\" in target) {\n        return target.getBBox();\n    }\n    else {\n        return {\n            width: target.offsetWidth,\n            height: target.offsetHeight,\n        };\n    }\n}\nfunction notifyTarget({ target, contentRect, borderBoxSize, }) {\n    var _a;\n    (_a = resizeHandlers.get(target)) === null || _a === void 0 ? void 0 : _a.forEach((handler) => {\n        handler({\n            target,\n            contentSize: contentRect,\n            get size() {\n                return getElementSize(target, borderBoxSize);\n            },\n        });\n    });\n}\nfunction notifyAll(entries) {\n    entries.forEach(notifyTarget);\n}\nfunction createResizeObserver() {\n    if (typeof ResizeObserver === \"undefined\")\n        return;\n    observer = new ResizeObserver(notifyAll);\n}\nfunction resizeElement(target, handler) {\n    if (!observer)\n        createResizeObserver();\n    const elements = resolveElements(target);\n    elements.forEach((element) => {\n        let elementHandlers = resizeHandlers.get(element);\n        if (!elementHandlers) {\n            elementHandlers = new Set();\n            resizeHandlers.set(element, elementHandlers);\n        }\n        elementHandlers.add(handler);\n        observer === null || observer === void 0 ? void 0 : observer.observe(element);\n    });\n    return () => {\n        elements.forEach((element) => {\n            const elementHandlers = resizeHandlers.get(element);\n            elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.delete(handler);\n            if (!(elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.size)) {\n                observer === null || observer === void 0 ? void 0 : observer.unobserve(element);\n            }\n        });\n    };\n}\n\nconst windowCallbacks = new Set();\nlet windowResizeHandler;\nfunction createWindowResizeHandler() {\n    windowResizeHandler = () => {\n        const size = {\n            width: window.innerWidth,\n            height: window.innerHeight,\n        };\n        const info = {\n            target: window,\n            size,\n            contentSize: size,\n        };\n        windowCallbacks.forEach((callback) => callback(info));\n    };\n    window.addEventListener(\"resize\", windowResizeHandler);\n}\nfunction resizeWindow(callback) {\n    windowCallbacks.add(callback);\n    if (!windowResizeHandler)\n        createWindowResizeHandler();\n    return () => {\n        windowCallbacks.delete(callback);\n        if (!windowCallbacks.size && windowResizeHandler) {\n            windowResizeHandler = undefined;\n        }\n    };\n}\n\nfunction resize(a, b) {\n    return typeof a === \"function\" ? resizeWindow(a) : resizeElement(a, b);\n}\n\n/**\n * A time in milliseconds, beyond which we consider the scroll velocity to be 0.\n */\nconst maxElapsed = 50;\nconst createAxisInfo = () => ({\n    current: 0,\n    offset: [],\n    progress: 0,\n    scrollLength: 0,\n    targetOffset: 0,\n    targetLength: 0,\n    containerLength: 0,\n    velocity: 0,\n});\nconst createScrollInfo = () => ({\n    time: 0,\n    x: createAxisInfo(),\n    y: createAxisInfo(),\n});\nconst keys = {\n    x: {\n        length: \"Width\",\n        position: \"Left\",\n    },\n    y: {\n        length: \"Height\",\n        position: \"Top\",\n    },\n};\nfunction updateAxisInfo(element, axisName, info, time) {\n    const axis = info[axisName];\n    const { length, position } = keys[axisName];\n    const prev = axis.current;\n    const prevTime = info.time;\n    axis.current = element[\"scroll\" + position];\n    axis.scrollLength = element[\"scroll\" + length] - element[\"client\" + length];\n    axis.offset.length = 0;\n    axis.offset[0] = 0;\n    axis.offset[1] = axis.scrollLength;\n    axis.progress = progress(0, axis.scrollLength, axis.current);\n    const elapsed = time - prevTime;\n    axis.velocity =\n        elapsed > maxElapsed\n            ? 0\n            : velocityPerSecond(axis.current - prev, elapsed);\n}\nfunction updateScrollInfo(element, info, time) {\n    updateAxisInfo(element, \"x\", info, time);\n    updateAxisInfo(element, \"y\", info, time);\n    info.time = time;\n}\n\nfunction calcInset(element, container) {\n    const inset = { x: 0, y: 0 };\n    let current = element;\n    while (current && current !== container) {\n        if (current instanceof HTMLElement) {\n            inset.x += current.offsetLeft;\n            inset.y += current.offsetTop;\n            current = current.offsetParent;\n        }\n        else if (current.tagName === \"svg\") {\n            /**\n             * This isn't an ideal approach to measuring the offset of <svg /> tags.\n             * It would be preferable, given they behave like HTMLElements in most ways\n             * to use offsetLeft/Top. But these don't exist on <svg />. Likewise we\n             * can't use .getBBox() like most SVG elements as these provide the offset\n             * relative to the SVG itself, which for <svg /> is usually 0x0.\n             */\n            const svgBoundingBox = current.getBoundingClientRect();\n            current = current.parentElement;\n            const parentBoundingBox = current.getBoundingClientRect();\n            inset.x += svgBoundingBox.left - parentBoundingBox.left;\n            inset.y += svgBoundingBox.top - parentBoundingBox.top;\n        }\n        else if (current instanceof SVGGraphicsElement) {\n            const { x, y } = current.getBBox();\n            inset.x += x;\n            inset.y += y;\n            let svg = null;\n            let parent = current.parentNode;\n            while (!svg) {\n                if (parent.tagName === \"svg\") {\n                    svg = parent;\n                }\n                parent = current.parentNode;\n            }\n            current = svg;\n        }\n        else {\n            break;\n        }\n    }\n    return inset;\n}\n\nconst ScrollOffset = {\n    Enter: [\n        [0, 1],\n        [1, 1],\n    ],\n    Exit: [\n        [0, 0],\n        [1, 0],\n    ],\n    Any: [\n        [1, 0],\n        [0, 1],\n    ],\n    All: [\n        [0, 0],\n        [1, 1],\n    ],\n};\n\nconst namedEdges = {\n    start: 0,\n    center: 0.5,\n    end: 1,\n};\nfunction resolveEdge(edge, length, inset = 0) {\n    let delta = 0;\n    /**\n     * If we have this edge defined as a preset, replace the definition\n     * with the numerical value.\n     */\n    if (namedEdges[edge] !== undefined) {\n        edge = namedEdges[edge];\n    }\n    /**\n     * Handle unit values\n     */\n    if (typeof edge === \"string\") {\n        const asNumber = parseFloat(edge);\n        if (edge.endsWith(\"px\")) {\n            delta = asNumber;\n        }\n        else if (edge.endsWith(\"%\")) {\n            edge = asNumber / 100;\n        }\n        else if (edge.endsWith(\"vw\")) {\n            delta = (asNumber / 100) * document.documentElement.clientWidth;\n        }\n        else if (edge.endsWith(\"vh\")) {\n            delta = (asNumber / 100) * document.documentElement.clientHeight;\n        }\n        else {\n            edge = asNumber;\n        }\n    }\n    /**\n     * If the edge is defined as a number, handle as a progress value.\n     */\n    if (typeof edge === \"number\") {\n        delta = length * edge;\n    }\n    return inset + delta;\n}\n\nconst defaultOffset = [0, 0];\nfunction resolveOffset(offset, containerLength, targetLength, targetInset) {\n    let offsetDefinition = Array.isArray(offset) ? offset : defaultOffset;\n    let targetPoint = 0;\n    let containerPoint = 0;\n    if (typeof offset === \"number\") {\n        /**\n         * If we're provided offset: [0, 0.5, 1] then each number x should become\n         * [x, x], so we default to the behaviour of mapping 0 => 0 of both target\n         * and container etc.\n         */\n        offsetDefinition = [offset, offset];\n    }\n    else if (typeof offset === \"string\") {\n        offset = offset.trim();\n        if (offset.includes(\" \")) {\n            offsetDefinition = offset.split(\" \");\n        }\n        else {\n            /**\n             * If we're provided a definition like \"100px\" then we want to apply\n             * that only to the top of the target point, leaving the container at 0.\n             * Whereas a named offset like \"end\" should be applied to both.\n             */\n            offsetDefinition = [offset, namedEdges[offset] ? offset : `0`];\n        }\n    }\n    targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset);\n    containerPoint = resolveEdge(offsetDefinition[1], containerLength);\n    return targetPoint - containerPoint;\n}\n\nconst point = { x: 0, y: 0 };\nfunction getTargetSize(target) {\n    return \"getBBox\" in target && target.tagName !== \"svg\"\n        ? target.getBBox()\n        : { width: target.clientWidth, height: target.clientHeight };\n}\nfunction resolveOffsets(container, info, options) {\n    let { offset: offsetDefinition = ScrollOffset.All } = options;\n    const { target = container, axis = \"y\" } = options;\n    const lengthLabel = axis === \"y\" ? \"height\" : \"width\";\n    const inset = target !== container ? calcInset(target, container) : point;\n    /**\n     * Measure the target and container. If they're the same thing then we\n     * use the container's scrollWidth/Height as the target, from there\n     * all other calculations can remain the same.\n     */\n    const targetSize = target === container\n        ? { width: container.scrollWidth, height: container.scrollHeight }\n        : getTargetSize(target);\n    const containerSize = {\n        width: container.clientWidth,\n        height: container.clientHeight,\n    };\n    /**\n     * Reset the length of the resolved offset array rather than creating a new one.\n     * TODO: More reusable data structures for targetSize/containerSize would also be good.\n     */\n    info[axis].offset.length = 0;\n    /**\n     * Populate the offset array by resolving the user's offset definition into\n     * a list of pixel scroll offets.\n     */\n    let hasChanged = !info[axis].interpolate;\n    const numOffsets = offsetDefinition.length;\n    for (let i = 0; i < numOffsets; i++) {\n        const offset = resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);\n        if (!hasChanged && offset !== info[axis].interpolatorOffsets[i]) {\n            hasChanged = true;\n        }\n        info[axis].offset[i] = offset;\n    }\n    /**\n     * If the pixel scroll offsets have changed, create a new interpolator function\n     * to map scroll value into a progress.\n     */\n    if (hasChanged) {\n        info[axis].interpolate = interpolate(info[axis].offset, defaultOffset$1(offsetDefinition));\n        info[axis].interpolatorOffsets = [...info[axis].offset];\n    }\n    info[axis].progress = info[axis].interpolate(info[axis].current);\n}\n\nfunction measure(container, target = container, info) {\n    /**\n     * Find inset of target within scrollable container\n     */\n    info.x.targetOffset = 0;\n    info.y.targetOffset = 0;\n    if (target !== container) {\n        let node = target;\n        while (node && node !== container) {\n            info.x.targetOffset += node.offsetLeft;\n            info.y.targetOffset += node.offsetTop;\n            node = node.offsetParent;\n        }\n    }\n    info.x.targetLength =\n        target === container ? target.scrollWidth : target.clientWidth;\n    info.y.targetLength =\n        target === container ? target.scrollHeight : target.clientHeight;\n    info.x.containerLength = container.clientWidth;\n    info.y.containerLength = container.clientHeight;\n    /**\n     * In development mode ensure scroll containers aren't position: static as this makes\n     * it difficult to measure their relative positions.\n     */\n    if (process.env.NODE_ENV !== \"production\") {\n        if (container && target && target !== container) {\n            warnOnce(getComputedStyle(container).position !== \"static\", \"Please ensure that the container has a non-static position, like 'relative', 'fixed', or 'absolute' to ensure scroll offset is calculated correctly.\");\n        }\n    }\n}\nfunction createOnScrollHandler(element, onScroll, info, options = {}) {\n    return {\n        measure: () => measure(element, options.target, info),\n        update: (time) => {\n            updateScrollInfo(element, info, time);\n            if (options.offset || options.target) {\n                resolveOffsets(element, info, options);\n            }\n        },\n        notify: () => onScroll(info),\n    };\n}\n\nconst scrollListeners = new WeakMap();\nconst resizeListeners = new WeakMap();\nconst onScrollHandlers = new WeakMap();\nconst getEventTarget = (element) => element === document.documentElement ? window : element;\nfunction scrollInfo(onScroll, { container = document.documentElement, ...options } = {}) {\n    let containerHandlers = onScrollHandlers.get(container);\n    /**\n     * Get the onScroll handlers for this container.\n     * If one isn't found, create a new one.\n     */\n    if (!containerHandlers) {\n        containerHandlers = new Set();\n        onScrollHandlers.set(container, containerHandlers);\n    }\n    /**\n     * Create a new onScroll handler for the provided callback.\n     */\n    const info = createScrollInfo();\n    const containerHandler = createOnScrollHandler(container, onScroll, info, options);\n    containerHandlers.add(containerHandler);\n    /**\n     * Check if there's a scroll event listener for this container.\n     * If not, create one.\n     */\n    if (!scrollListeners.has(container)) {\n        const measureAll = () => {\n            for (const handler of containerHandlers)\n                handler.measure();\n        };\n        const updateAll = () => {\n            for (const handler of containerHandlers) {\n                handler.update(frameData.timestamp);\n            }\n        };\n        const notifyAll = () => {\n            for (const handler of containerHandlers)\n                handler.notify();\n        };\n        const listener = () => {\n            frame.read(measureAll, false, true);\n            frame.read(updateAll, false, true);\n            frame.update(notifyAll, false, true);\n        };\n        scrollListeners.set(container, listener);\n        const target = getEventTarget(container);\n        window.addEventListener(\"resize\", listener, { passive: true });\n        if (container !== document.documentElement) {\n            resizeListeners.set(container, resize(container, listener));\n        }\n        target.addEventListener(\"scroll\", listener, { passive: true });\n    }\n    const listener = scrollListeners.get(container);\n    frame.read(listener, false, true);\n    return () => {\n        var _a;\n        cancelFrame(listener);\n        /**\n         * Check if we even have any handlers for this container.\n         */\n        const currentHandlers = onScrollHandlers.get(container);\n        if (!currentHandlers)\n            return;\n        currentHandlers.delete(containerHandler);\n        if (currentHandlers.size)\n            return;\n        /**\n         * If no more handlers, remove the scroll listener too.\n         */\n        const scrollListener = scrollListeners.get(container);\n        scrollListeners.delete(container);\n        if (scrollListener) {\n            getEventTarget(container).removeEventListener(\"scroll\", scrollListener);\n            (_a = resizeListeners.get(container)) === null || _a === void 0 ? void 0 : _a();\n            window.removeEventListener(\"resize\", scrollListener);\n        }\n    };\n}\n\nfunction scrollTimelineFallback({ source, axis = \"y\" }) {\n    // ScrollTimeline records progress as a percentage CSSUnitValue\n    const currentTime = { value: 0 };\n    const cancel = scrollInfo((info) => {\n        currentTime.value = info[axis].progress * 100;\n    }, { container: source, axis });\n    return { currentTime, cancel };\n}\nconst timelineCache = new Map();\nfunction getTimeline({ source = document.documentElement, axis = \"y\", } = {}) {\n    if (!timelineCache.has(source)) {\n        timelineCache.set(source, {});\n    }\n    const elementCache = timelineCache.get(source);\n    if (!elementCache[axis]) {\n        elementCache[axis] = supportsScrollTimeline()\n            ? new ScrollTimeline({ source, axis })\n            : scrollTimelineFallback({ source, axis });\n    }\n    return elementCache[axis];\n}\nfunction scroll(onScroll, options) {\n    const timeline = getTimeline(options);\n    if (typeof onScroll === \"function\") {\n        return observeTimeline(onScroll, timeline);\n    }\n    else {\n        return onScroll.attachTimeline(timeline);\n    }\n}\n\nconst thresholds = {\n    some: 0,\n    all: 1,\n};\nfunction inView(elementOrSelector, onStart, { root, margin: rootMargin, amount = \"some\" } = {}) {\n    const elements = resolveElements(elementOrSelector);\n    const activeIntersections = new WeakMap();\n    const onIntersectionChange = (entries) => {\n        entries.forEach((entry) => {\n            const onEnd = activeIntersections.get(entry.target);\n            /**\n             * If there's no change to the intersection, we don't need to\n             * do anything here.\n             */\n            if (entry.isIntersecting === Boolean(onEnd))\n                return;\n            if (entry.isIntersecting) {\n                const newOnEnd = onStart(entry);\n                if (typeof newOnEnd === \"function\") {\n                    activeIntersections.set(entry.target, newOnEnd);\n                }\n                else {\n                    observer.unobserve(entry.target);\n                }\n            }\n            else if (onEnd) {\n                onEnd(entry);\n                activeIntersections.delete(entry.target);\n            }\n        });\n    };\n    const observer = new IntersectionObserver(onIntersectionChange, {\n        root,\n        rootMargin,\n        threshold: typeof amount === \"number\" ? amount : thresholds[amount],\n    });\n    elements.forEach((element) => observer.observe(element));\n    return () => observer.disconnect();\n}\n\nfunction getOriginIndex(from, total) {\n    if (from === \"first\") {\n        return 0;\n    }\n    else {\n        const lastIndex = total - 1;\n        return from === \"last\" ? lastIndex : lastIndex / 2;\n    }\n}\nfunction stagger(duration = 0.1, { startDelay = 0, from = 0, ease } = {}) {\n    return (i, total) => {\n        const fromIndex = typeof from === \"number\" ? from : getOriginIndex(from, total);\n        const distance = Math.abs(fromIndex - i);\n        let delay = duration * distance;\n        if (ease) {\n            const maxDelay = total * duration;\n            const easingFunction = easingDefinitionToFunction(ease);\n            delay = easingFunction(delay / maxDelay) * maxDelay;\n        }\n        return startDelay + delay;\n    };\n}\n\nconst isCustomValueType = (v) => {\n    return v && typeof v === \"object\" && v.mix;\n};\nconst getMixer = (v) => (isCustomValueType(v) ? v.mix : undefined);\nfunction transform(...args) {\n    const useImmediate = !Array.isArray(args[0]);\n    const argOffset = useImmediate ? 0 : -1;\n    const inputValue = args[0 + argOffset];\n    const inputRange = args[1 + argOffset];\n    const outputRange = args[2 + argOffset];\n    const options = args[3 + argOffset];\n    const interpolator = interpolate(inputRange, outputRange, {\n        mixer: getMixer(outputRange[0]),\n        ...options,\n    });\n    return useImmediate ? interpolator(inputValue) : interpolator;\n}\n\n/**\n * @deprecated\n *\n * Import as `frame` instead.\n */\nconst sync = frame;\n/**\n * @deprecated\n *\n * Use cancelFrame(callback) instead.\n */\nconst cancelSync = stepsOrder.reduce((acc, key) => {\n    acc[key] = (process) => cancelFrame(process);\n    return acc;\n}, {});\n\nexports.HTMLVisualElement = HTMLVisualElement;\nexports.MotionGlobalConfig = MotionGlobalConfig;\nexports.MotionValue = MotionValue;\nexports.SVGVisualElement = SVGVisualElement;\nexports.SubscriptionManager = SubscriptionManager;\nexports.VisualElement = VisualElement;\nexports.addScaleCorrector = addScaleCorrector;\nexports.addUniqueItem = addUniqueItem;\nexports.animate = animate;\nexports.animateMotionValue = animateMotionValue;\nexports.animateSingleValue = animateSingleValue;\nexports.animateStyle = animateStyle;\nexports.animateTarget = animateTarget;\nexports.animateValue = animateValue;\nexports.anticipate = anticipate;\nexports.applyBoxDelta = applyBoxDelta;\nexports.applyTreeDeltas = applyTreeDeltas;\nexports.backIn = backIn;\nexports.backInOut = backInOut;\nexports.backOut = backOut;\nexports.buildHTMLStyles = buildHTMLStyles;\nexports.buildSVGAttrs = buildSVGAttrs;\nexports.buildTransform = buildTransform;\nexports.camelToDash = camelToDash;\nexports.cancelFrame = cancelFrame;\nexports.cancelSync = cancelSync;\nexports.checkTargetForNewValues = checkTargetForNewValues;\nexports.circIn = circIn;\nexports.circInOut = circInOut;\nexports.circOut = circOut;\nexports.clamp = clamp;\nexports.collectMotionValues = collectMotionValues;\nexports.color = color;\nexports.complex = complex;\nexports.convertBoundingBoxToBox = convertBoundingBoxToBox;\nexports.convertBoxToBoundingBox = convertBoxToBoundingBox;\nexports.createBox = createBox;\nexports.createDelta = createDelta;\nexports.createScopedAnimate = createScopedAnimate;\nexports.cubicBezier = cubicBezier;\nexports.delay = delay;\nexports.distance = distance;\nexports.distance2D = distance2D;\nexports.easeIn = easeIn;\nexports.easeInOut = easeInOut;\nexports.easeOut = easeOut;\nexports.featureDefinitions = featureDefinitions;\nexports.frame = frame;\nexports.frameData = frameData;\nexports.getOrigin = getOrigin;\nexports.getValueTransition = getValueTransition$1;\nexports.has2DTranslate = has2DTranslate;\nexports.hasReducedMotionListener = hasReducedMotionListener;\nexports.hasScale = hasScale;\nexports.hasTransform = hasTransform;\nexports.inView = inView;\nexports.initPrefersReducedMotion = initPrefersReducedMotion;\nexports.instantAnimationState = instantAnimationState;\nexports.interpolate = interpolate;\nexports.isAnimationControls = isAnimationControls;\nexports.isBrowser = isBrowser;\nexports.isCSSVariableName = isCSSVariableName;\nexports.isControllingVariants = isControllingVariants;\nexports.isCustomValue = isCustomValue;\nexports.isForcedMotionValue = isForcedMotionValue;\nexports.isKeyframesTarget = isKeyframesTarget;\nexports.isMotionValue = isMotionValue;\nexports.isRefObject = isRefObject;\nexports.isSVGElement = isSVGElement;\nexports.isSVGTag = isSVGTag;\nexports.isVariantLabel = isVariantLabel;\nexports.isVariantNode = isVariantNode;\nexports.measurePageBox = measurePageBox;\nexports.millisecondsToSeconds = millisecondsToSeconds;\nexports.mirrorEasing = mirrorEasing;\nexports.mix = mix;\nexports.motionValue = motionValue;\nexports.moveItem = moveItem;\nexports.noop = noop;\nexports.optimizedAppearDataAttribute = optimizedAppearDataAttribute;\nexports.optimizedAppearDataId = optimizedAppearDataId;\nexports.percent = percent;\nexports.pipe = pipe;\nexports.prefersReducedMotion = prefersReducedMotion;\nexports.progress = progress;\nexports.px = px;\nexports.removeItem = removeItem;\nexports.renderSVG = renderSVG;\nexports.resolveVariant = resolveVariant;\nexports.resolveVariantFromProps = resolveVariantFromProps;\nexports.reverseEasing = reverseEasing;\nexports.scaleCorrectors = scaleCorrectors;\nexports.scalePoint = scalePoint;\nexports.scrapeMotionValuesFromProps = scrapeMotionValuesFromProps;\nexports.scrapeMotionValuesFromProps$1 = scrapeMotionValuesFromProps$1;\nexports.scroll = scroll;\nexports.scrollInfo = scrollInfo;\nexports.secondsToMilliseconds = secondsToMilliseconds;\nexports.setValues = setValues;\nexports.spring = spring;\nexports.stagger = stagger;\nexports.steps = steps;\nexports.sync = sync;\nexports.transform = transform;\nexports.transformBox = transformBox;\nexports.transformProps = transformProps;\nexports.translateAxis = translateAxis;\nexports.variantPriorityOrder = variantPriorityOrder;\nexports.visualElementStore = visualElementStore;\nexports.warnOnce = warnOnce;\nexports.wrap = wrap;\n\n};"],
"names":["shadow$provide","global","require","module","exports","isRefObject","ref","Object","prototype","hasOwnProperty","call","isVariantLabel","v","Array","isArray","isAnimationControls","start","isControllingVariants","props","animate","variantProps","some","name","isVariantNode","variants","isForcedMotionValue","key","layout","layoutId","transformProps","has","startsWith","undefined","scaleCorrectors","buildTransform","transform","enableHardwareAcceleration","allowTransformNone","transformIsDefault","transformTemplate","transformString","i","numTransforms","transformPropOrder","translateAlias","z","trim","isString","buildHTMLStyles","state","latestValues","options","style","vars","transformOrigin","hasTransform","hasTransformOrigin","transformIsNone","value","isCSSVariableName","valueType","numberValueTypes","valueAsType","default","originX","originY","originZ","buildSVGPath","attrs","length","spacing","offset","useDashCase","pathLength","keys","dashKeys","camelKeys","px","pathSpacing","array","buildSVGAttrs","attrX","attrY","attrScale","pathOffset","latest","isSVGTag","viewBox","dimensions","origin","x","width","pxOriginY","y","height","pxOriginX","scale","renderHTML","element","styleProp","projection","assign","getProjectionStyles","setProperty","renderSVG","renderState","_styleProp","setAttribute","camelCaseAttributes","camelToDash","scrapeMotionValuesFromProps$1","prevProps","newValues","getVelocity","scrapeMotionValuesFromProps","targetKey","indexOf","charAt","toUpperCase","substring","resolveVariantFromProps","definition","custom","currentValues","currentVelocity","createRenderStep","runNextFrame","thisFrame","Queue","nextFrame","numToRun","isProcessing","flushNextFrame","toKeepAlive","WeakSet","step","schedule","callback","keepAlive","immediate","queue","addToCurrentFrame","add","order","cancel","remove","delete","process","frameData","clear","getCurrent","visualElement","current","values","forEach","get","velocity","resolveVariant","getProps","isWaapiSupportedEasing","easing","supportedWaapiEasing","isBezierDefinition","every","mapEasingToNativeEasing","cubicBezierAsString","map","animateStyle","valueName","keyframes","delay","duration","repeat","repeatType","ease","times","keyframeOptions","fill","iterations","direction","getFinalKeyframe","index","cubicBezier","mX1","mY1","mX2","mY2","noop","t","currentX","currentT","lowerBound","upperBound","subdivisionPrecision","Math","abs","subdivisionMaxIterations","a2","a1","hueToRgb","p","q","hslaToRgba","hue","saturation","lightness","alpha","red","green","blue","round","asRGBA","color","type","getColorType","invariant","model","parse","hsla","tokenise","info","regex","countKey","token","matches","tokenised","match","replace","push","analyseComplexValue","originalValue","toString","numVars","numColors","numNumbers","includes","cssVarTokeniser","colorTokeniser","numberTokeniser","parseComplexValue","createTransformer","source","numValues","output","getMixer$1","target","test","mixColor","mixImmediate","mixComplex","detectMixerFactory","mixArray","mixObject","mixNumber","createMixers","customMixer","mixers","mixerFactory","numMixers","mixer","easingFunction","reduce","combineFunctions","interpolate","input","isClamp","inputLength","reverse","interpolator","progressInRange","progress","clamp","fillOffset","remaining","min","offsetProgress","to","defaultOffset$1","arr","convertOffsetToTimes","o","defaultEasing","easeInOut","splice","keyframeValues","easingFunctions","isEasingArray","easingDefinitionToFunction","done","absoluteTimes","mapTimeToKeyframe","calculatedDuration","next","calcGeneratorVelocity","resolveValue","prevT","max","velocitySampleDuration","frameDuration","findSpring","bounce","mass","envelope","warning","dampingRatio","minDamping","maxDamping","minDuration","maxDuration$1","undampedFreq","exponentialDecay","safeMin","sqrt","exp","c","derivative","delta","d","e","pow","f","g","factor","a","approximateRoot","isNaN","stiffness","damping","initialGuess","rootIterations","result","isSpringType","getSpringOptions","springOptions","isResolvedFromDuration","physicsKeys","durationKeys","derived","spring","restDelta","restSpeed","initialVelocity","initialDelta","undampedAngularFreq","milliseconds","isGranularScale","resolveSpring","angularFreq","sin","cos","dampedAngularFreq","freqForT","sinh","cosh","isBelowDisplacementThreshold","inertia","power","timeConstant","bounceDamping","bounceStiffness","modifyTarget","amplitude","ideal","calcLatest","applyFriction","timeReachedBoundary","spring$1","checkCatchBoundary","hasUpdatedFrame","calcGeneratorDuration","generator","maxGeneratorDuration","timeStep","Infinity","animateValue","autoplay","driver","frameloopDriver","keyframes$1","repeatDelay","onPlay","onStop","onComplete","onUpdate","speed","hasStopped","resolveFinishedPromise","currentFinishedPromise","updateFinishedPromise","Promise","resolve","animationDriver","generatorFactory","types","mapNumbersToKeyframes","mirroredGenerator","playState","holdTime","startTime","cancelTime","resolvedDuration","totalDuration","currentTime","tick","timestamp","timeWithoutDelay","isInDelayPhase","elapsed","frameGenerator","currentIteration","floor","iterationProgress","isAnimationFinished","stop","play","now","controls","then","reject","time","newTime","newSpeed","pause","complete","sample","memo","createAcceleratedAnimation","supportsWaapi","acceleratedValues","pendingCancel","sampleAnimation","pregeneratedKeyframes","maxDuration","sampleDelta","animation","owner","cancelAnimation","safeCancel","frame","update","onfinish","animation.onfinish","set","attachTimeline","timeline","playbackRate","cancelFrame","setWithVelocity","finish","createInstantAnimation","setValue","applyDefaultFilter","slice","split","number","floatRegex","unit","defaultValue","maxDefaults","getAnimatableNone","defaultValueType","defaultValueTypes","filter","complex","getKeyframes","transition","isTargetAnimatable","isAnimatable","defaultOrigin","from","animatableTemplateValue","noneKeyframeIndexes","isTransitionDefined","when","_delay","delayChildren","staggerChildren","staggerDirection","getValueTransition$1","isWillChangeMotionValue","addUniqueItem","item","removeItem","warnOnce","condition","message","warned","console","warn","motionValue","init","MotionValue","setTarget","resolved","transitionEnd","makeTargetAnimatable","hasValue","getValue","addValue","setVariants","variantLabels","reversedLabels","variant","getVariant","variantChildren","child","checkTargetForNewValues","_a","_b","newValueKeys","numNewValues","targetValue","readValue","parseFloat","valueTypes","find","testValueType","setBaseTarget","getOrigin","transitionOrigin","shouldBlockAnimation","protectedKeys","needsAnimating","shouldBlock","hasKeyframesChanged","animateTarget","transitionOverride","getDefaultTransition","willChange","animations","animationTypeState","animationState","getState","valueTarget","valueTransition","window","HandoffAppearAnimations","appearId","optimizedAppearDataAttribute","isHandoff","canSkip","animateMotionValue","shouldReduceMotion","all","convertBoundingBoxToBox","top","left","right","bottom","transformBoxPoints","point","transformPoint","topLeft","bottomRight","hasScale","scaleX","scaleY","has2DTranslate","rotate","rotateX","rotateY","is2DTranslate","scalePoint","originPoint","applyPointDelta","translate","boxScale","applyAxisDelta","axis","applyBoxDelta","box","snapToDefault","Number","isInteger","translateAxis","distance","transformAxis","transforms","scaleKey","originKey","axisOrigin","transformBox","xKeys","yKeys","resolveElements","elements","scope","selectorCache","root","document","querySelectorAll","Element","observeTimeline","prevProgress","onFrame","percentage","isSVGElement","SVGElement","tagName","getVariableValue","depth","maxDepth","splitCSSVariableRegex","exec","fallback","getComputedStyle","getPropertyValue","trimmed","isCSSVariableToken","resolveCSSVariables","removeNonTranslationalTransform","removedTransforms","nonTranslationalTransformKeys","render","initPrefersReducedMotion","hasReducedMotionListener","isBrowser","matchMedia","motionMediaQuery","addListener","setReducedMotionPreferences","prefersReducedMotion","animateSingleValue","motionValue$1","createGeneratorEasing","calcNextTime","prev","labels","compareByTime","b","at","createAnimationsFromSequence","sequence","defaultTransition","sequenceTransition","defaultDuration","animationDefinitions","Map","sequences","elementCache","timeLabels","prevTime","segment","subject","resolveValueSequence","valueKeyframes","valueSequence","elementIndex","numElements","valueKeyframesAsList","remainingTransition","calculatedDelay","numKeyframes","absoluteDelta","isNumber","springTransition","springEasing","targetTime","remainder","unshift","keyframe","mix","wrap","subjectSequence","getSubjectSequence","getValueSequence","valueSequences","sort","valueOffset","valueEasing","defaultSegmentEasing","animateElements","elementOrSelector","visualElementStore","presenceContext","visualState","node","SVGVisualElement","HTMLVisualElement","mount","GroupPlaybackControls","animateSequence","notifyTarget","contentRect","borderBoxSize","resizeHandlers","handler","contentSize","size","inlineSize","blockSize","getBBox","offsetWidth","offsetHeight","notifyAll","entries","resizeElement","observer","ResizeObserver","elementHandlers","Set","observe","unobserve","createWindowResizeHandler","windowResizeHandler","innerWidth","innerHeight","windowCallbacks","addEventListener","resizeWindow","resize","updateAxisInfo","axisName","position","scrollLength","maxElapsed","resolveEdge","edge","inset","namedEdges","asNumber","endsWith","documentElement","clientWidth","clientHeight","measure","container","targetOffset","offsetLeft","offsetTop","offsetParent","targetLength","scrollWidth","scrollHeight","containerLength","createOnScrollHandler","onScroll","offsetDefinition","ScrollOffset","All","lengthLabel","HTMLElement","svgBoundingBox","getBoundingClientRect","parentElement","parentBoundingBox","SVGGraphicsElement","svg","parent","parentNode","containerSize","hasChanged","numOffsets","containerPoint","targetPoint","targetSize","defaultOffset","targetInset","interpolatorOffsets","notify","scrollInfo","containerHandlers","onScrollHandlers","createAxisInfo","containerHandler","scrollListeners","measureAll","updateAll","listener","read","passive","resizeListeners","currentHandlers","scrollListener","removeEventListener","scrollTimelineFallback","getTimeline","timelineCache","supportsScrollTimeline","ScrollTimeline","str","toLowerCase","optimizedAppearDataId","variantPriorityOrder","featureProps","exit","drag","focus","hover","tap","pan","inView","featureDefinitions","isEnabled","transformPerspective","checkStringStartsWith","colorRegex","singleColorRegex","createUnitType","degrees","percent","vh","vw","progressPercentage","int","borderWidth","borderTopWidth","borderRightWidth","borderBottomWidth","borderLeftWidth","borderRadius","radius","borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius","maxWidth","maxHeight","padding","paddingTop","paddingRight","paddingBottom","paddingLeft","margin","marginTop","marginRight","marginBottom","marginLeft","rotateZ","scaleZ","skew","skewX","skewY","translateX","translateY","translateZ","perspective","opacity","zIndex","fillOpacity","strokeOpacity","numOctaves","tag","any","constructor","scheduled","stepsOrder","steps","createRenderBatcher","scheduleNextBatch","allowKeepAlive","useDefaultElapsed","acc","processStep","stepId","processBatch","performance","maxElapsed$1","requestAnimationFrame","check","exports.warning","exports.invariant","Error","instantAnimationState","linear","easeIn","easeOut","circIn","circOut","backIn","backOut","mirrorEasing","reverseEasing","acos","circInOut","backInOut","anticipate","easingLookup","x1","y1","x2","y2","isColorString","testProp","splitColor","aName","bName","cName","rgbUnit","rgba","alpha$1","hex","parseHex","r","parseInt","mixLinearColor","fromExpo","colorTypes","fromRGBA","toRGBA","blended","cssVariableRegex","convertNumbersToZero","getAnimatableNone$1","parsed","transformer","blendValue","fromThis","template","originStats","targetStats","transformers","toFromDifference","passTimestamp","decay","tween","underDampedSpring","keyframesTransition","valueKey","functionRegex","functions","join","backgroundColor","outlineColor","stroke","borderColor","borderTopColor","borderRightColor","borderBottomColor","borderLeftColor","WebkitFilter","MotionGlobalConfig","skipAnimations","originKeyframe","targetKeyframe","isOriginAnimatable","acceleratedAnimation","SubscriptionManager","subscriptions","numSubscriptions","getSize","collectMotionValues","version","lastUpdated","timeDelta","canTrackVelocity","events","updateAndNotify","this.updateAndNotify","postRender","scheduleVelocityCheck","change","velocityChange","renderRequest","this.scheduleVelocityCheck","velocityCheck","this.velocityCheck","hasAnimated","onChange","subscription","on","eventName","unsubscribe","clearListeners","eventManagers","attach","passiveEffect","stopPassiveEffect","jump","getPrevious","startAnimation","animationStart","animationComplete","clearAnimation","animationCancel","isAnimating","destroy","dimensionValueTypes","auto","createAxisDelta","createBox","WeakMap","Boolean","onResolve","onReject","catch","getAll","propName","setAll","newValue","cancelAll","cancelTimeline","runAll","methodName","positionalKeys","isPositionalKey","getTranslateFromMatrix","pos2","pos3","_bbox","matrix3d","matrix","transformKeys","positionalValues","convertChangedValueTypes","changedKeys","originBbox","measureViewportBox","elementComputedStyle","display","setStaticValue","targetBbox","checkAndConvertChangedValueTypes","removedTransformValues","hasAttemptedToRemoveTransformValues","changedValueTypeKeys","targetPositionalKeys","fromType","fromIndex","toType","scrollY","pageYOffset","convertedTarget","scrollTo","featureNames","numFeatures","propEventHandlers","numVariantProps","VisualElement","reducedMotionConfig","children","features","valueSubscriptions","prevMotionValues","propEventSubscriptions","notifyUpdate","this.notifyUpdate","this.render","triggerBuild","renderInstance","scheduleRender","this.scheduleRender","baseTarget","initialValues","initial","manuallyAnimateOnMount","initialMotionValues","_props","_prevProps","instance","removeFromVariantTree","addVariantChild","bindToMotionValue","unmount","valueIsTransform","removeOnChange","latestValue","isTransformDirty","removeOnRenderRequest","sortNodePosition","other","sortInstanceNodePosition","loadFeatures","renderedProps","isStrict","preloadedFeatures","initialLayoutGroupConfig","ProjectionNodeConstructor","MeasureLayout","ignoreStrict","strictMessage","FeatureConstructor","ProjectionNode","MeasureLayoutComponent","dragConstraints","layoutScroll","layoutRoot","setOptions","alwaysMeasureLayout","animationType","initialPromotionConfig","updateFeatures","feature","isMounted","build","measureInstanceViewportBox","getStaticValue","canMutate","makeTargetAnimatableFromInstance","prevPresenceContext","nextValue","prevValue","existingValue","removeValue","handleChildMotionValue","getTransformPagePoint","transformPagePoint","getClosestVariantNode","getVariantContext","startAtParent","context","prop","closestVariantNode","removeValueFromRenderState","getBaseTargetFromProps","readValueFromInstance","getBaseTarget","valueFromInitial","args","DOMVisualElement","compareDocumentPosition","transformValues","arguments","defaultType","getAttribute","computedStyle","childSubscription","textContent","rangeSize","createScopedAnimate","scopedAnimate","valueOrElementOrSequence","Enter","Exit","Any","center","end","thresholds","sync","cancelSync","addScaleCorrector","correctors","applyTreeDeltas","treeScale","treePath","isSharedTransition","treeLength","projectionDelta","scroll","convertBoxToBoundingBox","createDelta","timeout","checkElapsed","distance2D","xDelta","yDelta","getValueTransition","onStart","rootMargin","amount","activeIntersections","IntersectionObserver","onIntersectionChange","entry","onEnd","isIntersecting","newOnEnd","threshold","disconnect","isCustomValue","toValue","isKeyframesTarget","isMotionValue","measurePageBox","rootProjectionNode","viewportBox","millisecondsToSeconds","moveItem","toIndex","startIndex","endIndex","pipe","secondsToMilliseconds","seconds","setValues","stagger","startDelay","total","lastIndex","maxDelay","useImmediate","argOffset","inputValue","outputRange","inputRange"]
}
